/************************************
 *
 * File : ${task.name}_Validation.cic
 * 
 * This file is automatically generated.
 *
*************************************/

#include <string.h>

/////////////////////////////////////
// include header section
/////////////////////////////////////

// ##DEFINE_SECTION::START
// ##DEFINE_SECTION::END


TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
<#list task.port as port>
  <#if port.direction == "OUTPUT">
STATIC int port_${port.name};
STATIC int port_${port.name}_input;
  </#if>
</#list>
// ##DEFINE_PORT_SECTION::END


#define MAX_COMPARE_COUNT (${task.faultTolerance.number})


<#assign total_port_num = 0>

<#list task.port as port>
  <#if port.direction == "OUTPUT">
#define s_nPortDataSize_${port.name} (${port.sampleSize?c} * ${port.rate[0].rate})
//const int s_nPortDataSize_${port.name} = (${port.sampleSize?c} * ${port.rate[0].rate});
    <#assign total_port_num = total_port_num + 1>
  </#if>
</#list>

#define TOTAL_OUTPUT_PORT_NUMBER (${total_port_num})
#define MAJORITY_NOT_SET (-1);

<#if task.faultTolerance.type == "REEXECUTION">
static int s_nMajoritySet[TOTAL_OUTPUT_PORT_NUMBER];
</#if>

/////////////////////////////////////
// init code
/////////////////////////////////////



TASK_INIT
{
	uem_result result;
// ##INIT_PORT_SECTION::START
<#list task.port as port>
  <#if port.direction == "OUTPUT">
	result = UFPort_Initialize(TASK_ID, "${port.name}", &port_${port.name});
	ERRIFGOTO(result, _EXIT);
	result = UFPort_Initialize(TASK_ID, "${port.name}_input", &port_${port.name}_input);
	ERRIFGOTO(result, _EXIT);
  </#if>
</#list>
// ##INIT_PORT_SECTION::END

    // TODO: task initialize code

<#if task.faultTolerance.type == "REEXECUTION">
	{
		int nLoop = 0;
		for(nLoop = 0 ; nLoop < TOTAL_OUTPUT_PORT_NUMBER ; nLoop++)
		{
    		s_nMajoritySet[nLoop] = MAJORITY_NOT_SET;
		}
	}
</#if>
_EXIT:
	return;
}


/////////////////////////////////////
// go code
/////////////////////////////////////




static int compareMemory(unsigned char *pMemory, int nItemsToCompare, int nCompareSize, int *pnMajorityCount)
{
	int nLoop = 0;
	int nCount = 0;
	int nSubLoop = 0;
	int nMajority = MAJORITY_NOT_SET;
	int nMajorityCount = 0;

	for(nLoop = 0; nLoop < nItemsToCompare ; nLoop++)
	{
		nCount = 0;
		for(nSubLoop = 0 ; nSubLoop < nItemsToCompare ; nSubLoop++)
		{
			if(memcmp(&pMemory[nLoop * nCompareSize], &pMemory[nSubLoop * nCompareSize], nCompareSize) == 0)
			{
				nCount++;
			}
		}

		if(nCount > nMajorityCount)
		{
			nMajority = nLoop;
			nMajorityCount = nCount;

			if(nMajorityCount > MAX_COMPARE_COUNT/2)
			{
				break;
			}
		}
	}

	*pnMajorityCount = nMajorityCount;

	return nMajority;
}

<#list task.port as port>
  <#if port.direction == "OUTPUT">
static unsigned char s_pInputData_${port.name}[s_nPortDataSize_${port.name} * MAX_COMPARE_COUNT];
  </#if>
</#list>

TASK_GO
{
	uem_result result;
	int nMajority = 0;
	int nMajorityCount = 0;
	int nDataRead = 0;
	int nDataWritten = 0;

<#if task.faultTolerance.type == "ACTIVE_REPLICATION">
  <#list task.port as port>
    <#if port.direction == "OUTPUT">
	result = UFPort_ReadFromQueue(port_${port.name}_input, s_pInputData_${port.name}, s_nPortDataSize_${port.name} * MAX_COMPARE_COUNT, 0, &nDataRead);
	ERRIFGOTO(result, _EXIT);  
    </#if>
  </#list>	
    
  <#list task.port as port>
    <#if port.direction == "OUTPUT">
	nMajority = compareMemory(s_pInputData_${port.name}, MAX_COMPARE_COUNT, s_nPortDataSize_${port.name}, &nMajorityCount);
	
	result = UFPort_WriteToQueue(port_${port.name}, &s_pInputData_${port.name}[nMajority * s_nPortDataSize_${port.name}], s_nPortDataSize_${port.name}, 0, &nDataWritten);
	ERRIFGOTO(result, _EXIT);
    </#if>
  </#list>

<#elseif task.faultTolerance.type == "REEXECUTION">
	int nLoop = 0;
	int nCurrentIteration = 0;
	uem_bool bAllMajoritySet = TRUE;
	
	result = UFLoop_GetIteration(THIS_TASK_ID, THIS_THREAD_ID, &nCurrentIteration);
	ERRIFGOTO(result, _EXIT);

  <#list task.port as port>
    <#if port.direction == "OUTPUT">
	result = UFPort_ReadFromQueue(port_${port.name}_input, &s_pInputData_${port.name}[nCurrentIteration * s_nPortDataSize_${port.name}], s_nPortDataSize_${port.name}, 0, &nDataRead);
	ERRIFGOTO(result, _EXIT);
    </#if>
  </#list>
  
  	if(nCurrentIteration + 1 > MAX_COMPARE_COUNT/2)
	{
  <#assign output_port_index = 0>
  <#list task.port as port>
    <#if port.direction == "OUTPUT">	
		nMajority = compareMemory(s_pInputData_${port.name}, nCurrentIteration + 1, s_nPortDataSize_${port.name}, &nMajorityCount);
		if(nMajorityCount > MAX_COMPARE_COUNT/2 || nCurrentIteration == MAX_COMPARE_COUNT - 1)
		{
			s_nMajoritySet[${output_port_index}] = nMajority;
		}
		<#assign output_port_index = output_port_index + 1>
    </#if>
  </#list>
	}

	for(nLoop = 0 ; nLoop < TOTAL_OUTPUT_PORT_NUMBER ; nLoop++)
	{
		if(s_nMajoritySet[nLoop] < 0)
		{
			bAllMajoritySet = FALSE;
			break;
		}
	}

	if(bAllMajoritySet == TRUE)
	{
		result = UFLoop_StopNextIteration(THIS_TASK_ID);
		ERRIFGOTO(result, _EXIT);

		// send all
  <#assign output_port_index = 0>
  <#list task.port as port>
    <#if port.direction == "OUTPUT">
		result = UFPort_WriteToQueue(port_${port.name}, &s_pInputData_${port.name}[s_nMajoritySet[${output_port_index}] * s_nPortDataSize_${port.name}], s_nPortDataSize_${port.name}, 0, &nDataWritten);
		ERRIFGOTO(result, _EXIT);
		<#assign output_port_index++>
    </#if>
  </#list>

		// clear
		for(nLoop = 0 ; nLoop < TOTAL_OUTPUT_PORT_NUMBER ; nLoop++)
		{
			s_nMajoritySet[nLoop] = MAJORITY_NOT_SET;
		}
	}
</#if>

_EXIT:
	return;
}



/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code

}

TASK_CODE_END

