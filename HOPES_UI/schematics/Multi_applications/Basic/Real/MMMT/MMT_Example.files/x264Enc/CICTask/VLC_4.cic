/************************************
 *
 * File : VLC_4.cic
 * Date : Jul 23, 2009 11:35 AM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////

// ##DEFINE_SECTION::START
// ##DEFINE_SECTION::END

TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_p14;
// ##DEFINE_PORT_SECTION::END

/* Define macro for prototyping functions on ANSI & non-ANSI compilers */
#ifndef ARGS
#if defined(__STDC__) || defined(__cplusplus)
#define ARGS(args) args
#else
#define ARGS(args) ()
#endif
#endif

#include <stdint.h>
#include <stdio.h>
#include "x264.h"
// by jwlee 2008.05.28
#include "ME.h"

/* Define constants TRUE and FALSE for portability */
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

typedef struct
{
    int i_type;
    int i_first_mb;
    int i_last_mb;		
    int i_frame_num;		
    int i_idr_pic_id;
    int i_poc_lsb;		
    int b_num_ref_idx_override;		
    int i_qp;
    int i_qp_delta;		
    int i_disable_deblocking_filter_idc;		
} SliceHeader;

typedef struct{
    int i_cbp_luma;
    int i_cbp_chroma;
    struct IntBlock16x16 luma4x4_out;
    struct IntArr16x15 luma_residual_ac;
    struct IntArr48 non_zero_count;
    struct IntArr8x15 chroma_residual_ac;
    struct IntArr2x4 chroma_dc;
    struct IntArr16 luma4x4;
    SliceHeader msgSliceHeader;
    int intFrameType;
    encoder_send_info e_s_info;
} EncVLCPacket;



/* Define a complex data type if one has not been defined */
#if !defined(COMPLEX_DATA)
#define COMPLEX_DATA 1
typedef struct complex_data { double real; double imag; } complex;
#endif

#define CGC_MOD(a,b) ((a)>=(b) ? (a-b):(a))
#ifndef __CIC__
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#endif
/* original global declaration */
#define REFERENCE_FRAME_COUNT 1
#define MAX_GOP_SIZE		250
#define MIN_GOP_SIZE		25
#define SCENE_CUT			40 // How aggressively to insert extra I-frames
#define MIN_QP_VALUE		10
#define MAX_QP_VALUE		51
#define BITRATE_VALUE		1000
#define MAX_QP_STEP			4
#define MAX_ME_RANGE		16
#define SUBPIXEL_ME_P		5
#define FPS_NUM				25
#define FPS_DEN				2
#define RATE_TOLERANCE		1.0
#define IP_FACTOR			1.4

#define LEVEL_IDC			51
#define LEVEL_FRAME_SIZE	36864 	// max frame size (macroblocks)
#define LEVEL_DPB			70778880 // max decoded picture buffer (bytes)
#define LEVEL_MBPS			983040   // max macroblock processing rate (macroblocks/sec)
#define LEVEL_MV_RANGE		512

#define FRAME_TYPE_IDR		0
#define FRAME_TYPE_P		1

#define SPS_MB_WIDTH ((176+15)/16) 
#define SPS_MB_HEIGHT ((144+15)/16)

#define SPS_CROP_RIGHT		((-176)&5)
#define SPS_CROP_BOTTOM		((-144)&15)
#define SPS_B_CROP			(SPS_CROP_RIGHT||SPS_CROP_BOTTOM)
#define SPS_MAX_FRAME_NUM	8
#define SPS_MAX_POC_LSB		(SPS_MAX_FRAME_NUM+1)
#define X264_MIN(a,b) ( (a)<(b) ? (a) : (b) )
#define X264_MAX(a,b) ( (a)>(b) ? (a) : (b) )
STATIC const int x264_mb_pred_mode4x4_fix[13] =
{
    -1,
    I_PRED_4x4_V,   I_PRED_4x4_H,   I_PRED_4x4_DC,
    I_PRED_4x4_DDL, I_PRED_4x4_DDR, I_PRED_4x4_VR,
    I_PRED_4x4_HD,  I_PRED_4x4_VL,  I_PRED_4x4_HU,
    I_PRED_4x4_DC,  I_PRED_4x4_DC,  I_PRED_4x4_DC
};
#define x264_mb_pred_mode4x4_fix(t) x264_mb_pred_mode4x4_fix[(t)+1]		
typedef struct
{
    int i_bits;
    int i_size;
} vlc_t;

/* XXX: don't forget to change it if you change vlc_t */
#define MKVLC( a, b ) { a, b }
STATIC const vlc_t x264_coeff_token[5][17*4] =
{
    /* table 0 */
    {
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x5, 6 ), /* str=000101 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x7, 8 ), /* str=00000111 */
        MKVLC( 0x4, 6 ), /* str=000100 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x7, 9 ), /* str=000000111 */
        MKVLC( 0x6, 8 ), /* str=00000110 */
        MKVLC( 0x5, 7 ), /* str=0000101 */
        MKVLC( 0x3, 5 ), /* str=00011 */

        MKVLC( 0x7, 10 ), /* str=0000000111 */
        MKVLC( 0x6, 9 ), /* str=000000110 */
        MKVLC( 0x5, 8 ), /* str=00000101 */
        MKVLC( 0x3, 6 ), /* str=000011 */

        MKVLC( 0x7, 11 ), /* str=00000000111 */
        MKVLC( 0x6, 10 ), /* str=0000000110 */
        MKVLC( 0x5, 9 ), /* str=000000101 */
        MKVLC( 0x4, 7 ), /* str=0000100 */

        MKVLC( 0xf, 13 ), /* str=0000000001111 */
        MKVLC( 0x6, 11 ), /* str=00000000110 */
        MKVLC( 0x5, 10 ), /* str=0000000101 */
        MKVLC( 0x4, 8 ), /* str=00000100 */

        MKVLC( 0xb, 13 ), /* str=0000000001011 */
        MKVLC( 0xe, 13 ), /* str=0000000001110 */
        MKVLC( 0x5, 11 ), /* str=00000000101 */
        MKVLC( 0x4, 9 ), /* str=000000100 */

        MKVLC( 0x8, 13 ), /* str=0000000001000 */
        MKVLC( 0xa, 13 ), /* str=0000000001010 */
        MKVLC( 0xd, 13 ), /* str=0000000001101 */
        MKVLC( 0x4, 10 ), /* str=0000000100 */

        MKVLC( 0xf, 14 ), /* str=00000000001111 */
        MKVLC( 0xe, 14 ), /* str=00000000001110 */
        MKVLC( 0x9, 13 ), /* str=0000000001001 */
        MKVLC( 0x4, 11 ), /* str=00000000100 */

        MKVLC( 0xb, 14 ), /* str=00000000001011 */
        MKVLC( 0xa, 14 ), /* str=00000000001010 */
        MKVLC( 0xd, 14 ), /* str=00000000001101 */
        MKVLC( 0xc, 13 ), /* str=0000000001100 */

        MKVLC( 0xf, 15 ), /* str=000000000001111 */
        MKVLC( 0xe, 15 ), /* str=000000000001110 */
        MKVLC( 0x9, 14 ), /* str=00000000001001 */
        MKVLC( 0xc, 14 ), /* str=00000000001100 */

        MKVLC( 0xb, 15 ), /* str=000000000001011 */
        MKVLC( 0xa, 15 ), /* str=000000000001010 */
        MKVLC( 0xd, 15 ), /* str=000000000001101 */
        MKVLC( 0x8, 14 ), /* str=00000000001000 */

        MKVLC( 0xf, 16 ), /* str=0000000000001111 */
        MKVLC( 0x1, 15 ), /* str=000000000000001 */
        MKVLC( 0x9, 15 ), /* str=000000000001001 */
        MKVLC( 0xc, 15 ), /* str=000000000001100 */

        MKVLC( 0xb, 16 ), /* str=0000000000001011 */
        MKVLC( 0xe, 16 ), /* str=0000000000001110 */
        MKVLC( 0xd, 16 ), /* str=0000000000001101 */
        MKVLC( 0x8, 15 ), /* str=000000000001000 */

        MKVLC( 0x7, 16 ), /* str=0000000000000111 */
        MKVLC( 0xa, 16 ), /* str=0000000000001010 */
        MKVLC( 0x9, 16 ), /* str=0000000000001001 */
        MKVLC( 0xc, 16 ), /* str=0000000000001100 */

        MKVLC( 0x4, 16 ), /* str=0000000000000100 */
        MKVLC( 0x6, 16 ), /* str=0000000000000110 */
        MKVLC( 0x5, 16 ), /* str=0000000000000101 */
        MKVLC( 0x8, 16 ), /* str=0000000000001000 */
    },

    /* table 1 */
    {
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0xb, 6 ), /* str=001011 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x7, 6 ), /* str=000111 */
        MKVLC( 0x7, 5 ), /* str=00111 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x7, 7 ), /* str=0000111 */
        MKVLC( 0xa, 6 ), /* str=001010 */
        MKVLC( 0x9, 6 ), /* str=001001 */
        MKVLC( 0x5, 4 ), /* str=0101 */

        MKVLC( 0x7, 8 ), /* str=00000111 */
        MKVLC( 0x6, 6 ), /* str=000110 */
        MKVLC( 0x5, 6 ), /* str=000101 */
        MKVLC( 0x4, 4 ), /* str=0100 */

        MKVLC( 0x4, 8 ), /* str=00000100 */
        MKVLC( 0x6, 7 ), /* str=0000110 */
        MKVLC( 0x5, 7 ), /* str=0000101 */
        MKVLC( 0x6, 5 ), /* str=00110 */

        MKVLC( 0x7, 9 ), /* str=000000111 */
        MKVLC( 0x6, 8 ), /* str=00000110 */
        MKVLC( 0x5, 8 ), /* str=00000101 */
        MKVLC( 0x8, 6 ), /* str=001000 */

        MKVLC( 0xf, 11 ), /* str=00000001111 */
        MKVLC( 0x6, 9 ), /* str=000000110 */
        MKVLC( 0x5, 9 ), /* str=000000101 */
        MKVLC( 0x4, 6 ), /* str=000100 */

        MKVLC( 0xb, 11 ), /* str=00000001011 */
        MKVLC( 0xe, 11 ), /* str=00000001110 */
        MKVLC( 0xd, 11 ), /* str=00000001101 */
        MKVLC( 0x4, 7 ), /* str=0000100 */

        MKVLC( 0xf, 12 ), /* str=000000001111 */
        MKVLC( 0xa, 11 ), /* str=00000001010 */
        MKVLC( 0x9, 11 ), /* str=00000001001 */
        MKVLC( 0x4, 9 ), /* str=000000100 */

        MKVLC( 0xb, 12 ), /* str=000000001011 */
        MKVLC( 0xe, 12 ), /* str=000000001110 */
        MKVLC( 0xd, 12 ), /* str=000000001101 */
        MKVLC( 0xc, 11 ), /* str=00000001100 */

        MKVLC( 0x8, 12 ), /* str=000000001000 */
        MKVLC( 0xa, 12 ), /* str=000000001010 */
        MKVLC( 0x9, 12 ), /* str=000000001001 */
        MKVLC( 0x8, 11 ), /* str=00000001000 */

        MKVLC( 0xf, 13 ), /* str=0000000001111 */
        MKVLC( 0xe, 13 ), /* str=0000000001110 */
        MKVLC( 0xd, 13 ), /* str=0000000001101 */
        MKVLC( 0xc, 12 ), /* str=000000001100 */

        MKVLC( 0xb, 13 ), /* str=0000000001011 */
        MKVLC( 0xa, 13 ), /* str=0000000001010 */
        MKVLC( 0x9, 13 ), /* str=0000000001001 */
        MKVLC( 0xc, 13 ), /* str=0000000001100 */

        MKVLC( 0x7, 13 ), /* str=0000000000111 */
        MKVLC( 0xb, 14 ), /* str=00000000001011 */
        MKVLC( 0x6, 13 ), /* str=0000000000110 */
        MKVLC( 0x8, 13 ), /* str=0000000001000 */

        MKVLC( 0x9, 14 ), /* str=00000000001001 */
        MKVLC( 0x8, 14 ), /* str=00000000001000 */
        MKVLC( 0xa, 14 ), /* str=00000000001010 */
        MKVLC( 0x1, 13 ), /* str=0000000000001 */

        MKVLC( 0x7, 14 ), /* str=00000000000111 */
        MKVLC( 0x6, 14 ), /* str=00000000000110 */
        MKVLC( 0x5, 14 ), /* str=00000000000101 */
        MKVLC( 0x4, 14 ), /* str=00000000000100 */
    },
    /* table 2 */
    {
        MKVLC( 0xf, 4 ), /* str=1111 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0xf, 6 ), /* str=001111 */
        MKVLC( 0xe, 4 ), /* str=1110 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0xb, 6 ), /* str=001011 */
        MKVLC( 0xf, 5 ), /* str=01111 */
        MKVLC( 0xd, 4 ), /* str=1101 */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x8, 6 ), /* str=001000 */
        MKVLC( 0xc, 5 ), /* str=01100 */
        MKVLC( 0xe, 5 ), /* str=01110 */
        MKVLC( 0xc, 4 ), /* str=1100 */

        MKVLC( 0xf, 7 ), /* str=0001111 */
        MKVLC( 0xa, 5 ), /* str=01010 */
        MKVLC( 0xb, 5 ), /* str=01011 */
        MKVLC( 0xb, 4 ), /* str=1011 */

        MKVLC( 0xb, 7 ), /* str=0001011 */
        MKVLC( 0x8, 5 ), /* str=01000 */
        MKVLC( 0x9, 5 ), /* str=01001 */
        MKVLC( 0xa, 4 ), /* str=1010 */

        MKVLC( 0x9, 7 ), /* str=0001001 */
        MKVLC( 0xe, 6 ), /* str=001110 */
        MKVLC( 0xd, 6 ), /* str=001101 */
        MKVLC( 0x9, 4 ), /* str=1001 */

        MKVLC( 0x8, 7 ), /* str=0001000 */
        MKVLC( 0xa, 6 ), /* str=001010 */
        MKVLC( 0x9, 6 ), /* str=001001 */
        MKVLC( 0x8, 4 ), /* str=1000 */

        MKVLC( 0xf, 8 ), /* str=00001111 */
        MKVLC( 0xe, 7 ), /* str=0001110 */
        MKVLC( 0xd, 7 ), /* str=0001101 */
        MKVLC( 0xd, 5 ), /* str=01101 */

        MKVLC( 0xb, 8 ), /* str=00001011 */
        MKVLC( 0xe, 8 ), /* str=00001110 */
        MKVLC( 0xa, 7 ), /* str=0001010 */
        MKVLC( 0xc, 6 ), /* str=001100 */

        MKVLC( 0xf, 9 ), /* str=000001111 */
        MKVLC( 0xa, 8 ), /* str=00001010 */
        MKVLC( 0xd, 8 ), /* str=00001101 */
        MKVLC( 0xc, 7 ), /* str=0001100 */

        MKVLC( 0xb, 9 ), /* str=000001011 */
        MKVLC( 0xe, 9 ), /* str=000001110 */
        MKVLC( 0x9, 8 ), /* str=00001001 */
        MKVLC( 0xc, 8 ), /* str=00001100 */

        MKVLC( 0x8, 9 ), /* str=000001000 */
        MKVLC( 0xa, 9 ), /* str=000001010 */
        MKVLC( 0xd, 9 ), /* str=000001101 */
        MKVLC( 0x8, 8 ), /* str=00001000 */

        MKVLC( 0xd, 10 ), /* str=0000001101 */
        MKVLC( 0x7, 9 ), /* str=000000111 */
        MKVLC( 0x9, 9 ), /* str=000001001 */
        MKVLC( 0xc, 9 ), /* str=000001100 */

        MKVLC( 0x9, 10 ), /* str=0000001001 */
        MKVLC( 0xc, 10 ), /* str=0000001100 */
        MKVLC( 0xb, 10 ), /* str=0000001011 */
        MKVLC( 0xa, 10 ), /* str=0000001010 */

        MKVLC( 0x5, 10 ), /* str=0000000101 */
        MKVLC( 0x8, 10 ), /* str=0000001000 */
        MKVLC( 0x7, 10 ), /* str=0000000111 */
        MKVLC( 0x6, 10 ), /* str=0000000110 */

        MKVLC( 0x1, 10 ), /* str=0000000001 */
        MKVLC( 0x4, 10 ), /* str=0000000100 */
        MKVLC( 0x3, 10 ), /* str=0000000011 */
        MKVLC( 0x2, 10 ), /* str=0000000010 */
    },

    /* table 3 */
    {
        MKVLC( 0x3, 6 ), /* str=000011 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x4, 6 ), /* str=000100 */
        MKVLC( 0x5, 6 ), /* str=000101 */
        MKVLC( 0x6, 6 ), /* str=000110 */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x8, 6 ), /* str=001000 */
        MKVLC( 0x9, 6 ), /* str=001001 */
        MKVLC( 0xa, 6 ), /* str=001010 */
        MKVLC( 0xb, 6 ), /* str=001011 */

        MKVLC( 0xc, 6 ), /* str=001100 */
        MKVLC( 0xd, 6 ), /* str=001101 */
        MKVLC( 0xe, 6 ), /* str=001110 */
        MKVLC( 0xf, 6 ), /* str=001111 */

        MKVLC( 0x10, 6 ), /* str=010000 */
        MKVLC( 0x11, 6 ), /* str=010001 */
        MKVLC( 0x12, 6 ), /* str=010010 */
        MKVLC( 0x13, 6 ), /* str=010011 */

        MKVLC( 0x14, 6 ), /* str=010100 */
        MKVLC( 0x15, 6 ), /* str=010101 */
        MKVLC( 0x16, 6 ), /* str=010110 */
        MKVLC( 0x17, 6 ), /* str=010111 */

        MKVLC( 0x18, 6 ), /* str=011000 */
        MKVLC( 0x19, 6 ), /* str=011001 */
        MKVLC( 0x1a, 6 ), /* str=011010 */
        MKVLC( 0x1b, 6 ), /* str=011011 */

        MKVLC( 0x1c, 6 ), /* str=011100 */
        MKVLC( 0x1d, 6 ), /* str=011101 */
        MKVLC( 0x1e, 6 ), /* str=011110 */
        MKVLC( 0x1f, 6 ), /* str=011111 */

        MKVLC( 0x20, 6 ), /* str=100000 */
        MKVLC( 0x21, 6 ), /* str=100001 */
        MKVLC( 0x22, 6 ), /* str=100010 */
        MKVLC( 0x23, 6 ), /* str=100011 */

        MKVLC( 0x24, 6 ), /* str=100100 */
        MKVLC( 0x25, 6 ), /* str=100101 */
        MKVLC( 0x26, 6 ), /* str=100110 */
        MKVLC( 0x27, 6 ), /* str=100111 */

        MKVLC( 0x28, 6 ), /* str=101000 */
        MKVLC( 0x29, 6 ), /* str=101001 */
        MKVLC( 0x2a, 6 ), /* str=101010 */
        MKVLC( 0x2b, 6 ), /* str=101011 */

        MKVLC( 0x2c, 6 ), /* str=101100 */
        MKVLC( 0x2d, 6 ), /* str=101101 */
        MKVLC( 0x2e, 6 ), /* str=101110 */
        MKVLC( 0x2f, 6 ), /* str=101111 */

        MKVLC( 0x30, 6 ), /* str=110000 */
        MKVLC( 0x31, 6 ), /* str=110001 */
        MKVLC( 0x32, 6 ), /* str=110010 */
        MKVLC( 0x33, 6 ), /* str=110011 */

        MKVLC( 0x34, 6 ), /* str=110100 */
        MKVLC( 0x35, 6 ), /* str=110101 */
        MKVLC( 0x36, 6 ), /* str=110110 */
        MKVLC( 0x37, 6 ), /* str=110111 */

        MKVLC( 0x38, 6 ), /* str=111000 */
        MKVLC( 0x39, 6 ), /* str=111001 */
        MKVLC( 0x3a, 6 ), /* str=111010 */
        MKVLC( 0x3b, 6 ), /* str=111011 */

        MKVLC( 0x3c, 6 ), /* str=111100 */
        MKVLC( 0x3d, 6 ), /* str=111101 */
        MKVLC( 0x3e, 6 ), /* str=111110 */
        MKVLC( 0x3f, 6 ), /* str=111111 */
    },

    /* table 4 */
    {
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x7, 6 ), /* str=000111 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x4, 6 ), /* str=000100 */
        MKVLC( 0x6, 6 ), /* str=000110 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x3, 6 ), /* str=000011 */
        MKVLC( 0x3, 7 ), /* str=0000011 */
        MKVLC( 0x2, 7 ), /* str=0000010 */
        MKVLC( 0x5, 6 ), /* str=000101 */

        MKVLC( 0x2, 6 ), /* str=000010 */
        MKVLC( 0x3, 8 ), /* str=00000011 */
        MKVLC( 0x2, 8 ), /* str=00000010 */
        MKVLC( 0x0, 7 ), /* str=0000000 */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */

        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    }
};

STATIC const vlc_t x264_level_prefix[16] =
{
    MKVLC( 0x01,  1 ),
    MKVLC( 0x01,  2 ),
    MKVLC( 0x01,  3 ),
    MKVLC( 0x01,  4 ),
    MKVLC( 0x01,  5 ),
    MKVLC( 0x01,  6 ),
    MKVLC( 0x01,  7 ),
    MKVLC( 0x01,  8 ),
    MKVLC( 0x01,  9 ),
    MKVLC( 0x01, 10 ),
    MKVLC( 0x01, 11 ),
    MKVLC( 0x01, 12 ),
    MKVLC( 0x01, 13 ),
    MKVLC( 0x01, 14 ),
    MKVLC( 0x01, 15 ),
    MKVLC( 0x01, 16 )
};

/* [i_total_coeff-1][i_total_zeros] */
STATIC const vlc_t x264_total_zeros[15][16] =
{
    { /* i_total 1 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x3, 4 ), /* str=0011 */
        MKVLC( 0x2, 4 ), /* str=0010 */
        MKVLC( 0x3, 5 ), /* str=00011 */
        MKVLC( 0x2, 5 ), /* str=00010 */
        MKVLC( 0x3, 6 ), /* str=000011 */
        MKVLC( 0x2, 6 ), /* str=000010 */
        MKVLC( 0x3, 7 ), /* str=0000011 */
        MKVLC( 0x2, 7 ), /* str=0000010 */
        MKVLC( 0x3, 8 ), /* str=00000011 */
        MKVLC( 0x2, 8 ), /* str=00000010 */
        MKVLC( 0x3, 9 ), /* str=000000011 */
        MKVLC( 0x2, 9 ), /* str=000000010 */
        MKVLC( 0x1, 9 ), /* str=000000001 */
    },
    { /* i_total 2 */
        MKVLC( 0x7, 3 ), /* str=111 */
        MKVLC( 0x6, 3 ), /* str=110 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x5, 4 ), /* str=0101 */
        MKVLC( 0x4, 4 ), /* str=0100 */
        MKVLC( 0x3, 4 ), /* str=0011 */
        MKVLC( 0x2, 4 ), /* str=0010 */
        MKVLC( 0x3, 5 ), /* str=00011 */
        MKVLC( 0x2, 5 ), /* str=00010 */
        MKVLC( 0x3, 6 ), /* str=000011 */
        MKVLC( 0x2, 6 ), /* str=000010 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 3 */
        MKVLC( 0x5, 4 ), /* str=0101 */
        MKVLC( 0x7, 3 ), /* str=111 */
        MKVLC( 0x6, 3 ), /* str=110 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 4 ), /* str=0100 */
        MKVLC( 0x3, 4 ), /* str=0011 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 4 ), /* str=0010 */
        MKVLC( 0x3, 5 ), /* str=00011 */
        MKVLC( 0x2, 5 ), /* str=00010 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 4 */
        MKVLC( 0x3, 5 ), /* str=00011 */
        MKVLC( 0x7, 3 ), /* str=111 */
        MKVLC( 0x5, 4 ), /* str=0101 */
        MKVLC( 0x4, 4 ), /* str=0100 */
        MKVLC( 0x6, 3 ), /* str=110 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 4 ), /* str=0011 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 4 ), /* str=0010 */
        MKVLC( 0x2, 5 ), /* str=00010 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x0, 5 ), /* str=00000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 5 */
        MKVLC( 0x5, 4 ), /* str=0101 */
        MKVLC( 0x4, 4 ), /* str=0100 */
        MKVLC( 0x3, 4 ), /* str=0011 */
        MKVLC( 0x7, 3 ), /* str=111 */
        MKVLC( 0x6, 3 ), /* str=110 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 4 ), /* str=0010 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x0, 5 ), /* str=00000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 6 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x7, 3 ), /* str=111 */
        MKVLC( 0x6, 3 ), /* str=110 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 7 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 8 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 9 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x0, 6 ), /* str=000000 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 10 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x0, 5 ), /* str=00000 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 11 */
        MKVLC( 0x0, 4 ), /* str=0000 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 12 */
        MKVLC( 0x0, 4 ), /* str=0000 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 13 */
        MKVLC( 0x0, 3 ), /* str=000 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 14 */
        MKVLC( 0x0, 2 ), /* str=00 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_total 15 */
        MKVLC( 0x0, 1 ), /* str=0 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
};

/* [i_total_coeff-1][i_total_zeros] */
STATIC const vlc_t x264_total_zeros_dc[3][4] =
{
    {
        MKVLC( 0x01, 1 ), /* 1  */
        MKVLC( 0x01, 2 ), /* 01 */
        MKVLC( 0x01, 3 ), /* 001*/
        MKVLC( 0x00, 3 )  /* 000*/
    },
    {
        MKVLC( 0x01, 1 ), /* 1  */
        MKVLC( 0x01, 2 ), /* 01 */
        MKVLC( 0x00, 2 ), /* 00 */
        MKVLC( 0x00, 0 )  /*    */
    },
    {
        MKVLC( 0x01, 1 ), /* 1  */
        MKVLC( 0x00, 1 ), /* 0  */
        MKVLC( 0x00, 0 ), /*    */
        MKVLC( 0x00, 0 )  /*    */
    }
};

/* x264_run_before[__MIN( i_zero_left -1, 6 )][run_before] */
STATIC const vlc_t x264_run_before[7][15] =
{
    { /* i_zero_left 1 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x0, 1 ), /* str=0 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_zero_left 2 */
        MKVLC( 0x1, 1 ), /* str=1 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x0, 2 ), /* str=00 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_zero_left 3 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x0, 2 ), /* str=00 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_zero_left 4 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x1, 2 ), /* str=01 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 3 ), /* str=000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_zero_left 5 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x2, 2 ), /* str=10 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x0, 3 ), /* str=000 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_zero_left 6 */
        MKVLC( 0x3, 2 ), /* str=11 */
        MKVLC( 0x0, 3 ), /* str=000 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
        MKVLC( 0x0, 0 ), /* str= */
    },
    { /* i_zero_left 7 */
        MKVLC( 0x7, 3 ), /* str=111 */
        MKVLC( 0x6, 3 ), /* str=110 */
        MKVLC( 0x5, 3 ), /* str=101 */
        MKVLC( 0x4, 3 ), /* str=100 */
        MKVLC( 0x3, 3 ), /* str=011 */
        MKVLC( 0x2, 3 ), /* str=010 */
        MKVLC( 0x1, 3 ), /* str=001 */
        MKVLC( 0x1, 4 ), /* str=0001 */
        MKVLC( 0x1, 5 ), /* str=00001 */
        MKVLC( 0x1, 6 ), /* str=000001 */
        MKVLC( 0x1, 7 ), /* str=0000001 */
        MKVLC( 0x1, 8 ), /* str=00000001 */
        MKVLC( 0x1, 9 ), /* str=000000001 */
        MKVLC( 0x1, 10 ), /* str=0000000001 */
        MKVLC( 0x1, 11 ), /* str=00000000001 */
    },
};
STATIC const int x264_mb_partition_listX_table[2][17] =
{
    {
        1, 1, 1, 1, /* D_L0_* */
        0, 0, 0, 0, /* D_L1_* */
        1, 1, 1, 1, /* D_BI_* */
        0,          /* D_DIRECT_8x8 */
        0, 0, 0, 0  /* 8x8 .. 16x16 */
    },
    {
        0, 0, 0, 0, /* D_L0_* */
        1, 1, 1, 1, /* D_L1_* */
        1, 1, 1, 1, /* D_BI_* */
        0,          /* D_DIRECT_8x8 */
        0, 0, 0, 0  /* 8x8 .. 16x16 */
    }
};		
typedef struct
{
    int size;
    uint8_t data[176*144];
} bs_data;

#define X264_ANALYSE_I4x4       0x0001  /* Analyse i4x4 */
#define X264_ANALYSE_PSUB16x16  0x0010  /* Analyse p16x8, p8x16 and p8x8 */
#define X264_ANALYSE_PSUB8x8    0x0020  /* Analyse p8x4, p4x8, p4x4 */
#define X264_ANALYSE_INTRA 		(X264_ANALYSE_I4x4)
#define X264_ANALYSE_INTER 		(X264_ANALYSE_I4x4 | X264_ANALYSE_PSUB16x16 | X264_ANALYSE_PSUB8x8)
#define DATA_MAX 3000000
#define QP_CONSTANT 26
#define QP_CONSTANT_I 23
typedef struct
{
    int i_ref_idc;  /* nal_priority_e */
    int i_type;     /* nal_unit_type_e */

    /* This data are raw payload */
    int     i_payload;
    uint8_t *p_payload;
} x264_nal_t;
FILE *fp264_1986 = NULL;
int i_intFrameType_1967_phase;
int i_intMBType_1968;
int i_intIntra16x16_pred_mode_1969;
int i_msgIntra4x4_pred_mode_1970;
int i_msgRef_1971;
int i_msgMV_1972;
int i_msgNon_zero_count_1973;
int i_intCbp_luma_1974;
int i_intCbp_chroma_1975;
int i_intChroma_pred_mode_1976;
int i_intPartition_1977;
int i_msgSub_partition_1978;
int i_msgLuma16x16_dc_1979;
int i_msgLuma4x4_1980;
int i_msgChroma_dc_1981;
int i_msgResidual_luma_ac_1982;
int i_msgResidual_chroma_ac_1983;
int i_msgSliceHeader_1984_phase;
bs_data o_msgBS_data_1947;
int o_msgBS_data_1985_phase;
int output_1948;
int output_1987_phase;
int output_1949[99];
int output_1989;
int output_1950[99];
int output_1991;
struct IntArr48 output_1951[99];
int output_1993;
struct ref_mb output_1952[99];
int output_1995;
struct mv_mb output_1953[99];
int output_1997;
struct IntArr48 output_1954[99];
int output_1999;
int output_1955[99];
int output_2001;
int output_1956[99];
int output_2003;
int output_1957[99];
int output_2005;
int output_1958[99];
int output_2007;
struct IntArr4 output_1959[99];
int output_2009;
struct IntArr16 output_1960[99];
int output_2011;
struct IntBlock16x16 output_1961[99];
int output_2013;
struct IntArr2x4 output_1962[99];
int output_2015;
struct IntArr16x15 output_1963[99];
int output_2017;
struct IntArr8x15 output_1964[99];
int output_2019;
SliceHeader output_1965;
int output_2021_phase;
int output_1966;
/* new global declaration */
/*
int fid_1988;//
int fid_2000;//
int fid_2002;//
int fid_2004;//
int fid_2012;//
int fid_2014;//
int fid_2016;//
int fid_2018;//
int fid_2020;//
int fid_2022;//
int fid_2023;//

// added by jwlee

int fid_5060; */
// by iloy 2008.05.24
encoder_send_info vlc_r_info;


STATIC inline int bs_size_ue( unsigned int val )
{
    STATIC const int i_size0_254[255] =
    {
        1, 3, 3, 5, 5, 5, 5, 7, 7, 7, 7, 7, 7, 7, 7,
        9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
        11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
        11,11,11,11,11,11,11,11,11,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
        13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
        13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
        13,13,13,13,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
        15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
        15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
        15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
        15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
        15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15
    };

    if( val < 255 )
    {
        return i_size0_254[val];
    }
    else
    {
        int i_size = 0;

        val++;

        if( val >= 0x10000 )
        {
            i_size += 32;
            val = (val >> 16) - 1;
        }
        if( val >= 0x100 )
        {
            i_size += 16;
            val = (val >> 8) - 1;
        }
        return i_size0_254[val] + i_size;
    }
}
STATIC inline int bs_size_te( int x, int val )
{
    if( x == 1 )
    {
        return 1;
    }
    else if( x > 1 )
    {
        return bs_size_ue( val );
    }
    return 0;
}
typedef struct bs_s
{
    uint8_t *p_start;
    uint8_t *p;
    uint8_t *p_end;

    int     i_left;    /* i_count number of available bits */
    int     i_bits_encoded; /* RD only */
} bs_t;

STATIC inline void bs_init( bs_t *s, void *p_data, int i_data )
{
    s->p_start = (uint8_t*)p_data;
    s->p       = (uint8_t*)p_data;
    s->p_end   = s->p + i_data;
    s->i_left  = 8;
}

STATIC inline int bs_pos( bs_t *s )
{
    return( 8 * ( s->p - s->p_start ) + 8 - s->i_left );
}

STATIC inline int bs_eof( bs_t *s )
{
    return( s->p >= s->p_end ? 1: 0 );
}

STATIC inline uint32_t bs_read( bs_t *s, int i_count )
{
    STATIC uint32_t i_mask[33] ={0x00,
        0x01,      0x03,      0x07,      0x0f,
        0x1f,      0x3f,      0x7f,      0xff,
        0x1ff,     0x3ff,     0x7ff,     0xfff,
        0x1fff,    0x3fff,    0x7fff,    0xffff,
        0x1ffff,   0x3ffff,   0x7ffff,   0xfffff,
        0x1fffff,  0x3fffff,  0x7fffff,  0xffffff,
        0x1ffffff, 0x3ffffff, 0x7ffffff, 0xfffffff,
        0x1fffffff,0x3fffffff,0x7fffffff,0xffffffff};
    int      i_shr;
    uint32_t i_result = 0;

    while( i_count > 0 )
    {
        if( s->p >= s->p_end )
        {
            break;
        }

        if( ( i_shr = s->i_left - i_count ) >= 0 )
        {
            /* more in the buffer than requested */
            i_result |= ( *s->p >> i_shr )&i_mask[i_count];
            s->i_left -= i_count;
            if( s->i_left == 0 )
            {
                s->p++;
                s->i_left = 8;
            }
            return( i_result );
        }
        else
        {
            /* less in the buffer than requested */
            i_result |= (*s->p&i_mask[s->i_left]) << -i_shr;
            i_count  -= s->i_left;
            s->p++;
            s->i_left = 8;
        }
    }

    return( i_result );
}

STATIC inline uint32_t bs_read1( bs_t *s )
{

    if( s->p < s->p_end )
    {
        unsigned int i_result;

        s->i_left--;
        i_result = ( *s->p >> s->i_left )&0x01;
        if( s->i_left == 0 )
        {
            s->p++;
            s->i_left = 8;
        }
        return i_result;
    }

    return 0;
}

STATIC inline uint32_t bs_show( bs_t *s, int i_count )
{
    if( s->p < s->p_end && i_count > 0 )
    {
        uint32_t i_cache = ((s->p[0] << 24)+(s->p[1] << 16)+(s->p[2] << 8)+s->p[3]) << (8-s->i_left);
        return( i_cache >> ( 32 - i_count) );
    }
    return 0;
}

/* TODO optimize */
STATIC inline void bs_skip( bs_t *s, int i_count )
{
    s->i_left -= i_count;

    while( s->i_left <= 0 )
    {
        s->p++;
        s->i_left += 8;
    }
}

STATIC inline int bs_read_ue( bs_t *s )
{
    int i = 0;

    while( bs_read1( s ) == 0 && s->p < s->p_end && i < 32 )
    {
        i++;
    }
    return( ( 1 << i) - 1 + bs_read( s, i ) );
}

STATIC inline int bs_read_se( bs_t *s )
{
    int val = bs_read_ue( s );

    return val&0x01 ? (val+1)/2 : -(val/2);
}

STATIC inline int bs_read_te( bs_t *s, int x )
{
    if( x == 1 )
    {
        return 1 - bs_read1( s );
    }
    else if( x > 1 )
    {
        return bs_read_ue( s );
    }
    return 0;
}

STATIC inline void bs_write( bs_t *s, int i_count, uint32_t i_bits )
{
    if( s->p >= s->p_end - 4 )
        return;
    while( i_count > 0 )
    {
        if( i_count < 32 )
            i_bits &= (1<<i_count)-1;
        if( i_count < s->i_left )
        {
            *s->p = (*s->p << i_count) | i_bits;
            s->i_left -= i_count;
            break;
        }
        else
        {
            *s->p = (*s->p << s->i_left) | (i_bits >> (i_count - s->i_left));
            i_count -= s->i_left;
            s->p++;
            s->i_left = 8;
        }
    }
}

STATIC inline void bs_write1( bs_t *s, uint32_t i_bit )
{
    if( s->p < s->p_end )
    {
        *s->p <<= 1;
        *s->p |= i_bit;
        s->i_left--;
        if( s->i_left == 0 )
        {
            s->p++;
            s->i_left = 8;
        }
    }
}

STATIC inline void bs_align_0( bs_t *s )
{
    if( s->i_left != 8 )
    {
        *s->p <<= s->i_left;
        s->i_left = 8;
        s->p++;
    }
}

STATIC inline void bs_align_1( bs_t *s )
{
    if( s->i_left != 8 )
    {
        *s->p <<= s->i_left;
        *s->p |= (1 << s->i_left) - 1;
        s->i_left = 8;
        s->p++;
    }
}

STATIC inline void bs_align( bs_t *s )
{
    bs_align_0( s );
}

/* golomb functions */
STATIC inline void bs_write_ue( bs_t *s, unsigned int val )
{
    int i_size = 0;
    STATIC const int i_size0_255[256] =
    {
        1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
        6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
        8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8
    };

    if( val == 0 )
    {
        bs_write1( s, 1 );
    }
    else
    {
        unsigned int tmp = ++val;

        if( tmp >= 0x00010000 )
        {
            i_size += 16;
            tmp >>= 16;
        }
        if( tmp >= 0x100 )
        {
            i_size += 8;
            tmp >>= 8;
        }
        i_size += i_size0_255[tmp];

        bs_write( s, 2 * i_size - 1, val );
    }
}

STATIC inline void bs_write_se( bs_t *s, int val )
{
    bs_write_ue( s, val <= 0 ? -val * 2 : val * 2 - 1);
}

STATIC inline void bs_write_te( bs_t *s, int x, int val )
{
    if( x == 1 )
    {
        bs_write1( s, 1&~val );
    }
    else if( x > 1 )
    {
        bs_write_ue( s, val );
    }
}

STATIC inline void bs_rbsp_trailing( bs_t *s )
{
    bs_write1( s, 1 );
    if( s->i_left != 8 )
    {
        bs_write( s, s->i_left, 0x00 );
    }
}

STATIC inline int bs_size_se( int val )
{
    return bs_size_ue( val <= 0 ? -val * 2 : val * 2 - 1);
}		
STATIC inline int x264_median( int a, int b, int c )
{
    int min = a, max =a;
    if( b < min )
        min = b;
    else
        max = b;    /* no need to do 'b > max' (more consuming than always doing affectation) */

    if( c < min )
        min = c;
    else if( c > max )
        max = c;

    return a + b + c - min - max;
}
STATIC void x264_mb_predict_mv(int16_t mv[2][48][2], int8_t ref[2][48], int i_list, int idx, int i_width, int mvp[2], int i_partition)
{
    const int i8 = x264_scan8[idx];
    const int i_ref= ref[i_list][i8];
    int     i_refa = ref[i_list][i8 - 1];
    int16_t *mv_a  = mv[i_list][i8 - 1];
    int     i_refb = ref[i_list][i8 - 8];
    int16_t *mv_b  = mv[i_list][i8 - 8];
    int     i_refc = ref[i_list][i8 - 8 + i_width ];
    int16_t *mv_c  = mv[i_list][i8 - 8 + i_width];
    int i_count;

    if( (idx&0x03) == 3 || ( i_width == 2 && (idx&0x3) == 2 )|| i_refc == -2 )
    {
        i_refc = ref[i_list][i8 - 8 - 1];
        mv_c   = mv[i_list][i8 - 8 - 1];
    }

    if( i_partition == D_16x8 )
    {
        if( idx == 0 && i_refb == i_ref )
        {
            mvp[0] = mv_b[0];
            mvp[1] = mv_b[1];
            return;
        }
        else if( idx != 0 && i_refa == i_ref )
        {
            mvp[0] = mv_a[0];
            mvp[1] = mv_a[1];
            return;
        }
    }
    else if( i_partition == D_8x16 )
    {
        if( idx == 0 && i_refa == i_ref )
        {
            mvp[0] = mv_a[0];
            mvp[1] = mv_a[1];
            return;
        }
        else if( idx != 0 && i_refc == i_ref )
        {
            mvp[0] = mv_c[0];
            mvp[1] = mv_c[1];
            return;
        }
    }

    i_count = 0;
    if( i_refa == i_ref ) i_count++;
    if( i_refb == i_ref ) i_count++;
    if( i_refc == i_ref ) i_count++;

    if( i_count > 1 )
    {
        mvp[0] = x264_median( mv_a[0], mv_b[0], mv_c[0] );
        mvp[1] = x264_median( mv_a[1], mv_b[1], mv_c[1] );
    }
    else if( i_count == 1 )
    {
        if( i_refa == i_ref )
        {
            mvp[0] = mv_a[0];
            mvp[1] = mv_a[1];
        }
        else if( i_refb == i_ref )
        {
            mvp[0] = mv_b[0];
            mvp[1] = mv_b[1];
        }
        else
        {					mvp[0] = mv_c[0];
            mvp[1] = mv_c[1];

        }
    }
    else if( i_refb == -2 && i_refc == -2 && i_refa != -2 )
    {
        mvp[0] = mv_a[0];
        mvp[1] = mv_a[1];
    }
    else
    {
        mvp[0] = x264_median( mv_a[0], mv_b[0], mv_c[0] );
        mvp[1] = x264_median( mv_a[1], mv_b[1], mv_c[1] );
    }
}
STATIC const uint8_t intra4x4_cbp_to_golomb[48]=
{
    3, 29, 30, 17, 31, 18, 37,  8, 32, 38, 19,  9, 20, 10, 11,  2,
    16, 33, 34, 21, 35, 22, 39,  4, 36, 40, 23,  5, 24,  6,  7,  1,
    41, 42, 43, 25, 44, 26, 46, 12, 45, 47, 27, 13, 28, 14, 15,  0
};
STATIC const uint8_t inter_cbp_to_golomb[48]=
{
    0,  2,  3,  7,  4,  8, 17, 13,  5, 18,  9, 14, 10, 15, 16, 11,
    1, 32, 33, 36, 34, 37, 44, 40, 35, 45, 38, 41, 39, 42, 43, 19,
    6, 24, 25, 20, 26, 21, 46, 28, 27, 47, 22, 29, 23, 30, 31, 12
};
STATIC const uint8_t mb_type_b_to_golomb[3][9]=
{
    { 4,  8, 12, 10,  6, 14, 16, 18, 20 }, /* D_16x8 */
    { 5,  9, 13, 11,  7, 15, 17, 19, 21 }, /* D_8x16 */
    { 1, -1, -1, -1,  2, -1, -1, -1,  3 }  /* D_16x16 */
};
STATIC const uint8_t sub_mb_type_p_to_golomb[4]=
{
    3, 1, 2, 0
};
STATIC const uint8_t sub_mb_type_b_to_golomb[13]=
{
    10,  4,  5,  1, 11,  6,  7,  2, 12,  8,  9,  3,  0
};

#define BLOCK_INDEX_CHROMA_DC   (-1)
#define BLOCK_INDEX_LUMA_DC     (-2)

STATIC inline void bs_write_vlc( bs_t *s, vlc_t v )
{
    bs_write( s, v.i_size, v.i_bits );
}

STATIC int x264_mb_predict_intra4x4_mode(int intra4x4_pred_mode[48], int idx )
{
    const int ma = intra4x4_pred_mode[x264_scan8[idx] - 1];
    const int mb = intra4x4_pred_mode[x264_scan8[idx] - 8];
    const int m  = X264_MIN( x264_mb_pred_mode4x4_fix[ma+1], x264_mb_pred_mode4x4_fix[mb+1] );

    if( m < 0 )
        return I_PRED_4x4_DC;

    return m;
}

STATIC int x264_mb_predict_non_zero_code( int non_zero_count[48], int idx )
{
    const int za = non_zero_count[x264_scan8[idx] - 1];
    const int zb = non_zero_count[x264_scan8[idx] - 8];

    int i_ret = za + zb;

    if( i_ret < 0x80 )
    {
        i_ret = ( i_ret + 1 ) >> 1;
    }
    return i_ret & 0x7f;
}

STATIC void block_residual_write_cavlc( int non_zero_count[48], bs_t *s, int i_idx, int *l, int i_count )
{
    int level[16], run[16];
    int i_total, i_trailing;
    int i_total_zero;
    int i_last;
    unsigned int i_sign;

    int i;
    int i_zero_left;
    int i_suffix_length;

    /* first find i_last */
    i_last = i_count - 1;
    while( i_last >= 0 && l[i_last] == 0 )
    {
        i_last--;
    }

    i_sign = 0;
    i_total = 0;
    i_trailing = 0;
    i_total_zero = 0;

    if( i_last >= 0 )
    {
        int b_trailing = 1;
        int idx = 0;

        /* level and run and total */
        while( i_last >= 0 )
        {
            level[idx] = l[i_last--];

            run[idx] = 0;
            while( i_last >= 0 && l[i_last] == 0 )
            {
                run[idx]++;
                i_last--;
            }

            i_total++;
            i_total_zero += run[idx];

            if( b_trailing && abs( level[idx] ) == 1 && i_trailing < 3 )
            {
                i_sign <<= 1;
                if( level[idx] < 0 )
                {
                    i_sign |= 0x01;
                }

                i_trailing++;
            }
            else
            {
                b_trailing = 0;
            }

            idx++;
        }
    }

    /* total/trailing */
    if( i_idx == BLOCK_INDEX_CHROMA_DC )
    {
        bs_write_vlc( s, x264_coeff_token[4][i_total*4+i_trailing] );
    }
    else
    {
        /* x264_mb_predict_non_zero_code return 0 <-> (16+16+1)>>1 = 16 */
        STATIC const int ct_index[17] = {0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,3 };
        int nC;

        if( i_idx == BLOCK_INDEX_LUMA_DC )
        {
            nC = x264_mb_predict_non_zero_code( non_zero_count, 0 );
        }
        else
        {
            nC = x264_mb_predict_non_zero_code( non_zero_count, i_idx );
        }

        bs_write_vlc( s, x264_coeff_token[ct_index[nC]][i_total*4+i_trailing] );
    }

    if( i_total <= 0 )
    {
        return;
    }

    i_suffix_length = i_total > 10 && i_trailing < 3 ? 1 : 0;
    if( i_trailing > 0 )
    {
        bs_write( s, i_trailing, i_sign );
    }
    for( i = i_trailing; i < i_total; i++ )
    {
        int i_level_code;

        /* calculate level code */
        if( level[i] < 0 )
        {
            i_level_code = -2*level[i] - 1;
        }
        else /* if( level[i] > 0 ) */
        {
            i_level_code = 2 * level[i] - 2;
        }
        if( i == i_trailing && i_trailing < 3 )
        {
            i_level_code -=2; /* as level[i] can't be 1 for the first one if i_trailing < 3 */
        }

        if( ( i_level_code >> i_suffix_length ) < 14 )
        {
            bs_write_vlc( s, x264_level_prefix[i_level_code >> i_suffix_length] );
            if( i_suffix_length > 0 )
            {
                bs_write( s, i_suffix_length, i_level_code );
            }
        }
        else if( i_suffix_length == 0 && i_level_code < 30 )
        {
            bs_write_vlc( s, x264_level_prefix[14] );
            bs_write( s, 4, i_level_code - 14 );
        }
        else if( i_suffix_length > 0 && ( i_level_code >> i_suffix_length ) == 14 )
        {
            bs_write_vlc( s, x264_level_prefix[14] );
            bs_write( s, i_suffix_length, i_level_code );
        }
        else
        {
            bs_write_vlc( s, x264_level_prefix[15] );
            i_level_code -= 15 << i_suffix_length;
            if( i_suffix_length == 0 )
            {
                i_level_code -= 15;
            }

            if( i_level_code >= ( 1 << 12 ) || i_level_code < 0 )
            {
                printf( "OVERFLOW levelcode=%d\n", i_level_code );
            }

            bs_write( s, 12, i_level_code );    /* check overflow ?? */
        }

        if( i_suffix_length == 0 )
        {
            i_suffix_length++;
        }
        if( abs( level[i] ) > ( 3 << ( i_suffix_length - 1 ) ) && i_suffix_length < 6 )
        {
            i_suffix_length++;
        }
    }

    if( i_total < i_count )
    {
        if( i_idx == BLOCK_INDEX_CHROMA_DC )
        {
            bs_write_vlc( s, x264_total_zeros_dc[i_total-1][i_total_zero] );
        }
        else
        {
            bs_write_vlc( s, x264_total_zeros[i_total-1][i_total_zero] );
        }
    }

    for( i = 0, i_zero_left = i_total_zero; i < i_total - 1; i++ )
    {
        int i_zl;

        if( i_zero_left <= 0 )
        {
            break;
        }

        i_zl = X264_MIN( i_zero_left - 1, 6 );

        bs_write_vlc( s, x264_run_before[i_zl][run[i]] );

        i_zero_left -= run[i];
    }
}

STATIC void x264_sub_mb_mv_write_cavlc(int16_t mv[2][48][2], int8_t ref[2][48], int partition, int sub_partition[4], bs_t *s )
{
    int i;
    for( i = 0; i < 4; i++ )
    {
        int mvp[2];

        if( !x264_mb_partition_listX_table[0][ sub_partition[i] ] )
        {
            continue;
        }
        switch( sub_partition[i] )
        {
            case D_L0_8x8:
                x264_mb_predict_mv( mv, ref, 0, 4*i, 2, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i]][1] - mvp[1] );
                break;
            case D_L0_8x4:
                x264_mb_predict_mv( mv, ref, 0, 4*i+0, 2, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i]][1] - mvp[1] );

                x264_mb_predict_mv( mv, ref, 0, 4*i+2, 2, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i+2]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i+2]][1] - mvp[1] );
                break;
            case D_L0_4x8:
                x264_mb_predict_mv( mv, ref, 0, 4*i+0, 1, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i]][1] - mvp[1] );

                x264_mb_predict_mv( mv, ref, 0, 4*i+1, 1, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i+1]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i+1]][1] - mvp[1] );
                break;
            case D_L0_4x4:
                x264_mb_predict_mv( mv, ref, 0, 4*i+0, 1, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i]][1] - mvp[1] );

                x264_mb_predict_mv( mv, ref, 0, 4*i+1, 1, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i+1]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i+1]][1] - mvp[1] );

                x264_mb_predict_mv( mv, ref, 0, 4*i+2, 1, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i+2]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i+2]][1] - mvp[1] );

                x264_mb_predict_mv( mv, ref, 0, 4*i+3, 1, mvp, partition );
                bs_write_se( s, mv[0][x264_scan8[4*i+3]][0] - mvp[0] );
                bs_write_se( s, mv[0][x264_scan8[4*i+3]][1] - mvp[1] );
                break;
        }
    }
}

STATIC void x264_macroblock_luma_write_cavlc( int i_cbp_luma, int non_zero_count[48], int dct_block[24][16], bs_t *s )
{
    int i8, i4, i;

    for( i8 = 0; i8 < 4; i8++ )
        if( i_cbp_luma & (1 << i8) )
            for( i4 = 0; i4 < 4; i4++ )
                block_residual_write_cavlc( non_zero_count, s, i4+i8*4, dct_block[i4+i8*4], 16 );
}		
STATIC void x264_slice_header_write(SliceHeader *sh, bs_t *s)
{
    bs_write_ue( s, sh->i_first_mb );
    if (FRAME_TYPE_IDR == sh->i_type)
        bs_write_ue( s, 7 );   /* same type things */
    else
        bs_write_ue( s, 5 );   /* same type things */
    bs_write_ue( s, 0);
    bs_write( s, SPS_MAX_FRAME_NUM, sh->i_frame_num );

    if( sh->i_idr_pic_id >= 0 ) /* NAL IDR */
    {
        bs_write_ue( s, sh->i_idr_pic_id );
    }

    bs_write( s, SPS_MAX_POC_LSB, sh->i_poc_lsb );

    if( sh->i_type == FRAME_TYPE_P)
    {
        bs_write1( s, sh->b_num_ref_idx_override );
        if( sh->b_num_ref_idx_override )
        {
            bs_write_ue( s, 0 );
        }
    }

    /* ref pic list reordering */
    if(FRAME_TYPE_P == sh->i_type )
    {
        bs_write1( s, 0);
    }

    if( sh->i_idr_pic_id >= 0 )
    {
        bs_write1( s, 0 );  /* no output of prior pics flag */
        bs_write1( s, 0 );  /* long term reference flag */
    }
    else
    {
        bs_write1( s, 0 );  /* adaptive_ref_pic_marking_mode_flag */
    }

    bs_write_se( s, sh->i_qp_delta );      /* slice qp delta */

    {
        bs_write_ue( s, sh->i_disable_deblocking_filter_idc );
        if( sh->i_disable_deblocking_filter_idc != 1 )
        {
            bs_write_se( s, 0);//sh->i_alpha_c0_offset >> 1 );
            bs_write_se( s, 0);//sh->i_beta_offset >> 1 );
        }
    }
} 
STATIC void x264_init_data(int i_mb_type, int i_pred4x4[48], int non_zero_count[48])
{
    /* load intra4x4 */
    i_pred4x4[x264_scan8[0] - 8] =
        i_pred4x4[x264_scan8[1] - 8] =
        i_pred4x4[x264_scan8[4] - 8] =
        i_pred4x4[x264_scan8[5] - 8] = -1;

    /* load non_zero_count */
    non_zero_count[x264_scan8[0] - 8] =
        non_zero_count[x264_scan8[1] - 8] =
        non_zero_count[x264_scan8[4] - 8] =
        non_zero_count[x264_scan8[5] - 8] =
        non_zero_count[x264_scan8[16+0] - 8] =
        non_zero_count[x264_scan8[16+1] - 8] =
        non_zero_count[x264_scan8[16+4+0] - 8] =
        non_zero_count[x264_scan8[16+4+1] - 8] = 0x80;

    i_pred4x4[x264_scan8[0 ] - 1] =
        i_pred4x4[x264_scan8[2 ] - 1] =
        i_pred4x4[x264_scan8[8 ] - 1] =
        i_pred4x4[x264_scan8[10] - 1] = -1;

    /* load non_zero_count */
    non_zero_count[x264_scan8[0 ] - 1] =
        non_zero_count[x264_scan8[2 ] - 1] =
        non_zero_count[x264_scan8[8 ] - 1] =
        non_zero_count[x264_scan8[10] - 1] =
        non_zero_count[x264_scan8[16+0] - 1] =
        non_zero_count[x264_scan8[16+2] - 1] =
        non_zero_count[x264_scan8[16+4+0] - 1] =
        non_zero_count[x264_scan8[16+4+2] - 1] = 0x80;
}
STATIC int x264_nal_encode( void *p_data, int *pi_data, int b_annexeb, x264_nal_t *nal )
{
    uint8_t *dst = (uint8_t *)p_data;
    uint8_t *src = nal->p_payload;
    uint8_t *end = &nal->p_payload[nal->i_payload];

    int i_count = 0;

    /* FIXME this code doesn't check overflow */

    if( b_annexeb )
    {
        /* long nal start code (we always use long ones)*/
        *dst++ = 0x00;
        *dst++ = 0x00;
        *dst++ = 0x00;
        *dst++ = 0x01;
    }

    /* nal header */
    *dst++ = ( 0x00 << 7 ) | ( nal->i_ref_idc << 5 ) | nal->i_type;

    while( src < end )
    {
        if( i_count == 2 && *src <= 0x03 )
        {
            *dst++ = 0x03;
            i_count = 0;
        }
        if( *src == 0 )
        {
            i_count++;
        }
        else
        {
            i_count = 0;
        }
        *dst++ = *src++;
    }
    *pi_data = dst - (uint8_t*)p_data;

    return *pi_data;
}
STATIC void x264_sei_version_write(FILE *fpWrite)
{
    bs_t bitStream;
    x264_nal_t nal;
    char szBuffer[256], szTemp[64], version[256];
    int i, length;
    // random ID number generated according to ISO-11578
    const uint8_t uuid[16] = {
        0xdc, 0x45, 0xe9, 0xbd, 0xe6, 0xd9, 0x48, 0xb7,
        0x96, 0x2c, 0xd8, 0x20, 0xd9, 0x23, 0xee, 0xef
    };

    bs_init(&bitStream, szBuffer, sizeof(szBuffer));

    nal.i_ref_idc = NAL_PRIORITY_DISPOSABLE;
    nal.i_type = NAL_SEI;
    nal.i_payload = 0;
    nal.p_payload = (uint8_t *)szBuffer;

    sprintf( version, " ref=%d", REFERENCE_FRAME_COUNT);
    sprintf( szTemp, " deblock=%d:%d:%d", 1, 0, 0); strcat(version, szTemp);
    sprintf( szTemp, " analyse=%#x:%#x", X264_ANALYSE_INTRA, X264_ANALYSE_INTER ); strcat(version, szTemp);
    sprintf( szTemp, " me=%s", "hex"); strcat(version, szTemp);
    sprintf( szTemp, " subme=%d", SUBPIXEL_ME_P ); strcat(version, szTemp);
    sprintf( szTemp, " mixed_ref=%d", 0 ); strcat(version, szTemp);
    sprintf( szTemp, " me_range=%d", MAX_ME_RANGE ); strcat(version, szTemp);
    sprintf( szTemp, " chroma_me=%d", 1 ); strcat(version, szTemp);
    sprintf( szTemp, " 8x8dct=%d", 0 ); strcat(version, szTemp);
    sprintf( szTemp, " cqm=%d", 0 ); strcat(version, szTemp);
    sprintf( szTemp, " chroma_qp_offset=%d", 0 ); strcat(version, szTemp);
    sprintf( szTemp, " slices=%d", 1 ); strcat(version, szTemp);
    sprintf( szTemp, " keyint=%d keyint_min=%d scenecut=%d", MAX_GOP_SIZE, MIN_GOP_SIZE, SCENE_CUT); strcat(version, szTemp);
    sprintf( szTemp, " pass=%d", 1 ); strcat(version, szTemp);
    sprintf( szTemp, " qp=%d", QP_CONSTANT ); strcat(version, szTemp);
    sprintf( szTemp, " ip_ratio=%.2f", IP_FACTOR ); strcat(version, szTemp);

    length = strlen(version)+1+16;

    bs_write( &bitStream, 8, 0x5 ); // payload_type = user_data_unregistered
    // payload_size
    for( i = 0; i <= length-255; i += 255 )
        bs_write( &bitStream, 8, 255 );
    bs_write( &bitStream, 8, length-i );

    for( i = 0; i < 16; i++ )
        bs_write( &bitStream, 8, uuid[i] );
    for( i = 0; i < length-16; i++ )
        bs_write( &bitStream, 8, version[i] );

    bs_rbsp_trailing( &bitStream );

    nal.i_payload = bs_pos(&bitStream)/8; //&szBuffer[bs_pos(&bitStream)/8] - nal.p_payload;
    i = DATA_MAX;
    length = x264_nal_encode(version, &i, 1, &nal);
    fwrite(version, 1, length, fpWrite);
}
STATIC void x264_sps_write(FILE *fpWrite)
{
    bs_t bitStream;
    x264_nal_t nal;
    char szBuffer[32], szOut[32];
    int i, length;

    bs_init(&bitStream, szBuffer, sizeof(szBuffer));
    nal.i_ref_idc = NAL_PRIORITY_HIGHEST;
    nal.i_type = NAL_SPS;
    nal.i_payload = 0;
    nal.p_payload = (uint8_t *)szBuffer;

    bs_write( &bitStream, 8, 66); //PROFILE_BASELINE); //sps->i_profile_idc );
    bs_write( &bitStream, 1, 0);//sps->b_constraint_set0 );
    bs_write( &bitStream, 1, 0);//sps->b_constraint_set1 );
    bs_write( &bitStream, 1, 0);//sps->b_constraint_set2 );

    bs_write( &bitStream, 5, 0 );    /* reserved */
    bs_write( &bitStream, 8, LEVEL_IDC );

    bs_write_ue( &bitStream, 0 );

    bs_write_ue( &bitStream, SPS_MAX_FRAME_NUM - 4 );
    bs_write_ue( &bitStream, 0);
    bs_write_ue( &bitStream, SPS_MAX_POC_LSB - 4 );

    bs_write_ue( &bitStream, REFERENCE_FRAME_COUNT);//sps->i_num_ref_frames );
    bs_write( &bitStream, 1, 0); // sps->b_gaps_in_frame_num_value_allowed );
    bs_write_ue( &bitStream, SPS_MB_WIDTH - 1 );
    bs_write_ue( &bitStream, SPS_MB_HEIGHT - 1);
    bs_write( &bitStream, 1, 1);//sps->b_frame_mbs_only );

    bs_write( &bitStream, 1, 0);//sps->b_direct8x8_inference );

    bs_write( &bitStream, 1, SPS_B_CROP );
    if( SPS_B_CROP )
    {
        bs_write_ue( &bitStream, 0 ); //sps->crop.i_left   / 2
        bs_write_ue( &bitStream, SPS_CROP_RIGHT / 2 );
        bs_write_ue( &bitStream, 0);//sps->crop.i_top    / 2 );
        bs_write_ue( &bitStream, SPS_CROP_BOTTOM / 2 );
    }

    bs_write( &bitStream, 1, 1);//sps->b_vui );
    {
        bs_write1( &bitStream, 0);//sps->vui.b_aspect_ratio_info_present );
        bs_write1( &bitStream, 0);//sps->vui.b_overscan_info_present );
        bs_write1( &bitStream, 0);//sps->vui.b_signal_type_present );

        bs_write1( &bitStream, 0); //sps->vui.b_chroma_loc_info_present );
        bs_write1( &bitStream, 1); //sps->vui.b_timing_info_present );
        {
            bs_write( &bitStream, 32, FPS_DEN); //sps->vui.i_num_units_in_tick );
            bs_write( &bitStream, 32, FPS_NUM * 2); //sps->vui.i_time_scale );
            bs_write1( &bitStream, 1); //sps->vui.b_fixed_frame_rate );
        }

        bs_write1( &bitStream, 0 );      /* nal_hrd_parameters_present_flag */
        bs_write1( &bitStream, 0 );      /* vcl_hrd_parameters_present_flag */
        bs_write1( &bitStream, 0 );      /* pic_struct_present_flag */
        bs_write1( &bitStream, 1); //sps->vui.b_bitstream_restriction );
        {
            bs_write1( &bitStream, 1); //sps->vui.b_motion_vectors_over_pic_boundaries );
            bs_write_ue( &bitStream, 0); //sps->vui.i_max_bytes_per_pic_denom );
            bs_write_ue( &bitStream, 0); //sps->vui.i_max_bits_per_mb_denom );
            bs_write_ue( &bitStream, 11);//sps->vui.i_log2_max_mv_length_horizontal );
            bs_write_ue( &bitStream, 11);//sps->vui.i_log2_max_mv_length_vertical );
            bs_write_ue( &bitStream, 0); //sps->vui.i_num_reorder_frames );
            bs_write_ue( &bitStream, REFERENCE_FRAME_COUNT); //sps->vui.i_max_dec_frame_buffering );
        }
    }

    bs_rbsp_trailing( &bitStream );

    nal.i_payload = bs_pos(&bitStream)/8; //&szBuffer[bs_pos(&bitStream)/8] - nal.p_payload;
    i = DATA_MAX;
    length = x264_nal_encode(szOut, &i, 1, &nal);
    fwrite(szOut, 1, length, fpWrite);
}
STATIC void x264_pps_write(FILE *fpWrite)
{
    bs_t bitStream;
    x264_nal_t nal;
    char szBuffer[8], szOut[8];
    int i, length;

    bs_init(&bitStream, szBuffer, sizeof(szBuffer));
    nal.i_ref_idc = NAL_PRIORITY_HIGHEST;
    nal.i_type = NAL_PPS;
    nal.i_payload = 0;
    nal.p_payload = (uint8_t *)szBuffer;

    bs_write_ue( &bitStream, 0 );
    bs_write_ue( &bitStream, 0); //PPS_SPS_ID );

    bs_write( &bitStream, 1, 0);//pps->b_cabac );
    bs_write( &bitStream, 1, 0);//PPS_PIC_ORDER );
    bs_write_ue( &bitStream, 0);//PPS_SLICE_GROUP - 1 );

    bs_write_ue( &bitStream, 0 );
    bs_write_ue( &bitStream, 0 );
    bs_write( &bitStream, 3, 0 );
    bs_write_se( &bitStream, 0);//PPS_PIC_INIT_QP - 26 );
    bs_write_se( &bitStream, 0);//PPS_PIC_INIT_QS - 26 );
    bs_write_se( &bitStream, 0); // i_chroma_qp_index_offset

    bs_write( &bitStream, 1, 1);//PPS_DEBLOCK_FLITER_CONTROL );
    bs_write( &bitStream, 1, 0);//PPS_CONSTRAINED_INTRA_PRED );
    bs_write( &bitStream, 1, 0);//PPS_REDUNDANT_PIC_CNT );

    bs_rbsp_trailing( &bitStream );

    nal.i_payload = bs_pos(&bitStream)/8; //&szBuffer[bs_pos(&bitStream)/8] - nal.p_payload;
    i = DATA_MAX;
    length = x264_nal_encode(szOut, &i, 1, &nal);
    fwrite(szOut, 1, length, fpWrite);
}

/////////////////////////////////////
// init code
/////////////////////////////////////
TASK_INIT
{
// ##INIT_PORT_SECTION::START
    port_p14 = PORT_INITIALIZE(TASK_ID, "p14");
// ##INIT_PORT_SECTION::END

    // TODO: task initialize code
    i_intFrameType_1967_phase = 0;
    i_intMBType_1968 = 0;
    i_intIntra16x16_pred_mode_1969 = 0;
    i_msgIntra4x4_pred_mode_1970 = 0;
    i_msgRef_1971 = 0;
    i_msgMV_1972 = 0;
    i_msgNon_zero_count_1973 = 0;
    i_intCbp_luma_1974 = 0;
    i_intCbp_chroma_1975 = 0;
    i_intChroma_pred_mode_1976 = 0;
    i_intPartition_1977 = 0;
    i_msgSub_partition_1978 = 0;
    i_msgLuma16x16_dc_1979 = 0;
    i_msgLuma4x4_1980 = 0;
    i_msgChroma_dc_1981 = 0;
    i_msgResidual_luma_ac_1982 = 0;
    i_msgResidual_chroma_ac_1983 = 0;
    i_msgSliceHeader_1984_phase = 0;
    o_msgBS_data_1985_phase = 0;
    fp264_1986 = fopen("FOREMAN.264", "wb");
    x264_sei_version_write(fp264_1986);
    output_1948 = 0;
    output_1987_phase = 0;
    {int i; for(i=0;i<99;i++) output_1949[i] = 0;}
    output_1989 = 0;
    {int i; for(i=0;i<99;i++) output_1950[i] = 0;}
    output_1991 = 0;
    output_1993 = 0;
    output_1995 = 0;
    output_1997 = 0;
    output_1999 = 0;
    {int i; for(i=0;i<99;i++) output_1955[i] = 0;}
    output_2001 = 0;

    {int i; for(i=0;i<99;i++) output_1956[i] = 0;}
    output_2003 = 0;
    {int i; for(i=0;i<99;i++) output_1957[i] = 0;}
    output_2005 = 0;
    {int i; for(i=0;i<99;i++) output_1958[i] = 0;}
    output_2007 = 0;
    output_2009 = 0;
    output_2011 = 0;
    output_2013 = 0;
    output_2015 = 0;
    output_2017 = 0;
    output_2019 = 0;
    output_2021_phase = 0;
    output_1966 = 0;


//    fid_5060=-1;
//    fid_5060=init_port(4, 60 ); //

}


/////////////////////////////////////
// go code
/////////////////////////////////////
STATIC int sdfLoopCounter_31;
TASK_GO
{
    // TODO: task main code
    int intFrameType;
    
    { 
        //int sdfLoopCounter_31;
        //for (sdfLoopCounter_31 = 0; sdfLoopCounter_31 < 99; sdfLoopCounter_31++) 
        {
                EncVLCPacket e;
                MQ_RECEIVE(port_p14, (unsigned char*)&e, sizeof(EncVLCPacket));
                memcpy(&vlc_r_info, &e.e_s_info, sizeof(encoder_send_info));
                memcpy((unsigned char *)&output_1959[output_2009],&vlc_r_info.i_sub_partition, 16); // i_sub_partition
                memcpy((unsigned char *)&output_1958[output_2007],&vlc_r_info.i_partition , 4); // i_partition
                memcpy((unsigned char *)&output_1957[output_2005],&vlc_r_info.chroma_pred_mode, 4); // chroma_pred_mode
                memcpy((unsigned char *)&output_1953[output_1997],&vlc_r_info.mv_mb, 384); // mv_mb data
                memcpy((unsigned char *)&output_1952[output_1995],&vlc_r_info.ref_mb, 96); // ref_mb
                memcpy((unsigned char *)&output_1951[output_1993],&vlc_r_info.intra4x4_pred_mode, 192); // intra4x4_pred_mdoe
                memcpy((unsigned char *)&output_1950[output_1991],&vlc_r_info.i_pred16x16, 4);  // i_pred16x16
                memcpy((unsigned char *)&output_1949[output_1989],&vlc_r_info.mb_type, 4); // mb_type
                // from Enc
                memcpy(&output_1962[output_2015], &e.chroma_dc, 32);
                memcpy(&output_1964[output_2019], &e.chroma_residual_ac, 480);
                memcpy(&output_1961[output_2013], &e.luma4x4_out, 1024);
                memcpy(&output_1963[output_2017], &e.luma_residual_ac, 960);
                memcpy(&output_1954[output_1999], &e.non_zero_count, 192);
                memcpy(&output_1960[output_2011], &e.luma4x4, 64);
                output_1955[output_2001] = e.i_cbp_luma;
                output_1956[output_2003] = e.i_cbp_chroma;
                intFrameType = e.intFrameType;

                output_2005 += 1;
                output_1989 += 1;
                output_2015 += 1;
                output_2019 += 1;
                output_2011 += 1;
                output_1999 += 1;
                output_2001 += 1;
                output_2003 += 1;
                output_1997 += 1;
                output_1995 += 1;
                output_2007 += 1;
                output_2009 += 1;
                output_1991 += 1;
                output_2013 += 1;
                output_2017 += 1;
                output_1993 += 1;
            {  /* star CIC_TM.Complete_galaxy_TMI0.Complete_galaxy_TMI0_vlc_4.Complete_galaxy_TMI0_arm926ej_s_4.ReceiveI3 (class CGCReceive) */
                if (output_2021_phase==0)
                    memcpy(&output_1965, &e.msgSliceHeader, 40);
                output_2021_phase = (output_2021_phase+1)%99;
            }

            {  /* star CIC_TM.Complete_galaxy_TMI0.Complete_galaxy_TMI0_vlc_4.Complete_galaxy_TMI0_arm926ej_s_4.ReceiveI5 (class CGCReceive) */
                if (output_1987_phase==0)
                    output_1948 = e.intFrameType;
                    
                output_1987_phase = (output_1987_phase+1)%99;
            }
            {  /* star CIC_TM.Complete_galaxy_TMI0.Complete_galaxy_TMI0_vlc_4.Complete_galaxy_TMI0_arm926ej_s_4.CIC_TM.Complete_galaxy_TMI0.Complete_galaxy_TM_GI0.CavlcI130.XCavlcI0 (class CGCXCavlc) */
                const int i_mb_type = output_1949[i_intMBType_1968];
                int i_mb_i_offset;
                int i;
                STATIC bs_t bitstream;
                STATIC int i_skip;

                switch( output_1948 )
                {
                    case FRAME_TYPE_IDR:
                        i_mb_i_offset = 0;
                        break;
                    case FRAME_TYPE_P:
                        i_mb_i_offset = 5;
                        break;
                        /*    
                              default:
                              printf( "internal error or slice unsupported\n" );
                              return;
                         */    
                }
                if (0 == o_msgBS_data_1985_phase)
                {
                    bs_init(&bitstream, o_msgBS_data_1947.data, sizeof(o_msgBS_data_1947.data));			
                    x264_slice_header_write( &output_1965, &bitstream );
                    i_skip = 0;
                    x264_init_data(i_mb_type, output_1951[i_msgIntra4x4_pred_mode_1970].data, output_1954[i_msgNon_zero_count_1973].data);
                }

                /* Write:
                   - type
                   - prediction
                   - mv */
                if (i_mb_type == P_SKIP)
                {
                    i_skip++;
                    goto skip;
                }

                if (output_1948 != FRAME_TYPE_IDR)
                {
                    bs_write_ue( &bitstream, i_skip );  /* skip run */
                    i_skip = 0;
                }

                if( i_mb_type == I_4x4 || i_mb_type == I_8x8 )
                {
                    int di = i_mb_type == I_8x8 ? 4 : 1;
                    bs_write_ue( &bitstream, i_mb_i_offset + 0 );

                    /* Prediction: Luma */
                    for( i = 0; i < 16; i += di )
                    {
                        int i_pred = x264_mb_predict_intra4x4_mode( output_1951[i_msgIntra4x4_pred_mode_1970].data, i );
                        int i_mode = x264_mb_pred_mode4x4_fix[output_1951[i_msgIntra4x4_pred_mode_1970].data[x264_scan8[i]]+1];

                        if( i_pred == i_mode)
                        {
                            bs_write1( &bitstream, 1 );  /* b_prev_intra4x4_pred_mode */
                        }
                        else
                        {
                            bs_write1( &bitstream, 0 );  /* b_prev_intra4x4_pred_mode */
                            if( i_mode < i_pred )
                            {
                                bs_write( &bitstream, 3, i_mode );
                            }
                            else
                            {
                                bs_write( &bitstream, 3, i_mode - 1 );
                            }
                        }
                    }
                    bs_write_ue( &bitstream, x264_mb_pred_mode8x8c_fix[ output_1957[i_intChroma_pred_mode_1976] ] );
                }
                else if( i_mb_type == I_16x16 )
                {
                    bs_write_ue( &bitstream, i_mb_i_offset + 1 + x264_mb_pred_mode16x16_fix[output_1950[i_intIntra16x16_pred_mode_1969]] +
                            output_1956[i_intCbp_chroma_1975] * 4 + ( output_1955[i_intCbp_luma_1974] == 0 ? 0 : 12 ) );
                    bs_write_ue( &bitstream, x264_mb_pred_mode8x8c_fix[ output_1957[i_intChroma_pred_mode_1976] ] );
                }
                else if( i_mb_type == P_L0 )
                {
                    int mvp[2];

                    if( output_1958[i_intPartition_1977] == D_16x16 )
                    {
                        bs_write_ue( &bitstream, 0 );

                        x264_mb_predict_mv( output_1953[i_msgMV_1972].data, output_1952[i_msgRef_1971].data, 0, 0, 4, mvp, output_1958[i_intPartition_1977] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[0]][0] - mvp[0] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[0]][1] - mvp[1] );
                    }
                    else if( output_1958[i_intPartition_1977] == D_16x8 )
                    {
                        bs_write_ue( &bitstream, 1 );

                        x264_mb_predict_mv( output_1953[i_msgMV_1972].data, output_1952[i_msgRef_1971].data, 0, 0, 4, mvp, output_1958[i_intPartition_1977] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[0]][0] - mvp[0] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[0]][1] - mvp[1] );

                        x264_mb_predict_mv( output_1953[i_msgMV_1972].data, output_1952[i_msgRef_1971].data, 0, 8, 4, mvp, output_1958[i_intPartition_1977] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[8]][0] - mvp[0] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[8]][1] - mvp[1] );
                    }
                    else if( output_1958[i_intPartition_1977] == D_8x16 )
                    {
                        bs_write_ue( &bitstream, 2 );

                        x264_mb_predict_mv( output_1953[i_msgMV_1972].data, output_1952[i_msgRef_1971].data, 0, 0, 2, mvp, output_1958[i_intPartition_1977]);
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[0]][0] - mvp[0] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[0]][1] - mvp[1] );

                        x264_mb_predict_mv( output_1953[i_msgMV_1972].data, output_1952[i_msgRef_1971].data, 0, 4, 2, mvp, output_1958[i_intPartition_1977] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[4]][0] - mvp[0] );
                        bs_write_se( &bitstream, output_1953[i_msgMV_1972].data[0][x264_scan8[4]][1] - mvp[1] );
                    }
                }
                else if( i_mb_type == P_8x8 )
                {
                    int b_sub_ref0;
                    if( output_1952[i_msgRef_1971].data[0][x264_scan8[0]] == 0 && output_1952[i_msgRef_1971].data[0][x264_scan8[4]] == 0 &&
                            output_1952[i_msgRef_1971].data[0][x264_scan8[8]] == 0 && output_1952[i_msgRef_1971].data[0][x264_scan8[12]] == 0 )
                    {
                        bs_write_ue( &bitstream, 4 );
                        b_sub_ref0 = 0;
                    }
                    else
                    {
                        bs_write_ue( &bitstream, 3 );
                        b_sub_ref0 = 1;
                    }
                    /* sub mb type */
                    for( i = 0; i < 4; i++ )
                    {
                        bs_write_ue( &bitstream, sub_mb_type_p_to_golomb[ output_1959[i_msgSub_partition_1978].data[i] ] );
                    }
                    /* ref0 */

                    x264_sub_mb_mv_write_cavlc( output_1953[i_msgMV_1972].data, output_1952[i_msgRef_1971].data, output_1958[i_intPartition_1977], output_1959[i_msgSub_partition_1978].data, &bitstream );
                }
                else
                {
                    /*
                       printf( "invalid/unhandled mb_type\n" );
                       return;
                     */
                }

                /* Coded block patern */
                if( i_mb_type == I_4x4 || i_mb_type == I_8x8 )
                {
                    bs_write_ue( &bitstream, intra4x4_cbp_to_golomb[( output_1956[i_intCbp_chroma_1975] << 4 )| output_1955[i_intCbp_luma_1974]] );
                }
                else if( i_mb_type != I_16x16 )
                {
                    bs_write_ue( &bitstream, inter_cbp_to_golomb[( output_1956[i_intCbp_chroma_1975] << 4 )| output_1955[i_intCbp_luma_1974]] );
                }

                // ?????? ???? ???? mb.i_qp = mb.i_last_qp????. 
                // I-Frame --> 23, P-Frame --> 26
                /* write residual */
                if( i_mb_type == I_16x16 )
                {
                    bs_write_se( &bitstream, 0); // h->mb.i_qp - h->mb.i_last_qp );

                    /* DC Luma */
                    block_residual_write_cavlc( output_1954[i_msgNon_zero_count_1973].data, &bitstream, BLOCK_INDEX_LUMA_DC ,output_1960[i_msgLuma16x16_dc_1979].data, 16 );

                    /* AC Luma */
                    if( output_1955[i_intCbp_luma_1974] != 0 )
                        for( i = 0; i < 16; i++ )
                            block_residual_write_cavlc( output_1954[i_msgNon_zero_count_1973].data, &bitstream, i, output_1963[i_msgResidual_luma_ac_1982].data[i], 15 );
                }
                else if( output_1955[i_intCbp_luma_1974] != 0 || output_1956[i_intCbp_chroma_1975] != 0 )
                {
                    int i8, i4;
                    bs_write_se( &bitstream, 0); // h->mb.i_qp - h->mb.i_last_qp );
                    for (i8=0; i8 < 4; i8++)
                        if (output_1955[i_intCbp_luma_1974] & (1<<i8))
                            for (i4=0; i4 < 4; i4++)
                                block_residual_write_cavlc( output_1954[i_msgNon_zero_count_1973].data, &bitstream, i4+i8*4, output_1961[i_msgLuma4x4_1980].data[i4+i8*4], 16 );
                }

                if( output_1956[i_intCbp_chroma_1975] != 0 )
                {
                    /* Chroma DC residual present */
                    block_residual_write_cavlc( output_1954[i_msgNon_zero_count_1973].data, &bitstream, BLOCK_INDEX_CHROMA_DC, output_1962[i_msgChroma_dc_1981].data[0], 4 );
                    block_residual_write_cavlc( output_1954[i_msgNon_zero_count_1973].data, &bitstream, BLOCK_INDEX_CHROMA_DC, output_1962[i_msgChroma_dc_1981].data[1], 4 );
                    if( output_1956[i_intCbp_chroma_1975]&0x02 ) /* Chroma AC residual present */
                        for( i = 0; i < 8; i++ )
                            block_residual_write_cavlc( output_1954[i_msgNon_zero_count_1973].data, &bitstream, 16 + i, output_1964[i_msgResidual_chroma_ac_1983].data[i], 15 );
                }
skip :
                if ((((176+15)/16)*((144+15)/16))-1 == o_msgBS_data_1985_phase)
                {
                    if( i_skip > 0 )
                        bs_write_ue( &bitstream, i_skip );  /* last skip run */
                    bs_rbsp_trailing( &bitstream );
                    o_msgBS_data_1947.size = bs_pos(&bitstream)/8;;
                }
                i_intFrameType_1967_phase = (i_intFrameType_1967_phase+1)%99;
                i_msgSliceHeader_1984_phase = (i_msgSliceHeader_1984_phase+1)%99;
                o_msgBS_data_1985_phase = (o_msgBS_data_1985_phase+1)%99;
                i_intMBType_1968 += 1;
                i_intIntra16x16_pred_mode_1969 += 1;
                i_msgIntra4x4_pred_mode_1970 += 1;
                i_msgRef_1971 += 1;
                i_msgMV_1972 += 1;
                i_msgNon_zero_count_1973 += 1;
                i_intCbp_luma_1974 += 1;
                i_intCbp_chroma_1975 += 1;
                i_intChroma_pred_mode_1976 += 1;
                i_intPartition_1977 += 1;
                i_msgSub_partition_1978 += 1;
                i_msgLuma16x16_dc_1979 += 1;
                i_msgLuma4x4_1980 += 1;
                i_msgChroma_dc_1981 += 1;
                i_msgResidual_luma_ac_1982 += 1;
                i_msgResidual_chroma_ac_1983 += 1;
            }
        }
    } /* end repeat, depth 2*/


            sdfLoopCounter_31++;
            if(sdfLoopCounter_31 == 99){
            output_1966 = intFrameType;
        {  /* star CIC_TM.Complete_galaxy_TMI0.Complete_galaxy_TMI0_vlc_4.Complete_galaxy_TMI0_arm926ej_s_4.CIC_TM.Complete_galaxy_TMI0.Complete_galaxy_TM_GI0.CavlcI130.XFileWriterI20 (class CGCXFileWriter) */
            uint8_t szBuffer[176*144];
            x264_nal_t nal;
            int i, length;

            if (output_1966 == FRAME_TYPE_IDR)
            {
                x264_sps_write(fp264_1986);
                x264_pps_write(fp264_1986);
            }

            if (output_1966 == FRAME_TYPE_IDR)
            {
                nal.i_ref_idc = NAL_PRIORITY_HIGHEST;
                nal.i_type = NAL_SLICE_IDR;
            }
            else
            {
                nal.i_ref_idc = NAL_PRIORITY_HIGH;
                nal.i_type = NAL_SLICE;
            }
            nal.i_payload = o_msgBS_data_1947.size;
            nal.p_payload = o_msgBS_data_1947.data;

            i = DATA_MAX;
            length = x264_nal_encode( szBuffer, &i, 1, &nal );
            fwrite(szBuffer, 1, length, fp264_1986);
        }

        output_2009 = 0;
        output_2007 = 0;
        output_1995 = 0;
        output_1997 = 0;
        output_1993 = 0;
        output_1991 = 0;
        output_2005 = 0;
        output_1989 = 0;
        output_2015 = 0;
        output_2019 = 0;
        output_2011 = 0;
        output_2001 = 0;
        output_2003 = 0;
        output_2013 = 0;
        output_2017 = 0;
        output_1999 = 0;
        i_intMBType_1968 = 0;
        i_intIntra16x16_pred_mode_1969 = 0;
        i_msgIntra4x4_pred_mode_1970 = 0;
        i_msgRef_1971 = 0;
        i_msgMV_1972 = 0;
        i_msgNon_zero_count_1973 = 0;
        i_intCbp_luma_1974 = 0;
        i_intCbp_chroma_1975 = 0;
        i_intChroma_pred_mode_1976 = 0;
        i_intPartition_1977 = 0;
        i_msgSub_partition_1978 = 0;
        i_msgLuma16x16_dc_1979 = 0;
        i_msgLuma4x4_1980 = 0;
        i_msgChroma_dc_1981 = 0;
        i_msgResidual_luma_ac_1982 = 0;
        i_msgResidual_chroma_ac_1983 = 0;
        sdfLoopCounter_31 = 0;
        }
}



/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    fclose(fp264_1986);
    /*
    int t=0;
    MQ_SEND(port_out, (unsigned char*)&t, sizeof(int));
    */
}

TASK_CODE_END
