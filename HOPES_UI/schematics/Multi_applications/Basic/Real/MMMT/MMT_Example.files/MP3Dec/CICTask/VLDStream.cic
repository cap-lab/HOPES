/************************************
 *
 * File : VLDStream.cic
 * Date : Sep 18, 2012 1:45 PM
 *
 *************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <math.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <ctype.h>

#include "mp3_struct.h"

typedef struct  blockAlign_struct {
  unsigned long   offset;
  unsigned long   blockSize;
} blockAlign;

typedef struct  IFF_AIFF_struct {
  short           numChannels;
  unsigned long   numSampleFrames;
  short           sampleSize;
  double          sampleRate;
  unsigned long   sampleType;
  blockAlign      blkAlgn;
} IFF_AIFF;

enum byte_order { order_unknown, order_bigEndian, order_littleEndian };
extern enum byte_order NativeByteOrder;

STATIC char *programName;
STATIC Arguments_t Arguments;

STATIC int tpart2_start_31;
// ##DEFINE_SECTION::END


static Bit_stream_struc bs;

STATIC unsigned long sample_frames_33;
static int stereo, sync1, error_protection;
static unsigned int old_crc;
STATIC unsigned long frameBits, gotBits=0;
STATIC unsigned long bitsPerSlot = 0, samplesPerFrame = 0; 
STATIC int Max_gr_34;

static int      nSlots;
static int      group_35, group_temp_36, channelNumber_37, ss, sb,
                main_data_end, flush_main;
static int      bytes_to_discard;
static int      frame_start = 0;
STATIC III_side_info_t sideInformation_38;
/*
   STATIC char *mode_names[5] = { "stereo", "j-stereo", "dual-ch", "single-ch" , "multi-ch"};
   STATIC char *layer_names[3] = { "I", "II", "III" };
   STATIC char *version_names[2] = { "MPEG-2 LSF", "MPEG-1" };
   */
/* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
STATIC double s_freq[2][4] = {{22.05, 24, 16, 0}, {44.1, 48, 32, 0}};

/* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
STATIC int bitrate[2][3][15] = {{
  {0,32,48,56,64,80,96,112,128,144,160,176,192,224,256},
    {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160},
    {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160}},

       {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
         {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
         {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}
       }};

/* Number of bit alloc tables*/
#define NALLOCTAB 5

/* Table alloc_0*/
static unsigned short alloc_0[] = {
  0, 0, 0, 4, 0, 0,
  0, 1, 3, 5, 1, 0,
  0, 2, 7, 3, 3, 2,
  0, 3, 15, 4, 3, 4,
  0, 4, 31, 5, 3, 5,
  0, 5, 63, 6, 3, 6,
  0, 6, 127, 7, 3, 7,
  0, 7, 255, 8, 3, 8,
  0, 8, 511, 9, 3, 9,
  0, 9, 1023, 10, 3, 10,
  0, 10, 2047, 11, 3, 11,
  0, 11, 4095, 12, 3, 12,
  0, 12, 8191, 13, 3, 13,
  0, 13, 16383, 14, 3, 14,
  0, 14, 32767, 15, 3, 15,
  0, 15, 65535, 16, 3, 16,
  1, 0, 0, 4, 0, 0,
  1, 1, 3, 5, 1, 0,
  1, 2, 7, 3, 3, 2,
  1, 3, 15, 4, 3, 4,
  1, 4, 31, 5, 3, 5,
  1, 5, 63, 6, 3, 6,
  1, 6, 127, 7, 3, 7,
  1, 7, 255, 8, 3, 8,
  1, 8, 511, 9, 3, 9,
  1, 9, 1023, 10, 3, 10,
  1, 10, 2047, 11, 3, 11,
  1, 11, 4095, 12, 3, 12,
  1, 12, 8191, 13, 3, 13,
  1, 13, 16383, 14, 3, 14,
  1, 14, 32767, 15, 3, 15,
  1, 15, 65535, 16, 3, 16,
  2, 0, 0, 4, 0, 0,
  2, 1, 3, 5, 1, 0,
  2, 2, 7, 3, 3, 2,
  2, 3, 15, 4, 3, 4,
  2, 4, 31, 5, 3, 5,
  2, 5, 63, 6, 3, 6,
  2, 6, 127, 7, 3, 7,
  2, 7, 255, 8, 3, 8,
  2, 8, 511, 9, 3, 9,
  2, 9, 1023, 10, 3, 10,
  2, 10, 2047, 11, 3, 11,
  2, 11, 4095, 12, 3, 12,
  2, 12, 8191, 13, 3, 13,
  2, 13, 16383, 14, 3, 14,
  2, 14, 32767, 15, 3, 15,
  2, 15, 65535, 16, 3, 16,
  3, 0, 0, 4, 0, 0,
  3, 1, 3, 5, 1, 0,
  3, 2, 5, 7, 1, 1,
  3, 3, 7, 3, 3, 2,
  3, 4, 9, 10, 1, 3,
  3, 5, 15, 4, 3, 4,
  3, 6, 31, 5, 3, 5,
  3, 7, 63, 6, 3, 6,
  3, 8, 127, 7, 3, 7,
  3, 9, 255, 8, 3, 8,
  3, 10, 511, 9, 3, 9,
  3, 11, 1023, 10, 3, 10,
  3, 12, 2047, 11, 3, 11,
  3, 13, 4095, 12, 3, 12,
  3, 14, 8191, 13, 3, 13,
  3, 15, 65535, 16, 3, 16,
  4, 0, 0, 4, 0, 0,
  4, 1, 3, 5, 1, 0,
  4, 2, 5, 7, 1, 1,
  4, 3, 7, 3, 3, 2,
  4, 4, 9, 10, 1, 3,
  4, 5, 15, 4, 3, 4,
  4, 6, 31, 5, 3, 5,
  4, 7, 63, 6, 3, 6,
  4, 8, 127, 7, 3, 7,
  4, 9, 255, 8, 3, 8,
  4, 10, 511, 9, 3, 9,
  4, 11, 1023, 10, 3, 10,
  4, 12, 2047, 11, 3, 11,
  4, 13, 4095, 12, 3, 12,
  4, 14, 8191, 13, 3, 13,
  4, 15, 65535, 16, 3, 16,
  5, 0, 0, 4, 0, 0,
  5, 1, 3, 5, 1, 0,
  5, 2, 5, 7, 1, 1,
  5, 3, 7, 3, 3, 2,
  5, 4, 9, 10, 1, 3,
  5, 5, 15, 4, 3, 4,
  5, 6, 31, 5, 3, 5,
  5, 7, 63, 6, 3, 6,
  5, 8, 127, 7, 3, 7,
  5, 9, 255, 8, 3, 8,
  5, 10, 511, 9, 3, 9,
  5, 11, 1023, 10, 3, 10,
  5, 12, 2047, 11, 3, 11,
  5, 13, 4095, 12, 3, 12,
  5, 14, 8191, 13, 3, 13,
  5, 15, 65535, 16, 3, 16,
  6, 0, 0, 4, 0, 0,
  6, 1, 3, 5, 1, 0,
  6, 2, 5, 7, 1, 1,
  6, 3, 7, 3, 3, 2,
  6, 4, 9, 10, 1, 3,
  6, 5, 15, 4, 3, 4,
  6, 6, 31, 5, 3, 5,
  6, 7, 63, 6, 3, 6,
  6, 8, 127, 7, 3, 7,
  6, 9, 255, 8, 3, 8,
  6, 10, 511, 9, 3, 9,
  6, 11, 1023, 10, 3, 10,
  6, 12, 2047, 11, 3, 11,
  6, 13, 4095, 12, 3, 12,
  6, 14, 8191, 13, 3, 13,
  6, 15, 65535, 16, 3, 16,
  7, 0, 0, 4, 0, 0,
  7, 1, 3, 5, 1, 0,
  7, 2, 5, 7, 1, 1,
  7, 3, 7, 3, 3, 2,
  7, 4, 9, 10, 1, 3,
  7, 5, 15, 4, 3, 4,
  7, 6, 31, 5, 3, 5,
  7, 7, 63, 6, 3, 6,
  7, 8, 127, 7, 3, 7,
  7, 9, 255, 8, 3, 8,
  7, 10, 511, 9, 3, 9,
  7, 11, 1023, 10, 3, 10,
  7, 12, 2047, 11, 3, 11,
  7, 13, 4095, 12, 3, 12,
  7, 14, 8191, 13, 3, 13,
  7, 15, 65535, 16, 3, 16,
  8, 0, 0, 4, 0, 0,
  8, 1, 3, 5, 1, 0,
  8, 2, 5, 7, 1, 1,
  8, 3, 7, 3, 3, 2,
  8, 4, 9, 10, 1, 3,
  8, 5, 15, 4, 3, 4,
  8, 6, 31, 5, 3, 5,
  8, 7, 63, 6, 3, 6,
  8, 8, 127, 7, 3, 7,
  8, 9, 255, 8, 3, 8,
  8, 10, 511, 9, 3, 9,
  8, 11, 1023, 10, 3, 10,
  8, 12, 2047, 11, 3, 11,
  8, 13, 4095, 12, 3, 12,
  8, 14, 8191, 13, 3, 13,
  8, 15, 65535, 16, 3, 16,
  9, 0, 0, 4, 0, 0,
  9, 1, 3, 5, 1, 0,
  9, 2, 5, 7, 1, 1,
  9, 3, 7, 3, 3, 2,
  9, 4, 9, 10, 1, 3,
  9, 5, 15, 4, 3, 4,
  9, 6, 31, 5, 3, 5,
  9, 7, 63, 6, 3, 6,
  9, 8, 127, 7, 3, 7,
  9, 9, 255, 8, 3, 8,
  9, 10, 511, 9, 3, 9,
  9, 11, 1023, 10, 3, 10,
  9, 12, 2047, 11, 3, 11,
  9, 13, 4095, 12, 3, 12,
  9, 14, 8191, 13, 3, 13,
  9, 15, 65535, 16, 3, 16,
  10, 0, 0, 4, 0, 0,
  10, 1, 3, 5, 1, 0,
  10, 2, 5, 7, 1, 1,
  10, 3, 7, 3, 3, 2,
  10, 4, 9, 10, 1, 3,
  10, 5, 15, 4, 3, 4,
  10, 6, 31, 5, 3, 5,
  10, 7, 63, 6, 3, 6,
  10, 8, 127, 7, 3, 7,
  10, 9, 255, 8, 3, 8,
  10, 10, 511, 9, 3, 9,
  10, 11, 1023, 10, 3, 10,
  10, 12, 2047, 11, 3, 11,
  10, 13, 4095, 12, 3, 12,
  10, 14, 8191, 13, 3, 13,
  10, 15, 65535, 16, 3, 16,
  11, 0, 0, 3, 0, 0,
  11, 1, 3, 5, 1, 0,
  11, 2, 5, 7, 1, 1,
  11, 3, 7, 3, 3, 2,
  11, 4, 9, 10, 1, 3,
  11, 5, 15, 4, 3, 4,
  11, 6, 31, 5, 3, 5,
  11, 7, 65535, 16, 3, 16,
  12, 0, 0, 3, 0, 0,
  12, 1, 3, 5, 1, 0,
  12, 2, 5, 7, 1, 1,
  12, 3, 7, 3, 3, 2,
  12, 4, 9, 10, 1, 3,
  12, 5, 15, 4, 3, 4,
  12, 6, 31, 5, 3, 5,
  12, 7, 65535, 16, 3, 16,
  13, 0, 0, 3, 0, 0,
  13, 1, 3, 5, 1, 0,
  13, 2, 5, 7, 1, 1,
  13, 3, 7, 3, 3, 2,
  13, 4, 9, 10, 1, 3,
  13, 5, 15, 4, 3, 4,
  13, 6, 31, 5, 3, 5,
  13, 7, 65535, 16, 3, 16,
  14, 0, 0, 3, 0, 0,
  14, 1, 3, 5, 1, 0,
  14, 2, 5, 7, 1, 1,
  14, 3, 7, 3, 3, 2,
  14, 4, 9, 10, 1, 3,
  14, 5, 15, 4, 3, 4,
  14, 6, 31, 5, 3, 5,
  14, 7, 65535, 16, 3, 16,
  15, 0, 0, 3, 0, 0,
  15, 1, 3, 5, 1, 0,
  15, 2, 5, 7, 1, 1,
  15, 3, 7, 3, 3, 2,
  15, 4, 9, 10, 1, 3,
  15, 5, 15, 4, 3, 4,
  15, 6, 31, 5, 3, 5,
  15, 7, 65535, 16, 3, 16,
  16, 0, 0, 3, 0, 0,
  16, 1, 3, 5, 1, 0,
  16, 2, 5, 7, 1, 1,
  16, 3, 7, 3, 3, 2,
  16, 4, 9, 10, 1, 3,
  16, 5, 15, 4, 3, 4,
  16, 6, 31, 5, 3, 5,
  16, 7, 65535, 16, 3, 16,
  17, 0, 0, 3, 0, 0,
  17, 1, 3, 5, 1, 0,
  17, 2, 5, 7, 1, 1,
  17, 3, 7, 3, 3, 2,
  17, 4, 9, 10, 1, 3,
  17, 5, 15, 4, 3, 4,
  17, 6, 31, 5, 3, 5,
  17, 7, 65535, 16, 3, 16,
  18, 0, 0, 3, 0, 0,
  18, 1, 3, 5, 1, 0,
  18, 2, 5, 7, 1, 1,
  18, 3, 7, 3, 3, 2,
  18, 4, 9, 10, 1, 3,
  18, 5, 15, 4, 3, 4,
  18, 6, 31, 5, 3, 5,
  18, 7, 65535, 16, 3, 16,
  19, 0, 0, 3, 0, 0,
  19, 1, 3, 5, 1, 0,
  19, 2, 5, 7, 1, 1,
  19, 3, 7, 3, 3, 2,
  19, 4, 9, 10, 1, 3,
  19, 5, 15, 4, 3, 4,
  19, 6, 31, 5, 3, 5,
  19, 7, 65535, 16, 3, 16,
  20, 0, 0, 3, 0, 0,
  20, 1, 3, 5, 1, 0,
  20, 2, 5, 7, 1, 1,
  20, 3, 7, 3, 3, 2,
  20, 4, 9, 10, 1, 3,
  20, 5, 15, 4, 3, 4,
  20, 6, 31, 5, 3, 5,
  20, 7, 65535, 16, 3, 16,
  21, 0, 0, 3, 0, 0,
  21, 1, 3, 5, 1, 0,
  21, 2, 5, 7, 1, 1,
  21, 3, 7, 3, 3, 2,
  21, 4, 9, 10, 1, 3,
  21, 5, 15, 4, 3, 4,
  21, 6, 31, 5, 3, 5,
  21, 7, 65535, 16, 3, 16,
  22, 0, 0, 3, 0, 0,
  22, 1, 3, 5, 1, 0,
  22, 2, 5, 7, 1, 1,
  22, 3, 7, 3, 3, 2,
  22, 4, 9, 10, 1, 3,
  22, 5, 15, 4, 3, 4,
  22, 6, 31, 5, 3, 5,
  22, 7, 65535, 16, 3, 16,
  23, 0, 0, 2, 0, 0,
  23, 1, 3, 5, 1, 0,
  23, 2, 5, 7, 1, 1,
  23, 3, 65535, 16, 3, 16,
  24, 0, 0, 2, 0, 0,
  24, 1, 3, 5, 1, 0,
  24, 2, 5, 7, 1, 1,
  24, 3, 65535, 16, 3, 16,
  25, 0, 0, 2, 0, 0,
  25, 1, 3, 5, 1, 0,
  25, 2, 5, 7, 1, 1,
  25, 3, 65535, 16, 3, 16,
  26, 0, 0, 2, 0, 0,
  26, 1, 3, 5, 1, 0,
  26, 2, 5, 7, 1, 1,
  26, 3, 65535, 16, 3, 16
};

/* Table alloc_1*/
static unsigned short alloc_1[] = {
  0, 0, 0, 4, 0, 0,
  0, 1, 3, 5, 1, 0,
  0, 2, 7, 3, 3, 2,
  0, 3, 15, 4, 3, 4,
  0, 4, 31, 5, 3, 5,
  0, 5, 63, 6, 3, 6,
  0, 6, 127, 7, 3, 7,
  0, 7, 255, 8, 3, 8,
  0, 8, 511, 9, 3, 9,
  0, 9, 1023, 10, 3, 10,
  0, 10, 2047, 11, 3, 11,
  0, 11, 4095, 12, 3, 12,
  0, 12, 8191, 13, 3, 13,
  0, 13, 16383, 14, 3, 14,
  0, 14, 32767, 15, 3, 15,
  0, 15, 65535, 16, 3, 16,
  1, 0, 0, 4, 0, 0,
  1, 1, 3, 5, 1, 0,
  1, 2, 7, 3, 3, 2,
  1, 3, 15, 4, 3, 4,
  1, 4, 31, 5, 3, 5,
  1, 5, 63, 6, 3, 6,
  1, 6, 127, 7, 3, 7,
  1, 7, 255, 8, 3, 8,
  1, 8, 511, 9, 3, 9,
  1, 9, 1023, 10, 3, 10,
  1, 10, 2047, 11, 3, 11,
  1, 11, 4095, 12, 3, 12,
  1, 12, 8191, 13, 3, 13,
  1, 13, 16383, 14, 3, 14,
  1, 14, 32767, 15, 3, 15,
  1, 15, 65535, 16, 3, 16,
  2, 0, 0, 4, 0, 0,
  2, 1, 3, 5, 1, 0,
  2, 2, 7, 3, 3, 2,
  2, 3, 15, 4, 3, 4,
  2, 4, 31, 5, 3, 5,
  2, 5, 63, 6, 3, 6,
  2, 6, 127, 7, 3, 7,
  2, 7, 255, 8, 3, 8,
  2, 8, 511, 9, 3, 9,
  2, 9, 1023, 10, 3, 10,
  2, 10, 2047, 11, 3, 11,
  2, 11, 4095, 12, 3, 12,
  2, 12, 8191, 13, 3, 13,
  2, 13, 16383, 14, 3, 14,
  2, 14, 32767, 15, 3, 15,
  2, 15, 65535, 16, 3, 16,
  3, 0, 0, 4, 0, 0,
  3, 1, 3, 5, 1, 0,
  3, 2, 5, 7, 1, 1,
  3, 3, 7, 3, 3, 2,
  3, 4, 9, 10, 1, 3,
  3, 5, 15, 4, 3, 4,
  3, 6, 31, 5, 3, 5,
  3, 7, 63, 6, 3, 6,
  3, 8, 127, 7, 3, 7,
  3, 9, 255, 8, 3, 8,
  3, 10, 511, 9, 3, 9,
  3, 11, 1023, 10, 3, 10,
  3, 12, 2047, 11, 3, 11,
  3, 13, 4095, 12, 3, 12,
  3, 14, 8191, 13, 3, 13,
  3, 15, 65535, 16, 3, 16,
  4, 0, 0, 4, 0, 0,
  4, 1, 3, 5, 1, 0,
  4, 2, 5, 7, 1, 1,
  4, 3, 7, 3, 3, 2,
  4, 4, 9, 10, 1, 3,
  4, 5, 15, 4, 3, 4,
  4, 6, 31, 5, 3, 5,
  4, 7, 63, 6, 3, 6,
  4, 8, 127, 7, 3, 7,
  4, 9, 255, 8, 3, 8,
  4, 10, 511, 9, 3, 9,
  4, 11, 1023, 10, 3, 10,
  4, 12, 2047, 11, 3, 11,
  4, 13, 4095, 12, 3, 12,
  4, 14, 8191, 13, 3, 13,
  4, 15, 65535, 16, 3, 16,
  5, 0, 0, 4, 0, 0,
  5, 1, 3, 5, 1, 0,
  5, 2, 5, 7, 1, 1,
  5, 3, 7, 3, 3, 2,
  5, 4, 9, 10, 1, 3,
  5, 5, 15, 4, 3, 4,
  5, 6, 31, 5, 3, 5,
  5, 7, 63, 6, 3, 6,
  5, 8, 127, 7, 3, 7,
  5, 9, 255, 8, 3, 8,
  5, 10, 511, 9, 3, 9,
  5, 11, 1023, 10, 3, 10,
  5, 12, 2047, 11, 3, 11,
  5, 13, 4095, 12, 3, 12,
  5, 14, 8191, 13, 3, 13,
  5, 15, 65535, 16, 3, 16,
  6, 0, 0, 4, 0, 0,
  6, 1, 3, 5, 1, 0,
  6, 2, 5, 7, 1, 1,
  6, 3, 7, 3, 3, 2,
  6, 4, 9, 10, 1, 3,
  6, 5, 15, 4, 3, 4,
  6, 6, 31, 5, 3, 5,
  6, 7, 63, 6, 3, 6,
  6, 8, 127, 7, 3, 7,
  6, 9, 255, 8, 3, 8,
  6, 10, 511, 9, 3, 9,
  6, 11, 1023, 10, 3, 10,
  6, 12, 2047, 11, 3, 11,
  6, 13, 4095, 12, 3, 12,
  6, 14, 8191, 13, 3, 13,
  6, 15, 65535, 16, 3, 16,
  7, 0, 0, 4, 0, 0,
  7, 1, 3, 5, 1, 0,
  7, 2, 5, 7, 1, 1,
  7, 3, 7, 3, 3, 2,
  7, 4, 9, 10, 1, 3,
  7, 5, 15, 4, 3, 4,
  7, 6, 31, 5, 3, 5,
  7, 7, 63, 6, 3, 6,
  7, 8, 127, 7, 3, 7,
  7, 9, 255, 8, 3, 8,
  7, 10, 511, 9, 3, 9,
  7, 11, 1023, 10, 3, 10,
  7, 12, 2047, 11, 3, 11,
  7, 13, 4095, 12, 3, 12,
  7, 14, 8191, 13, 3, 13,
  7, 15, 65535, 16, 3, 16,
  8, 0, 0, 4, 0, 0,
  8, 1, 3, 5, 1, 0,
  8, 2, 5, 7, 1, 1,
  8, 3, 7, 3, 3, 2,
  8, 4, 9, 10, 1, 3,
  8, 5, 15, 4, 3, 4,
  8, 6, 31, 5, 3, 5,
  8, 7, 63, 6, 3, 6,
  8, 8, 127, 7, 3, 7,
  8, 9, 255, 8, 3, 8,
  8, 10, 511, 9, 3, 9,
  8, 11, 1023, 10, 3, 10,
  8, 12, 2047, 11, 3, 11,
  8, 13, 4095, 12, 3, 12,
  8, 14, 8191, 13, 3, 13,
  8, 15, 65535, 16, 3, 16,
  9, 0, 0, 4, 0, 0,
  9, 1, 3, 5, 1, 0,
  9, 2, 5, 7, 1, 1,
  9, 3, 7, 3, 3, 2,
  9, 4, 9, 10, 1, 3,
  9, 5, 15, 4, 3, 4,
  9, 6, 31, 5, 3, 5,
  9, 7, 63, 6, 3, 6,
  9, 8, 127, 7, 3, 7,
  9, 9, 255, 8, 3, 8,
  9, 10, 511, 9, 3, 9,
  9, 11, 1023, 10, 3, 10,
  9, 12, 2047, 11, 3, 11,
  9, 13, 4095, 12, 3, 12,
  9, 14, 8191, 13, 3, 13,
  9, 15, 65535, 16, 3, 16,
  10, 0, 0, 4, 0, 0,
  10, 1, 3, 5, 1, 0,
  10, 2, 5, 7, 1, 1,
  10, 3, 7, 3, 3, 2,
  10, 4, 9, 10, 1, 3,
  10, 5, 15, 4, 3, 4,
  10, 6, 31, 5, 3, 5,
  10, 7, 63, 6, 3, 6,
  10, 8, 127, 7, 3, 7,
  10, 9, 255, 8, 3, 8,
  10, 10, 511, 9, 3, 9,
  10, 11, 1023, 10, 3, 10,
  10, 12, 2047, 11, 3, 11,
  10, 13, 4095, 12, 3, 12,
  10, 14, 8191, 13, 3, 13,
  10, 15, 65535, 16, 3, 16,
  11, 0, 0, 3, 0, 0,
  11, 1, 3, 5, 1, 0,
  11, 2, 5, 7, 1, 1,
  11, 3, 7, 3, 3, 2,
  11, 4, 9, 10, 1, 3,
  11, 5, 15, 4, 3, 4,
  11, 6, 31, 5, 3, 5,
  11, 7, 65535, 16, 3, 16,
  12, 0, 0, 3, 0, 0,
  12, 1, 3, 5, 1, 0,
  12, 2, 5, 7, 1, 1,
  12, 3, 7, 3, 3, 2,
  12, 4, 9, 10, 1, 3,
  12, 5, 15, 4, 3, 4,
  12, 6, 31, 5, 3, 5,
  12, 7, 65535, 16, 3, 16,
  13, 0, 0, 3, 0, 0,
  13, 1, 3, 5, 1, 0,
  13, 2, 5, 7, 1, 1,
  13, 3, 7, 3, 3, 2,
  13, 4, 9, 10, 1, 3,
  13, 5, 15, 4, 3, 4,
  13, 6, 31, 5, 3, 5,
  13, 7, 65535, 16, 3, 16,
  14, 0, 0, 3, 0, 0,
  14, 1, 3, 5, 1, 0,
  14, 2, 5, 7, 1, 1,
  14, 3, 7, 3, 3, 2,
  14, 4, 9, 10, 1, 3,
  14, 5, 15, 4, 3, 4,
  14, 6, 31, 5, 3, 5,
  14, 7, 65535, 16, 3, 16,
  15, 0, 0, 3, 0, 0,
  15, 1, 3, 5, 1, 0,
  15, 2, 5, 7, 1, 1,
  15, 3, 7, 3, 3, 2,
  15, 4, 9, 10, 1, 3,
  15, 5, 15, 4, 3, 4,
  15, 6, 31, 5, 3, 5,
  15, 7, 65535, 16, 3, 16,
  16, 0, 0, 3, 0, 0,
  16, 1, 3, 5, 1, 0,
  16, 2, 5, 7, 1, 1,
  16, 3, 7, 3, 3, 2,
  16, 4, 9, 10, 1, 3,
  16, 5, 15, 4, 3, 4,
  16, 6, 31, 5, 3, 5,
  16, 7, 65535, 16, 3, 16,
  17, 0, 0, 3, 0, 0,
  17, 1, 3, 5, 1, 0,
  17, 2, 5, 7, 1, 1,
  17, 3, 7, 3, 3, 2,
  17, 4, 9, 10, 1, 3,
  17, 5, 15, 4, 3, 4,
  17, 6, 31, 5, 3, 5,
  17, 7, 65535, 16, 3, 16,
  18, 0, 0, 3, 0, 0,
  18, 1, 3, 5, 1, 0,
  18, 2, 5, 7, 1, 1,
  18, 3, 7, 3, 3, 2,
  18, 4, 9, 10, 1, 3,
  18, 5, 15, 4, 3, 4,
  18, 6, 31, 5, 3, 5,
  18, 7, 65535, 16, 3, 16,
  19, 0, 0, 3, 0, 0,
  19, 1, 3, 5, 1, 0,
  19, 2, 5, 7, 1, 1,
  19, 3, 7, 3, 3, 2,
  19, 4, 9, 10, 1, 3,
  19, 5, 15, 4, 3, 4,
  19, 6, 31, 5, 3, 5,
  19, 7, 65535, 16, 3, 16,
  20, 0, 0, 3, 0, 0,
  20, 1, 3, 5, 1, 0,
  20, 2, 5, 7, 1, 1,
  20, 3, 7, 3, 3, 2,
  20, 4, 9, 10, 1, 3,
  20, 5, 15, 4, 3, 4,
  20, 6, 31, 5, 3, 5,
  20, 7, 65535, 16, 3, 16,
  21, 0, 0, 3, 0, 0,
  21, 1, 3, 5, 1, 0,
  21, 2, 5, 7, 1, 1,
  21, 3, 7, 3, 3, 2,
  21, 4, 9, 10, 1, 3,
  21, 5, 15, 4, 3, 4,
  21, 6, 31, 5, 3, 5,
  21, 7, 65535, 16, 3, 16,
  22, 0, 0, 3, 0, 0,
  22, 1, 3, 5, 1, 0,
  22, 2, 5, 7, 1, 1,
  22, 3, 7, 3, 3, 2,
  22, 4, 9, 10, 1, 3,
  22, 5, 15, 4, 3, 4,
  22, 6, 31, 5, 3, 5,
  22, 7, 65535, 16, 3, 16,
  23, 0, 0, 2, 0, 0,
  23, 1, 3, 5, 1, 0,
  23, 2, 5, 7, 1, 1,
  23, 3, 65535, 16, 3, 16,
  24, 0, 0, 2, 0, 0,
  24, 1, 3, 5, 1, 0,
  24, 2, 5, 7, 1, 1,
  24, 3, 65535, 16, 3, 16,
  25, 0, 0, 2, 0, 0,
  25, 1, 3, 5, 1, 0,
  25, 2, 5, 7, 1, 1,
  25, 3, 65535, 16, 3, 16,
  26, 0, 0, 2, 0, 0,
  26, 1, 3, 5, 1, 0,
  26, 2, 5, 7, 1, 1,
  26, 3, 65535, 16, 3, 16,
  27, 0, 0, 2, 0, 0,
  27, 1, 3, 5, 1, 0,
  27, 2, 5, 7, 1, 1,
  27, 3, 65535, 16, 3, 16,
  28, 0, 0, 2, 0, 0,
  28, 1, 3, 5, 1, 0,
  28, 2, 5, 7, 1, 1,
  28, 3, 65535, 16, 3, 16,
  29, 0, 0, 2, 0, 0,
  29, 1, 3, 5, 1, 0,
  29, 2, 5, 7, 1, 1,
  29, 3, 65535, 16, 3, 16
};

/* Table alloc_2*/
static unsigned short alloc_2[] = {
  0, 0, 0, 4, 0, 0,
  0, 1, 3, 5, 1, 0,
  0, 2, 5, 7, 1, 1,
  0, 3, 9, 10, 1, 3,
  0, 4, 15, 4, 3, 4,
  0, 5, 31, 5, 3, 5,
  0, 6, 63, 6, 3, 6,
  0, 7, 127, 7, 3, 7,
  0, 8, 255, 8, 3, 8,
  0, 9, 511, 9, 3, 9,
  0, 10, 1023, 10, 3, 10,
  0, 11, 2047, 11, 3, 11,
  0, 12, 4095, 12, 3, 12,
  0, 13, 8191, 13, 3, 13,
  0, 14, 16383, 14, 3, 14,
  0, 15, 32767, 15, 3, 15,
  1, 0, 0, 4, 0, 0,
  1, 1, 3, 5, 1, 0,
  1, 2, 5, 7, 1, 1,
  1, 3, 9, 10, 1, 3,
  1, 4, 15, 4, 3, 4,
  1, 5, 31, 5, 3, 5,
  1, 6, 63, 6, 3, 6,
  1, 7, 127, 7, 3, 7,
  1, 8, 255, 8, 3, 8,
  1, 9, 511, 9, 3, 9,
  1, 10, 1023, 10, 3, 10,
  1, 11, 2047, 11, 3, 11,
  1, 12, 4095, 12, 3, 12,
  1, 13, 8191, 13, 3, 13,
  1, 14, 16383, 14, 3, 14,
  1, 15, 32767, 15, 3, 15,
  2, 0, 0, 3, 0, 0,
  2, 1, 3, 5, 1, 0,
  2, 2, 5, 7, 1, 1,
  2, 3, 9, 10, 1, 3,
  2, 4, 15, 4, 3, 4,
  2, 5, 31, 5, 3, 5,
  2, 6, 63, 6, 3, 6,
  2, 7, 127, 7, 3, 7,
  3, 0, 0, 3, 0, 0,
  3, 1, 3, 5, 1, 0,
  3, 2, 5, 7, 1, 1,
  3, 3, 9, 10, 1, 3,
  3, 4, 15, 4, 3, 4,
  3, 5, 31, 5, 3, 5,
  3, 6, 63, 6, 3, 6,
  3, 7, 127, 7, 3, 7,
  4, 0, 0, 3, 0, 0,
  4, 1, 3, 5, 1, 0,
  4, 2, 5, 7, 1, 1,
  4, 3, 9, 10, 1, 3,
  4, 4, 15, 4, 3, 4,
  4, 5, 31, 5, 3, 5,
  4, 6, 63, 6, 3, 6,
  4, 7, 127, 7, 3, 7,
  5, 0, 0, 3, 0, 0,
  5, 1, 3, 5, 1, 0,
  5, 2, 5, 7, 1, 1,
  5, 3, 9, 10, 1, 3,
  5, 4, 15, 4, 3, 4,
  5, 5, 31, 5, 3, 5,
  5, 6, 63, 6, 3, 6,
  5, 7, 127, 7, 3, 7,
  6, 0, 0, 3, 0, 0,
  6, 1, 3, 5, 1, 0,
  6, 2, 5, 7, 1, 1,
  6, 3, 9, 10, 1, 3,
  6, 4, 15, 4, 3, 4,
  6, 5, 31, 5, 3, 5,
  6, 6, 63, 6, 3, 6,
  6, 7, 127, 7, 3, 7,
  7, 0, 0, 3, 0, 0,
  7, 1, 3, 5, 1, 0,
  7, 2, 5, 7, 1, 1,
  7, 3, 9, 10, 1, 3,
  7, 4, 15, 4, 3, 4,
  7, 5, 31, 5, 3, 5,
  7, 6, 63, 6, 3, 6,
  7, 7, 127, 7, 3, 7
};

/* Table alloc_3*/
static unsigned short alloc_3[] = {
  0, 0, 0, 4, 0, 0,
  0, 1, 3, 5, 1, 0,
  0, 2, 5, 7, 1, 1,
  0, 3, 9, 10, 1, 3,
  0, 4, 15, 4, 3, 4,
  0, 5, 31, 5, 3, 5,
  0, 6, 63, 6, 3, 6,
  0, 7, 127, 7, 3, 7,
  0, 8, 255, 8, 3, 8,
  0, 9, 511, 9, 3, 9,
  0, 10, 1023, 10, 3, 10,
  0, 11, 2047, 11, 3, 11,
  0, 12, 4095, 12, 3, 12,
  0, 13, 8191, 13, 3, 13,
  0, 14, 16383, 14, 3, 14,
  0, 15, 32767, 15, 3, 15,
  1, 0, 0, 4, 0, 0,
  1, 1, 3, 5, 1, 0,
  1, 2, 5, 7, 1, 1,
  1, 3, 9, 10, 1, 3,
  1, 4, 15, 4, 3, 4,
  1, 5, 31, 5, 3, 5,
  1, 6, 63, 6, 3, 6,
  1, 7, 127, 7, 3, 7,
  1, 8, 255, 8, 3, 8,
  1, 9, 511, 9, 3, 9,
  1, 10, 1023, 10, 3, 10,
  1, 11, 2047, 11, 3, 11,
  1, 12, 4095, 12, 3, 12,
  1, 13, 8191, 13, 3, 13,
  1, 14, 16383, 14, 3, 14,
  1, 15, 32767, 15, 3, 15,
  2, 0, 0, 3, 0, 0,
  2, 1, 3, 5, 1, 0,
  2, 2, 5, 7, 1, 1,
  2, 3, 9, 10, 1, 3,
  2, 4, 15, 4, 3, 4,
  2, 5, 31, 5, 3, 5,
  2, 6, 63, 6, 3, 6,
  2, 7, 127, 7, 3, 7,
  3, 0, 0, 3, 0, 0,
  3, 1, 3, 5, 1, 0,
  3, 2, 5, 7, 1, 1,
  3, 3, 9, 10, 1, 3,
  3, 4, 15, 4, 3, 4,
  3, 5, 31, 5, 3, 5,
  3, 6, 63, 6, 3, 6,
  3, 7, 127, 7, 3, 7,
  4, 0, 0, 3, 0, 0,
  4, 1, 3, 5, 1, 0,
  4, 2, 5, 7, 1, 1,
  4, 3, 9, 10, 1, 3,
  4, 4, 15, 4, 3, 4,
  4, 5, 31, 5, 3, 5,
  4, 6, 63, 6, 3, 6,
  4, 7, 127, 7, 3, 7,
  5, 0, 0, 3, 0, 0,
  5, 1, 3, 5, 1, 0,
  5, 2, 5, 7, 1, 1,
  5, 3, 9, 10, 1, 3,
  5, 4, 15, 4, 3, 4,
  5, 5, 31, 5, 3, 5,
  5, 6, 63, 6, 3, 6,
  5, 7, 127, 7, 3, 7,
  6, 0, 0, 3, 0, 0,
  6, 1, 3, 5, 1, 0,
  6, 2, 5, 7, 1, 1,
  6, 3, 9, 10, 1, 3,
  6, 4, 15, 4, 3, 4,
  6, 5, 31, 5, 3, 5,
  6, 6, 63, 6, 3, 6,
  6, 7, 127, 7, 3, 7,
  7, 0, 0, 3, 0, 0,
  7, 1, 3, 5, 1, 0,
  7, 2, 5, 7, 1, 1,
  7, 3, 9, 10, 1, 3,
  7, 4, 15, 4, 3, 4,
  7, 5, 31, 5, 3, 5,
  7, 6, 63, 6, 3, 6,
  7, 7, 127, 7, 3, 7,
  8, 0, 0, 3, 0, 0,
  8, 1, 3, 5, 1, 0,
  8, 2, 5, 7, 1, 1,
  8, 3, 9, 10, 1, 3,
  8, 4, 15, 4, 3, 4,
  8, 5, 31, 5, 3, 5,
  8, 6, 63, 6, 3, 6,
  8, 7, 127, 7, 3, 7,
  9, 0, 0, 3, 0, 0,
  9, 1, 3, 5, 1, 0,
  9, 2, 5, 7, 1, 1,
  9, 3, 9, 10, 1, 3,
  9, 4, 15, 4, 3, 4,
  9, 5, 31, 5, 3, 5,
  9, 6, 63, 6, 3, 6,
  9, 7, 127, 7, 3, 7,
  10, 0, 0, 3, 0, 0,
  10, 1, 3, 5, 1, 0,
  10, 2, 5, 7, 1, 1,
  10, 3, 9, 10, 1, 3,
  10, 4, 15, 4, 3, 4,
  10, 5, 31, 5, 3, 5,
  10, 6, 63, 6, 3, 6,
  10, 7, 127, 7, 3, 7,
  11, 0, 0, 3, 0, 0,
  11, 1, 3, 5, 1, 0,
  11, 2, 5, 7, 1, 1,
  11, 3, 9, 10, 1, 3,
  11, 4, 15, 4, 3, 4,
  11, 5, 31, 5, 3, 5,
  11, 6, 63, 6, 3, 6,
  11, 7, 127, 7, 3, 7
};

/* Table alloc_4*/
static unsigned short alloc_4[] = {
  0, 0, 0, 4, 0, 0,
  0, 1, 3, 5, 1, 0,
  0, 2, 5, 7, 1, 1,
  0, 3, 7, 3, 3, 2,
  0, 4, 9, 10, 1, 3,
  0, 5, 15, 4, 3, 4,
  0, 6, 31, 5, 3, 5,
  0, 7, 63, 6, 3, 6,
  0, 8, 127, 7, 3, 7,
  0, 9, 255, 8, 3, 8,
  0, 10, 511, 9, 3, 9,
  0, 11, 1023, 10, 3, 10,
  0, 12, 2047, 11, 3, 11,
  0, 13, 4095, 12, 3, 12,
  0, 14, 8191, 13, 3, 13,
  0, 15, 16383, 14, 3, 14,
  1, 0, 0, 4, 0, 0,
  1, 1, 3, 5, 1, 0,
  1, 2, 5, 7, 1, 1,
  1, 3, 7, 3, 3, 2,
  1, 4, 9, 10, 1, 3,
  1, 5, 15, 4, 3, 4,
  1, 6, 31, 5, 3, 5,
  1, 7, 63, 6, 3, 6,
  1, 8, 127, 7, 3, 7,
  1, 9, 255, 8, 3, 8,
  1, 10, 511, 9, 3, 9,
  1, 11, 1023, 10, 3, 10,
  1, 12, 2047, 11, 3, 11,
  1, 13, 4095, 12, 3, 12,
  1, 14, 8191, 13, 3, 13,
  1, 15, 16383, 14, 3, 14,
  2, 0, 0, 4, 0, 0,
  2, 1, 3, 5, 1, 0,
  2, 2, 5, 7, 1, 1,
  2, 3, 7, 3, 3, 2,
  2, 4, 9, 10, 1, 3,
  2, 5, 15, 4, 3, 4,
  2, 6, 31, 5, 3, 5,
  2, 7, 63, 6, 3, 6,
  2, 8, 127, 7, 3, 7,
  2, 9, 255, 8, 3, 8,
  2, 10, 511, 9, 3, 9,
  2, 11, 1023, 10, 3, 10,
  2, 12, 2047, 11, 3, 11,
  2, 13, 4095, 12, 3, 12,
  2, 14, 8191, 13, 3, 13,
  2, 15, 16383, 14, 3, 14,
  3, 0, 0, 4, 0, 0,
  3, 1, 3, 5, 1, 0,
  3, 2, 5, 7, 1, 1,
  3, 3, 7, 3, 3, 2,
  3, 4, 9, 10, 1, 3,
  3, 5, 15, 4, 3, 4,
  3, 6, 31, 5, 3, 5,
  3, 7, 63, 6, 3, 6,
  3, 8, 127, 7, 3, 7,
  3, 9, 255, 8, 3, 8,
  3, 10, 511, 9, 3, 9,
  3, 11, 1023, 10, 3, 10,
  3, 12, 2047, 11, 3, 11,
  3, 13, 4095, 12, 3, 12,
  3, 14, 8191, 13, 3, 13,
  3, 15, 16383, 14, 3, 14,
  4, 0, 0, 3, 0, 0,
  4, 1, 3, 5, 1, 0,
  4, 2, 5, 7, 1, 1,
  4, 3, 9, 10, 1, 3,
  4, 4, 15, 4, 3, 4,
  4, 5, 31, 5, 3, 5,
  4, 6, 63, 6, 3, 6,
  4, 7, 127, 7, 3, 7,
  5, 0, 0, 3, 0, 0,
  5, 1, 3, 5, 1, 0,
  5, 2, 5, 7, 1, 1,
  5, 3, 9, 10, 1, 3,
  5, 4, 15, 4, 3, 4,
  5, 5, 31, 5, 3, 5,
  5, 6, 63, 6, 3, 6,
  5, 7, 127, 7, 3, 7,
  6, 0, 0, 3, 0, 0,
  6, 1, 3, 5, 1, 0,
  6, 2, 5, 7, 1, 1,
  6, 3, 9, 10, 1, 3,
  6, 4, 15, 4, 3, 4,
  6, 5, 31, 5, 3, 5,
  6, 6, 63, 6, 3, 6,
  6, 7, 127, 7, 3, 7,
  7, 0, 0, 3, 0, 0,
  7, 1, 3, 5, 1, 0,
  7, 2, 5, 7, 1, 1,
  7, 3, 9, 10, 1, 3,
  7, 4, 15, 4, 3, 4,
  7, 5, 31, 5, 3, 5,
  7, 6, 63, 6, 3, 6,
  7, 7, 127, 7, 3, 7,
  8, 0, 0, 3, 0, 0,
  8, 1, 3, 5, 1, 0,
  8, 2, 5, 7, 1, 1,
  8, 3, 9, 10, 1, 3,
  8, 4, 15, 4, 3, 4,
  8, 5, 31, 5, 3, 5,
  8, 6, 63, 6, 3, 6,
  8, 7, 127, 7, 3, 7,
  9, 0, 0, 3, 0, 0,
  9, 1, 3, 5, 1, 0,
  9, 2, 5, 7, 1, 1,
  9, 3, 9, 10, 1, 3,
  9, 4, 15, 4, 3, 4,
  9, 5, 31, 5, 3, 5,
  9, 6, 63, 6, 3, 6,
  9, 7, 127, 7, 3, 7,
  10, 0, 0, 3, 0, 0,
  10, 1, 3, 5, 1, 0,
  10, 2, 5, 7, 1, 1,
  10, 3, 9, 10, 1, 3,
  10, 4, 15, 4, 3, 4,
  10, 5, 31, 5, 3, 5,
  10, 6, 63, 6, 3, 6,
  10, 7, 127, 7, 3, 7,
  11, 0, 0, 2, 0, 0,
  11, 1, 3, 5, 1, 0,
  11, 2, 5, 7, 1, 1,
  11, 3, 9, 10, 1, 3,
  12, 0, 0, 2, 0, 0,
  12, 1, 3, 5, 1, 0,
  12, 2, 5, 7, 1, 1,
  12, 3, 9, 10, 1, 3,
  13, 0, 0, 2, 0, 0,
  13, 1, 3, 5, 1, 0,
  13, 2, 5, 7, 1, 1,
  13, 3, 9, 10, 1, 3,
  14, 0, 0, 2, 0, 0,
  14, 1, 3, 5, 1, 0,
  14, 2, 5, 7, 1, 1,
  14, 3, 9, 10, 1, 3,
  15, 0, 0, 2, 0, 0,
  15, 1, 3, 5, 1, 0,
  15, 2, 5, 7, 1, 1,
  15, 3, 9, 10, 1, 3,
  16, 0, 0, 2, 0, 0,
  16, 1, 3, 5, 1, 0,
  16, 2, 5, 7, 1, 1,
  16, 3, 9, 10, 1, 3,
  17, 0, 0, 2, 0, 0,
  17, 1, 3, 5, 1, 0,
  17, 2, 5, 7, 1, 1,
  17, 3, 9, 10, 1, 3,
  18, 0, 0, 2, 0, 0,
  18, 1, 3, 5, 1, 0,
  18, 2, 5, 7, 1, 1,
  18, 3, 9, 10, 1, 3,
  19, 0, 0, 2, 0, 0,
  19, 1, 3, 5, 1, 0,
  19, 2, 5, 7, 1, 1,
  19, 3, 9, 10, 1, 3,
  20, 0, 0, 2, 0, 0,
  20, 1, 3, 5, 1, 0,
  20, 2, 5, 7, 1, 1,
  20, 3, 9, 10, 1, 3,
  21, 0, 0, 2, 0, 0,
  21, 1, 3, 5, 1, 0,
  21, 2, 5, 7, 1, 1,
  21, 3, 9, 10, 1, 3,
  22, 0, 0, 2, 0, 0,
  22, 1, 3, 5, 1, 0,
  22, 2, 5, 7, 1, 1,
  22, 3, 9, 10, 1, 3,
  23, 0, 0, 2, 0, 0,
  23, 1, 3, 5, 1, 0,
  23, 2, 5, 7, 1, 1,
  23, 3, 9, 10, 1, 3,
  24, 0, 0, 2, 0, 0,
  24, 1, 3, 5, 1, 0,
  24, 2, 5, 7, 1, 1,
  24, 3, 9, 10, 1, 3,
  25, 0, 0, 2, 0, 0,
  25, 1, 3, 5, 1, 0,
  25, 2, 5, 7, 1, 1,
  25, 3, 9, 10, 1, 3,
  26, 0, 0, 2, 0, 0,
  26, 1, 3, 5, 1, 0,
  26, 2, 5, 7, 1, 1,
  26, 3, 9, 10, 1, 3,
  27, 0, 0, 2, 0, 0,
  27, 1, 3, 5, 1, 0,
  27, 2, 5, 7, 1, 1,
  27, 3, 9, 10, 1, 3,
  28, 0, 0, 2, 0, 0,
  28, 1, 3, 5, 1, 0,
  28, 2, 5, 7, 1, 1,
  28, 3, 9, 10, 1, 3,
  29, 0, 0, 2, 0, 0,
  29, 1, 3, 5, 1, 0,
  29, 2, 5, 7, 1, 1,
  29, 3, 9, 10, 1, 3
};

/* Subband limits for each table*/
static int sblim[NALLOCTAB] = {27, 30, 8, 12, 30};
/***********************************************************************
 *
 * Read one of the data tables ("alloc_*") specifying the bit allocation/
 * quatization parameters for each subband in layer II encoding
 *
 **********************************************************************/

static int read_bit_alloc(     /* read in table, return # subbands */
    int          table,
    al_table    *alloc)
{
  unsigned int         a, b, c, d, i, j, n, nitems;
  unsigned short      *p;

  switch (table) {
    case 0:
    default:
      p = &alloc_0[0];
      nitems = sizeof(alloc_0)/sizeof(unsigned short);
      break;
    case 1:
      p = &alloc_1[0];
      nitems = sizeof(alloc_1)/sizeof(unsigned short);
      break;
    case 2:
      p = &alloc_2[0];
      nitems = sizeof(alloc_2)/sizeof(unsigned short);
      break;
    case 3:
      p = &alloc_3[0];
      nitems = sizeof(alloc_3)/sizeof(unsigned short);
      break;
    case 4:
      p = &alloc_4[0];
      nitems = sizeof(alloc_4)/sizeof(unsigned short);
      break;          /* LSF, added 1995-07-11 shn */
  }

  n = 0;
  while (n < nitems) {
    i = *p++; j = *p++;
    a = *p++; b = *p++; c = *p++; d = *p++;
    (*alloc)[i][j].steps = a;
    (*alloc)[i][j].bits  = b;
    (*alloc)[i][j].group = c;
    (*alloc)[i][j].quant = d;
    n += 6;
  }

  return sblim[table];
}

/***********************************************************************
 *
 * Using the decoded info the appropriate possible quantization per
 * subband table is loaded
 *
 **********************************************************************/

static int pick_table(         /* choose table, load if necess, return # sb's */
    frame_params *fr_ps)
{
  int table, lay, ws, bsp, br_per_ch, sfrq,ver;
  int sblim = fr_ps->sblimit;     /* return current value if no load */

  ver = fr_ps->header.version;
  lay = fr_ps->header.lay - 1;
  bsp = fr_ps->header.bitrate_index;
  br_per_ch = bitrate[ver][lay][bsp] / fr_ps->stereo;
  ws = fr_ps->header.sampling_frequency;
  sfrq = (int)s_freq[ver][ws];

  /* decision rules refer to per-channel bitrates (kbits/sec/chan) */
  if (fr_ps->header.version == MPEG_AUDIO_ID) { /* MPEG-1 */
    if ((sfrq == 48 && br_per_ch >= 56) ||
        (br_per_ch >= 56 && br_per_ch <= 80)) table = 0;
    else if (sfrq != 48 && br_per_ch >= 96) table = 1;
    else if (sfrq != 32 && br_per_ch <= 48) table = 2;
    else table = 3;
  }
  else { /* MPEG-2 LSF */
    table = 4;
  }

  if (fr_ps->tab_num != table) {
    sblim = read_bit_alloc(fr_ps->tab_num = table, &fr_ps->alloc);
  }
  return sblim;
}


static int js_bound(int lay, int m_ext)
{
  static int jsb_table[3][4] =  { { 4, 8, 12, 16 }, { 4, 8, 12, 16},
    { 0, 4, 8, 16} };  /* lay+m_e -> jsbound */

  if(lay<1 || lay >3 || m_ext<0 || m_ext>3) {
    fprintf(stderr, "js_bound bad layer/modext (%d/%d)\n", lay, m_ext);
    exit(1);
  }
  return(jsb_table[lay-1][m_ext]);
}

/*
 * Interpret data in hdr str to fields in fr_ps
 */
static void hdr_to_frps(
    frame_params *fr_ps)
{
  layer *hdr = &fr_ps->header;         /* (or pass in as arg?) */

  fr_ps->actual_mode = hdr->mode;
  fr_ps->stereo = (hdr->mode == MPG_MD_MONO) ? 1 : 2;
  if (hdr->lay == 2)
    fr_ps->sblimit = pick_table(fr_ps);
  else
    fr_ps->sblimit = SBLIMIT;
  if (hdr->mode == MPG_MD_JOINT_STEREO)
    fr_ps->jsbound = js_bound(hdr->lay, hdr->mode_ext);
  else
    fr_ps->jsbound = fr_ps->sblimit;
  /* alloc, tab_num set in pick_table */
}

/*
   static void WriteHdr(frame_params *fr_ps, FILE *s)
   {
   layer *info = &fr_ps->header;

   fprintf(s,
   "hdr: s=FFF, id=%X, l=%X, ep=%s, br=%X, sf=%X, pd=%X, ",
   info->version, info->lay,
   ((info->error_protection) ? "on" : "off"),
   info->bitrate_index, info->sampling_frequency, info->padding);
   fprintf(s, "pr=%X, m=%X, js=%X, c=%X,\n",
   info->extension, info->mode, info->mode_ext, info->copyright);
   fprintf(s, "     o=%X, e=%X, alg=%s, layer=%s, tot bitrate=%d, sfrq=%.2f\n",
   info->original, info->emphasis, version_names[info->version],
   layer_names[info->lay-1],
   bitrate[info->version][info->lay-1][info->bitrate_index],
   s_freq[info->version][info->sampling_frequency]);
   fprintf(s, "     mode=%s, sblim=%d, jsbd=%d, ch=%d\n",
   mode_names[info->mode], fr_ps->sblimit, fr_ps->jsbound, fr_ps->stereo);
   fflush(s);
   }


   static void WriteBitAlloc(unsigned int bit_alloc[2][SBLIMIT],
   frame_params *f_p, FILE *s)
   {
   int i,j;
   int st = f_p->stereo;
   int sbl = f_p->sblimit;
   int jsb = f_p->jsbound;

   fprintf(s, "BITA ");
   for(i=0; i<sbl; ++i) {
   if(i == jsb) fprintf(s,"-");
   for(j=0; j<st; ++j)
   fprintf(s, "%1x", bit_alloc[j][i]);
   }
   fprintf(s, "\n");   fflush(s);
   }


   static void WriteScale(unsigned int bit_alloc[2][SBLIMIT],
   unsigned int scfsi[2][SBLIMIT], unsigned int scalar[2][3][SBLIMIT],
   frame_params *fr_ps, FILE *s)
   {
   int stereo  = fr_ps->stereo;
   int sblimit = fr_ps->sblimit;
   int lay     = fr_ps->header.lay;
   int i, j, k;

   if (lay == 2) {
   fprintf(s, "SFSI ");
   for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
   if (bit_alloc[k][i])  fprintf(s,"%d",scfsi[k][i]);
   fprintf(s, "\nSCFs ");
   for (k=0;k<stereo;k++) {
   for (i=0;i<sblimit;i++)
   if (bit_alloc[k][i])
   switch (scfsi[k][i]) {
   case 0: for (j=0;j<3;j++)
   fprintf(s,"%2d%c",scalar[k][j][i],
   (j==2)?';':'-');
   break;
   case 1:
   case 3: fprintf(s,"%2d-",scalar[k][0][i]);
   fprintf(s,"%2d;",scalar[k][2][i]);
   break;
   case 2: fprintf(s,"%2d;",scalar[k][0][i]);
   }
   fprintf(s, "\n");
   }
}
else {   // lay == 1 
  fprintf(s, "SCFs ");
  for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
    if (bit_alloc[k][i])  fprintf(s,"%2d;",scalar[k][0][i]);
  fprintf(s, "\n");
}
}


static void WriteSamples(int ch, unsigned int FAR sample[SBLIMIT],
    unsigned int bit_alloc[SBLIMIT], frame_params *fr_ps, FILE *s)
{
  int i;
  int stereo = fr_ps->stereo;
  int sblimit = fr_ps->sblimit;

  fprintf(s, "SMPL ");
  for (i=0;i<sblimit;i++)
    if ( bit_alloc[i] != 0)
      fprintf(s, "%d:", sample[i]);
  if (ch==(stereo-1) )    fprintf(s, "\n");
  else                    fprintf(s, "\t");
}


static int NumericQ(char *s) //  see if a string lookd like a numeric argument 
{
  char    c;

  while( (c = *s++)!='\0' && isspace((int)c)) // strip leading ws 
    ;
  if( c == '+' || c == '-' )
    c = *s++;               // perhaps skip leading + or - 
  return isdigit((int)c);
}


static int BitrateIndex(       // convert bitrate in kbps to index 
    int ver,            // 1 or 2
    int layr,
    int bRate)          // legal rates from 32 to 448 
{
  int     index = 0;
  int     found = 0;

  while(!found && index<15)   {
    if(bitrate[ver][layr-1][index] == bRate)
      found = 1;
    else
      ++index;
  }
  if(found)
    return(index);
  else {
    fprintf(stderr, "BitrateIndex: %d (layer %d) is not a legal bitrate\n",
        bRate, layr);
    return(-1);     // Error!
  }
}


static int SmpFrqIndex(    // convert samp frq in Hz to index
    long sRate,     // legal rates 16000, 22050, 24000, 32000, 44100, 48000
    int  *version)
{
  if (sRate == 44100L) {
    *version = MPEG_AUDIO_ID; return(0);
  }
  else if (sRate == 48000L) {
    *version = MPEG_AUDIO_ID; return(1);
  }
  else if (sRate == 32000L) {
    *version = MPEG_AUDIO_ID; return(2);
  }
  else if (sRate == 24000L) {
    *version = MPEG_PHASE2_LSF; return(1);
  }
  else if (sRate == 22050L) {
    *version = MPEG_PHASE2_LSF; return(0);
  }
  else if (sRate == 16000L) {
    *version = MPEG_PHASE2_LSF; return(2);
  }
  else {
    fprintf(stderr, "SmpFrqIndex: %ld is not a legal sample rate\n", sRate);
    return(-1);      // Error! 
  }
}
*/

/*****************************************************************************
 *
 *  Routines to determine byte order and swap bytes
 *
 *****************************************************************************/

/*
   enum byte_order NativeByteOrder = order_unknown;

   static enum byte_order DetermineByteOrder()
   {
   char s[ sizeof(long) + 1 ];
   union
   {
   long longval;
   char charval[ sizeof(long) ];
   } probe;
   probe.longval = 0x41424344L;  // ABCD in ASCII
   strncpy( s, probe.charval, sizeof(long) );
   s[ sizeof(long) ] = '\0';
// fprintf( stderr, "byte order is %s\n", s );
if ( strcmp(s, "ABCD") == 0 )
return order_bigEndian;
else
if ( strcmp(s, "DCBA") == 0 )
return order_littleEndian;
else
return order_unknown;
}

static void SwapBytesInWords(short *loc, int words)
{
int            i;
unsigned char *src = (unsigned char *)loc;
unsigned char  tmp;

for (i = 0; i < words; i++) {
tmp = src[0];
src[0] = src[1];
src[1] = tmp;
src += 2;
}
}
*/

/*****************************************************************************
 *
 *  bit_stream.c package
 *  Author:  Jean-Georges Fritsch, C-Cube Microsystems
 *
 *****************************************************************************/

/********************************************************************
  This package provides functions to write (exclusive or read)
  information from (exclusive or to) the bit stream.

  If the bit stream is opened in read mode only the get functions are
  available. If the bit stream is opened in write mode only the put
  functions are available.
 ********************************************************************/

/*open_bit_stream_w(); open the device to write the bit stream into it    */
/*open_bit_stream_r(); open the device to read the bit stream from it     */
/*close_bit_stream();  close the device containing the bit stream         */
/*back_track_buffer();     goes back N bits in the buffer                 */
/*unsigned int get1bit();  read 1 bit from the bit stream                 */
/*unsigned long getbits(); read N bits from the bit stream                */
/*unsigned long byte_ali_getbits();   read the next byte aligned N bits from*/
/*                                    the bit stream                        */
/*unsigned long look_ahead(); grep the next N bits in the bit stream without*/
/*                            changing the buffer pointer                   */
/*put1bit(); write 1 bit from the bit stream  */
/*put1bit(); write 1 bit from the bit stream  */
/*putbits(); write N bits from the bit stream */
/*byte_ali_putbits(); write byte aligned the next N bits into the bit stream*/
/*unsigned long sstell(); return the current bit stream length (in bits)    */
/*int end_bs(); return 1 if the end of bit stream reached otherwise 0       */
/*int seek_sync(); return 1 if a sync word was found in the bit stream      */
/*                 otherwise returns 0                                      */

/* refill the buffer from the input device when the buffer becomes empty    */

static void refill_buffer(Bit_stream_struc *bs)        /* bit stream structure */
{
  int                 i = bs->buf_size - 2 - bs->buf_byte_idx;
  unsigned long       n = 1;
  int                 index = 0;
  char                val[2];

#ifdef OPTIMIZE

#   define RBUFSIZE             8192
  static unsigned char        readbuf[RBUFSIZE];

  if (bs->format == BINARY) {

    while (i >= 0 && (!bs->eob)) {
      int j;

      /* Try to read many bytes in each call to fread()*/
      if (i > RBUFSIZE)
        n = fread(readbuf, sizeof(unsigned char), RBUFSIZE, bs->pt);
      else
        n = fread(readbuf, sizeof(unsigned char), i + 1, bs->pt);

      /* Copy the read buffer*/
      for (j = 0; i >= 0 && j < n; j++)
        bs->buf[i--] = readbuf[j];

      if (n == 0 && feof(bs->pt))
        bs->eob = i + 1;        /* eof*/
    }

  } else {
    while ((i>=0) && (!bs->eob)) {
      while((index < 2) && n) {
        n = fread(&val[index], sizeof(char), 1, bs->pt);
        switch (val[index]) {
          case 0x30:
          case 0x31:
          case 0x32:
          case 0x33:
          case 0x34:
          case 0x35:
          case 0x36:
          case 0x37:
          case 0x38:
          case 0x39:
          case 0x41:
          case 0x42:
          case 0x43:
          case 0x44:
          case 0x45:
          case 0x46:
            index++;
            break;
          default:
            break;
        }
      }

      if (val[0] <= 0x39)
        bs->buf[i] = (val[0] - 0x30) << 4;
      else
        bs->buf[i] = (val[0] - 0x37) << 4;

      if (val[1] <= 0x39)
        bs->buf[i--] |= (val[1] - 0x30);
      else
        bs->buf[i--] |= (val[1] - 0x37);
      index = 0;

      if (!n)
        bs->eob= i+1;
    }
  }

#else
  /* Original code*/

  while ((i>=0) && (!bs->eob)) {
    if (bs->format == BINARY)
      n = fread(&bs->buf[i--], sizeof(unsigned char), 1, bs->pt);
    else {
      while((index < 2) && n) {
        n = fread(&val[index], sizeof(char), 1, bs->pt);
        switch (val[index]) {
          case 0x30:
          case 0x31:
          case 0x32:
          case 0x33:
          case 0x34:
          case 0x35:
          case 0x36:
          case 0x37:
          case 0x38:
          case 0x39:
          case 0x41:
          case 0x42:
          case 0x43:
          case 0x44:
          case 0x45:
          case 0x46:
            index++;
            break;
          default:
            break;
        }
      }

      if (val[0] <= 0x39)
        bs->buf[i] = (val[0] - 0x30) << 4;
      else
        bs->buf[i] = (val[0] - 0x37) << 4;

      if (val[1] <= 0x39)
        bs->buf[i--] |= (val[1] - 0x30);
      else
        bs->buf[i--] |= (val[1] - 0x37);
      index = 0;
    }
    if (!n)
      bs->eob= i+1;
  }
#endif /* OPTIMIZE*/
}

#if BS_FORMAT != BINARY
//static char *he = "0123456789ABCDEF";
#endif

/*
 * Empty the buffer to the output device when the buffer becomes full
 */
/*
   static void empty_buffer(
   Bit_stream_struc *bs,   // bit stream structure
   int minimum)            // end of the buffer to empty
   {
   int i;

#if BS_FORMAT == BINARY
for (i=bs->buf_size-1;i>=minimum;i--)
fwrite(&bs->buf[i], sizeof(unsigned char), 1, bs->pt);
#else
for (i=bs->buf_size-1;i>=minimum;i--) {
char val[2];
val[0] = he[((bs->buf[i] >> 4) & 0x0F)];
val[1] = he[(bs->buf[i] & 0x0F)];
fwrite(val, sizeof(char), 2, bs->pt);
}
#endif

for (i=minimum-1; i>=0; i--)
bs->buf[bs->buf_size - minimum + i] = bs->buf[i];

bs->buf_byte_idx = bs->buf_size -1 - minimum;
bs->buf_bit_idx = 8;
}
*/

/*
 * Open the device to write the bit stream into it
 */
/*
   static void open_bit_stream_w(
   Bit_stream_struc *bs,   // bit stream structure
   char *bs_filenam,       // name of the bit stream file
   int size)               // size of the buffer
   {
   if ((bs->pt = fopen(bs_filenam, "wb")) == NULL) {
   fprintf(stderr, "Could not create \"%s\"\n", bs_filenam);
   exit(1);
   }
//alloc_buffer(bs, size);
bs->buf_size = size;
bs->buf_byte_idx = size-1;
bs->buf_bit_idx=8;
bs->totbit=0;
bs->mode = WRITE_MODE;
bs->eob = FALSE;
bs->eobs = FALSE;
}
*/

/*
 * Open the device to read the bit stream from it
 */
static void open_bit_stream_r(
    Bit_stream_struc *bs,   /* bit stream structure */
    char *bs_filenam,       /* name of the bit stream file */
    int size)               /* size of the buffer */
{
  unsigned long       n=0;
  unsigned char       flag = 1;
  unsigned char       val;
  unsigned char       ungetBuf[10]; /* max # chars we can ungetc()*/
  int                 nungetc;

  if (strcmp(bs_filenam, "-") == 0) {
    /* Read stdin*/
    //        if ((bs->pt = fdopen(0, "rb")) == NULL) {
    //            fprintf(stderr, "%s: could not open stdin\n", $starSymbol(programName));
    //            exit(1);
    //        }
  } else {
    /* Read a file*/
    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
      fprintf(stderr, "%s: could not find \"%s\"\n",
          programName, bs_filenam);
      exit(1);
    }
  }

  nungetc = 0;
  do {
    //        n = fread(&val, sizeof(unsigned char), 1, bs->pt);
    //        n = read_port($ref(input), &val, sizeof(unsigned char));
    val = 0xff;	
    n = fread(&val, sizeof(unsigned char), 1, bs->pt);
    ungetBuf[nungetc++] = val;      /* save for pushback to stream*/

    switch (val) {
      case 0x30:
      case 0x31:
      case 0x32:
      case 0x33:
      case 0x34:
      case 0x35:
      case 0x36:
      case 0x37:
      case 0x38:
      case 0x39:
      case 0x41:
      case 0x42:
      case 0x43:
      case 0x44:
      case 0x45:
      case 0x46:
      case 0xa:  /* \n */
      case 0xd:  /* cr */
      case 0x1a:  /* sub */
        break;
      default: /* detection of an binary character */
        flag--;
        break;
    }
  } while ((flag & n) && nungetc < 10);

  if (flag) {
    if (Arguments.verbose)
      fprintf(stderr, "The bit stream file %s is an ascii file\n", bs_filenam);
    bs->format = ASCII;
  } else {
    if (Arguments.verbose) {
      if (strcmp(bs_filenam, "-") == 0)
        fprintf(stderr, "The input bit stream is binary\n");
      else
        fprintf(stderr, "The bit stream file \"%s\" is a binary file\n",
            bs_filenam);
    }
    bs->format = BINARY;
  }

  if (strcmp(bs_filenam, "-") == 0) {
    /* Cannot rewind a pipe, push back character instead.*/
    /* Only four bytes are actually guaranteed to ungetc().*/
    //        while (nungetc > 0)
    //            ungetc(ungetBuf[--nungetc], bs->pt);

  } else {
    fclose(bs->pt);
    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
      fprintf(stderr, "%s: could not find \"%s\"\n",
          programName, bs_filenam);
      exit(1);
    }
  }

  // Hyunok Oh
  //alloc_buffer(bs, size);
  bs->buf_size = size;
  bs->buf_byte_idx=0;
  bs->buf_bit_idx=0;
  bs->totbit=0;
  bs->mode = READ_MODE;
  bs->eob = FALSE;
  bs->eobs = FALSE;
}

/* Close the device containing the bit stream after a read process*/
static void close_bit_stream_r(Bit_stream_struc *bs)   /* bit stream structure */
{
  //   fclose(bs->pt);
  // Hyunok Oh
  //desalloc_buffer(bs);
}

/* Close the device containing the bit stream after a write process*/
/*
   static void close_bit_stream_w(Bit_stream_struc *bs)   // bit stream structure
   {
// oho
// empty_buffer(bs, bs->buf_byte_idx);
fclose(bs->pt);
// desalloc_buffer(bs);
}
*/

int putmask[9] = {0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
int clearmask[9] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0};
/*
   static void back_track_buffer(     // goes back N bits in the buffer
   Bit_stream_struc *bs,   // bit stream structure 
   int N)
   {
   int  tmp = N - (N/8)*8;
   int  i;

   bs->totbit -= N;
   for (i=bs->buf_byte_idx;i< bs->buf_byte_idx+N/8-1;i++) bs->buf[i] = 0;
   bs->buf_byte_idx += N/8;
   if ( (tmp + bs->buf_bit_idx) <= 8) {
   bs->buf_bit_idx += tmp;
   }
   else {
   bs->buf_byte_idx ++;
   bs->buf_bit_idx += (tmp - 8);
   }
   bs->buf[bs->buf_byte_idx] &= clearmask[bs->buf_bit_idx];
   }
   */

int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};

/*
 * Read 1 bit from the bit stream
 */
static unsigned int get1bit(Bit_stream_struc *bs)   /* bit stream structure */
{
  unsigned int bit;
  int          i;

  bs->totbit++;

  if (!bs->buf_bit_idx) {
    bs->buf_bit_idx = 8;
    bs->buf_byte_idx--;
    if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
      if (bs->eob)
        bs->eobs = TRUE;
      else {
        for (i = bs->buf_byte_idx; i >= 0; i--)
          bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
        refill_buffer(bs);
        bs->buf_byte_idx = bs->buf_size-1;
      }
    }
  }
  bit = bs->buf[bs->buf_byte_idx] & mask[bs->buf_bit_idx-1];
  bit = bit >> (bs->buf_bit_idx-1);
  bs->buf_bit_idx--;

  return bit;
}

/*
 * Write 1 bit from the bit stream
 */
/*
   static void put1bit(
   Bit_stream_struc *bs,   // bit stream structure
   int bit)                // bit to write into the buffer
   {
   bs->totbit++;

   bs->buf[bs->buf_byte_idx] |= (bit&0x1) << (bs->buf_bit_idx-1);
   bs->buf_bit_idx--;
   if (!bs->buf_bit_idx) {
   bs->buf_bit_idx = 8;
   bs->buf_byte_idx--;
   if (bs->buf_byte_idx < 0)
   empty_buffer(bs, MINIMUM);
   bs->buf[bs->buf_byte_idx] = 0;
   }
   }
   */
/*
 * Look ahead for the next N bits from the bit stream
 */
/*
   static unsigned long look_ahead(
   Bit_stream_struc    *bs,    // bit stream structure
   int                  N)     // number of bits to read from the bit stream
   {
   unsigned long       val = 0;
   int                 j = N;
   int                 k, tmp;
   int                 bit_idx = bs->buf_bit_idx;
   int                 byte_idx = bs->buf_byte_idx;

#ifndef OPTIMIZE
if (N > MAX_LENGTH)
fprintf(stderr, "Cannot read or write more than %d bits at a time.\n",
MAX_LENGTH);
#endif

while (j > 0) {
if (!bit_idx) {
bit_idx = 8;
byte_idx--;
}
k = MIN(j, bit_idx);
tmp = bs->buf[byte_idx]&putmask[bit_idx];
tmp = tmp >> (bit_idx-k);
val |= tmp << (j-k);
bit_idx -= k;
j -= k;
}
return val;
}
*/
/*
 * Read N bit from the bit stream
 */
static unsigned long getbits(
    Bit_stream_struc    *bs,    /* bit stream structure */
    int                  N)     /* number of bits to read from the bit stream */
{
  unsigned long       val = 0;
  int                 i;
  int                 j = N;
  int                 k;
#ifndef OPTIMIZE
  int                 tmp;

  if (N > MAX_LENGTH)
    fprintf(stderr, "Cannot read/write more than %d bits at a time\n", MAX_LENGTH);
#endif

  bs->totbit += N;
  while (j > 0) {
    if (!bs->buf_bit_idx) {
      bs->buf_bit_idx = 8;
      bs->buf_byte_idx--;
      if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
        if (bs->eob)
          bs->eobs = TRUE;
        else {
          for (i=bs->buf_byte_idx; i>=0;i--)
            bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
          refill_buffer(bs);
          bs->buf_byte_idx = bs->buf_size-1;
        }
      }
    }
    k = MIN(j, bs->buf_bit_idx);
#ifdef OPTIMIZE
    val |= ((int)(bs->buf[bs->buf_byte_idx] & putmask[bs->buf_bit_idx]) >>
        (bs->buf_bit_idx - k)) << (j - k);
#else
    tmp = bs->buf[bs->buf_byte_idx] & putmask[bs->buf_bit_idx];
    tmp = tmp >> (bs->buf_bit_idx-k);
    val |= tmp << (j-k);
#endif
    bs->buf_bit_idx -= k;
    j -= k;
  }
  return val;
}

/* Write N bits into the bit stream */
/*
   static void putbits(
   Bit_stream_struc *bs,   // bit stream structure
   unsigned int val,       // val to write into the buffer
   int N)                  // number of bits of val
   {
   int    j = N;
   int    k, tmp;

   if (N > MAX_LENGTH)
   fprintf(stderr, "Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);

   bs->totbit += N;
   while (j > 0) {
   k = MIN(j, bs->buf_bit_idx);
   tmp = val >> (j-k);
   bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
   bs->buf_bit_idx -= k;
   if (!bs->buf_bit_idx) {
   bs->buf_bit_idx = 8;
   bs->buf_byte_idx--;
   if (bs->buf_byte_idx < 0)
   empty_buffer(bs, MINIMUM);
   bs->buf[bs->buf_byte_idx] = 0;
   }
   j -= k;
   }
   }
   */

/* Return the current bit stream length (in bits)*/
static unsigned long sstell(Bit_stream_struc *bs)   /* bit stream structure */
{
  return(bs->totbit);
}

/* Write N bits byte aligned into the bit stream */
/*
   static void byte_ali_putbits(
   Bit_stream_struc *bs,   // bit stream structure
   unsigned int val,       // val to write into the buffer
   int N)                  // number of bits of val
   {
   unsigned long aligning;

   if (N > MAX_LENGTH)
   fprintf(stderr, "Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
   aligning = sstell(bs)%8;
   if (aligning)
   putbits(bs, (unsigned int)0, (int)(8-aligning));

   putbits(bs, val, N);
   }

// Read the next bute aligned N bits from the bit stream
static unsigned long byte_ali_getbits(
Bit_stream_struc *bs,   // bit stream structure
int N)                  // number of bits of val
{
unsigned long aligning;

if (N > MAX_LENGTH)
fprintf(stderr, "Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
aligning = sstell(bs)%8;
if (aligning)
getbits(bs, (int)(8-aligning));

return(getbits(bs, N));
}
*/

/* Return the status of the bit stream */
/* returns 1 if end of bit stream was reached */
/* returns 0 if end of bit stream was not reached */
static int end_bs(Bit_stream_struc *bs)   /* bit stream structure */
{
  return(bs->eobs);
}


/*
 * This function seeks for a byte aligned sync word in the bit stream and
 * places the bit stream pointer right after the sync.
 * This function returns 1 if the sync was found otherwise it returns 0
 */
static int seek_sync(
    Bit_stream_struc    *bs,    /* bit stream structure */
    long                 sync,  /* sync word maximum 32 bits */
    int                  N)     /* sync word length */
{
  unsigned long aligning;
  unsigned long val;
#ifdef OPTIMIZE
  /* main() *always* calls this routine with N = SYNC_WORD_LNGTH = 12*/
  /* This is really easy to optimize :-)*/
  long maxi = 4095;   /*(long)pow(2.0, (float)N) - 1;*/

  aligning = bs->totbit & (ALIGNING - 1);     /* ALIGNING equals 8*/
  if (aligning)
    getbits(bs, ALIGNING-aligning);
#else
  long maxi = (long)pow(2.0, (float)N) - 1;

  aligning = sstell(bs)%ALIGNING;
  if (aligning)
    getbits(bs, (int)(ALIGNING-aligning));
#endif

  val = getbits(bs, N);
  while (((val & maxi) != sync) && (!end_bs(bs))) {
    val <<= ALIGNING;
    val |= getbits(bs, ALIGNING);
  }

  if (end_bs(bs))
    return 0;
  else
    return 1;
}

/*****************************************************************************
 *
 *  End of bit_stream.c package
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  CRC error protection package
 *
 *****************************************************************************/
static void buffer_CRC(Bit_stream_struc *bs, unsigned int *old_crc)
{   
  *old_crc = getbits(bs, 16);
}   
/*
   static void update_CRC(unsigned int data, unsigned int length, unsigned int *crc)
   {
   unsigned int  masking, carry;

   masking = 1 << length;

   while((masking >>= 1)) {
   carry = *crc & 0x8000;
 *crc <<= 1;
 if (!carry ^ !(data & masking))
 *crc ^= CRC16_POLYNOMIAL;
 }
 *crc &= 0xffff;
 }

 static void I_CRC_calc(
 frame_params *fr_ps,
 unsigned int bit_alloc[2][SBLIMIT],
 unsigned int *crc)
 {
 int i, k;
 layer *info = &fr_ps->header;
 int stereo  = fr_ps->stereo;
 int jsbound = fr_ps->jsbound;

 *crc = 0xffff; // changed from '0' 92-08-11 shn
 update_CRC(info->bitrate_index, 4, crc);
 update_CRC(info->sampling_frequency, 2, crc);
 update_CRC(info->padding, 1, crc);
 update_CRC(info->extension, 1, crc);
 update_CRC(info->mode, 2, crc);
 update_CRC(info->mode_ext, 2, crc);
 update_CRC(info->copyright, 1, crc);
 update_CRC(info->original, 1, crc);
 update_CRC(info->emphasis, 2, crc);

 for (i=0;i<SBLIMIT;i++)
 for (k=0;k<((i<jsbound)?stereo:1);k++)
 update_CRC(bit_alloc[k][i], 4, crc);
 }

 static void II_CRC_calc(
 frame_params        *fr_ps,
 unsigned int         bit_alloc[2][SBLIMIT],
 unsigned int         scfsi[2][SBLIMIT],
 unsigned int        *crc)
 {
 int          i, k;
 layer       *info = &fr_ps->header;
 int          stereo  = fr_ps->stereo;
 int          sblimit = fr_ps->sblimit;
 int          jsbound = fr_ps->jsbound;
 al_table    *alloc = &fr_ps->alloc;
#ifdef OPTIMIZE
unsigned int lcrc = 0xffff;

update_CRC(info->bitrate_index, 4, &lcrc);
update_CRC(info->sampling_frequency, 2, &lcrc);
update_CRC(info->padding, 1, &lcrc);
update_CRC(info->extension, 1, &lcrc);
update_CRC(info->mode, 2, &lcrc);
update_CRC(info->mode_ext, 2, &lcrc);
update_CRC(info->copyright, 1, &lcrc);
update_CRC(info->original, 1, &lcrc);
update_CRC(info->emphasis, 2, &lcrc);

// Combine loops into one
for (i = 0; i < sblimit; i++)
for (k = 0; k < stereo; k++) {
if (bit_alloc[k][i])
update_CRC(scfsi[k][i], 2, &lcrc);
if (i < jsbound || k == 0)
  update_CRC(bit_alloc[k][i], (*alloc)[i][0].bits, &lcrc);
  }
*crc = lcrc;        // update once

#else
// Original code

*crc = 0xffff;              // changed from '0' 92-08-11 shn
update_CRC(info->bitrate_index, 4, crc);
update_CRC(info->sampling_frequency, 2, crc);
update_CRC(info->padding, 1, crc);
update_CRC(info->extension, 1, crc);
update_CRC(info->mode, 2, crc);
update_CRC(info->mode_ext, 2, crc);
update_CRC(info->copyright, 1, crc);
update_CRC(info->original, 1, crc);
update_CRC(info->emphasis, 2, crc);

for (i = 0; i < sblimit; i++)
for (k = 0; k < ((i < jsbound) ? stereo : 1); k++)
update_CRC(bit_alloc[k][i], (*alloc)[i][0].bits, crc);

for (i = 0; i < sblimit; i++)
  for (k = 0; k < stereo; k++)
if (bit_alloc[k][i])
  update_CRC(scfsi[k][i], 2, crc);
#endif // OPTIMIZE
  }
*/

/*****************************************************************************
 *
 *  End of CRC error protection package
 *
 *****************************************************************************/

/************************* Layer III routines **********************/

static void III_get_side_info(
    Bit_stream_struc *bs,
    III_side_info_t *si,
    frame_params *fr_ps)
{
  int  ch, gr, i;
  int  stereo = fr_ps->stereo;

  if (fr_ps->header.version != MPEG_PHASE2_LSF) {
    si->main_data_begin = getbits(bs, 9);
    if (stereo == 1)
      si->private_bits = getbits(bs,5);
    else
      si->private_bits = getbits(bs,3);

    for (ch = 0; ch < stereo; ch++)
      for (i = 0; i < 4; i++)
        si->ch[ch].scfsi[i] = get1bit(bs);

    for (gr = 0; gr < 2 ; gr++) {
      for (ch = 0; ch < stereo; ch++) {
        si->ch[ch].gr[gr].part2_3_length = getbits(bs, 12);
        si->ch[ch].gr[gr].big_values = getbits(bs, 9);
        si->ch[ch].gr[gr].global_gain = getbits(bs, 8);
        si->ch[ch].gr[gr].scalefac_compress = getbits(bs, 4);
        si->ch[ch].gr[gr].window_switching_flag = get1bit(bs);
        if (si->ch[ch].gr[gr].window_switching_flag) {
          si->ch[ch].gr[gr].block_type = getbits(bs, 2);
          si->ch[ch].gr[gr].mixed_block_flag = get1bit(bs);
          for (i = 0; i < 2; i++)
            si->ch[ch].gr[gr].table_select[i] = getbits(bs, 5);
          for (i = 0; i < 3; i++)
            si->ch[ch].gr[gr].subblock_gain[i] = getbits(bs, 3);
          /*
           * Set region_count parameters since they are
           * implicit in this case.
           */
          if (si->ch[ch].gr[gr].block_type == 0) {
            fprintf(stderr, "Side info bad: block_type 0 in split block\n");
            exit(0);
          } else if (si->ch[ch].gr[gr].block_type == 2
              && si->ch[ch].gr[gr].mixed_block_flag == 0)
            si->ch[ch].gr[gr].region0_count = 8; /* MI 9; */
          else
            si->ch[ch].gr[gr].region0_count = 7; /* MI 8; */
          si->ch[ch].gr[gr].region1_count =
            20 - si->ch[ch].gr[gr].region0_count;
        } else {
          for (i = 0; i < 3; i++)
            si->ch[ch].gr[gr].table_select[i] = getbits(bs, 5);
          si->ch[ch].gr[gr].region0_count = getbits(bs, 4);
          si->ch[ch].gr[gr].region1_count = getbits(bs, 3);
          si->ch[ch].gr[gr].block_type = 0;
        }
        si->ch[ch].gr[gr].preflag = get1bit(bs);
        si->ch[ch].gr[gr].scalefac_scale = get1bit(bs);
        si->ch[ch].gr[gr].count1table_select = get1bit(bs);
      }
    }

  } else {    /* Layer 3 LSF */

    si->main_data_begin = getbits(bs, 8);
    if (stereo == 1)
      si->private_bits = getbits(bs,1);
    else
      si->private_bits = getbits(bs,2);

    for (gr = 0; gr < 1 ; gr++) {
      for (ch = 0; ch < stereo; ch++) {
        si->ch[ch].gr[gr].part2_3_length = getbits(bs, 12);
        si->ch[ch].gr[gr].big_values = getbits(bs, 9);
        si->ch[ch].gr[gr].global_gain = getbits(bs, 8);
        si->ch[ch].gr[gr].scalefac_compress = getbits(bs, 9);
        si->ch[ch].gr[gr].window_switching_flag = get1bit(bs);
        if (si->ch[ch].gr[gr].window_switching_flag) {
          si->ch[ch].gr[gr].block_type = getbits(bs, 2);
          si->ch[ch].gr[gr].mixed_block_flag = get1bit(bs);
          for (i = 0; i < 2; i++)
            si->ch[ch].gr[gr].table_select[i] = getbits(bs, 5);
          for (i = 0; i < 3; i++)
            si->ch[ch].gr[gr].subblock_gain[i] = getbits(bs, 3);
          /*
           * Set region_count parameters since they are
           * implicit in this case.
           */
          if (si->ch[ch].gr[gr].block_type == 0) {
            fprintf(stderr, "Side info bad: block_type 0 in split block\n");
            exit(0);
          } else if (si->ch[ch].gr[gr].block_type == 2
              && si->ch[ch].gr[gr].mixed_block_flag == 0)
            si->ch[ch].gr[gr].region0_count = 8; /* MI 9; */
          else
            si->ch[ch].gr[gr].region0_count = 7; /* MI 8; */
          si->ch[ch].gr[gr].region1_count =
            20 - si->ch[ch].gr[gr].region0_count;
        } else {
          for (i = 0; i < 3; i++)
            si->ch[ch].gr[gr].table_select[i] = getbits(bs, 5);
          si->ch[ch].gr[gr].region0_count = getbits(bs, 4);
          si->ch[ch].gr[gr].region1_count = getbits(bs, 3);
          si->ch[ch].gr[gr].block_type = 0;
        }

        si->ch[ch].gr[gr].scalefac_scale = get1bit(bs);
        si->ch[ch].gr[gr].count1table_select = get1bit(bs);
      }
    }
  }
}



#ifdef  MACINTOSH
/*****************************************************************************
 *
 *  Set Macintosh file attributes.
 *
 *****************************************************************************/

static void    set_mac_file_attr(fileName, vRefNum, creator, fileType)
  char    fileName[MAX_NAME_SIZE];
  short   vRefNum;
  OsType  creator;
  OsType  fileType;
{

  short   theFile;
  char    pascal_fileName[MAX_NAME_SIZE];
  FInfo   fndrInfo;

  CtoPstr(strcpy(pascal_fileName, fileName));

  FSOpen(pascal_fileName, vRefNum, &theFile);
  GetFInfo(pascal_fileName, vRefNum, &fndrInfo);
  fndrInfo.fdCreator = creator;
  fndrInfo.fdType = fileType;
  SetFInfo(pascal_fileName, vRefNum, &fndrInfo);
  FSClose(theFile);

}
#endif /* MACINTOSH*/


#ifdef MS_DOS
/* ------------------------------------------------------------------------
   new_ext()
   Puts a new extension name on a file name <filename>.
   Removes the last extension name, if any.
   1992-08-19, 1995-06-12 shn
   ------------------------------------------------------------------------ */
static char *new_ext(char *filename, char *extname)
{
  int found, dotpos;
  static char newname[80];

  /* First, strip the extension */
  dotpos=strlen(filename); found=0;
  do
  {
    switch (filename[dotpos])
    {
      case '.' : found=1; break;
      case '\\':                  /* used by MS-DOS */
      case '/' :                  /* used by UNIX */
      case ':' : found=-1; break; /* used by MS-DOS in drive designation */
      default  : dotpos--; if (dotpos<0) found=-1; break;
    }
  } while (found==0);
  if (found==-1) strcpy(newname,filename);
  if (found== 1) strncpy(newname,filename,dotpos); newname[dotpos]='\0';
  strcat(newname,extname);
  return(newname);
}
#endif /* MS_DOS*/

#define BUFSIZE 4096
/* Assembly routines require these to be global*/
unsigned long offset,totbit=0, buf_byte_idx=0;
unsigned int buf[BUFSIZE];
unsigned int buf_bit_idx=8;

/* Return the current bit stream length (in bits) */
static unsigned long hsstell()
{
  return(totbit);
}

/*
 * read N bit from the bit stream
 */
static unsigned long hgetbits(int N)  /* number of bits to read from the bit stream */
{
  unsigned long       val = 0;
  int                 j = N;
  int                 k;

#ifndef OPTIMIZE
  int                 tmp;
#endif

  /*
   * if (N > MAX_LENGTH)
   *  fprintf(stderr, "Cannot read or write more than %d bits at a time.\n",
   *                  MAX_LENGTH);
   */
  totbit += N;
  while (j > 0) {
    if (!buf_bit_idx) {
      buf_bit_idx = 8;
      buf_byte_idx++;
      if (buf_byte_idx > offset) {
        fprintf(stderr, "Buffer overflow !!\n");exit(3);
      }
    }
    k = MIN(j, buf_bit_idx);
#ifdef OPTIMIZE
    val |= ((buf[buf_byte_idx & (BUFSIZE-1)] & putmask[buf_bit_idx]) >>
        (buf_bit_idx - k)) << (j - k);
#else
    tmp = buf[buf_byte_idx%BUFSIZE]&putmask[buf_bit_idx];
    tmp = tmp >> (buf_bit_idx-k);
    val |= tmp << (j-k);
#endif
    buf_bit_idx -= k;
    j -= k;
  }
  return(val);
}

static unsigned int hget1bit()
{
#ifdef OPTIMIZE
  unsigned int val;

  totbit++;
  if (buf_bit_idx == 0) {
    buf_bit_idx = 8;
    buf_byte_idx++;
    if (buf_byte_idx > offset) {
      fprintf(stderr, "Buffer overflow!!\n");
      exit(3);
    }
  }
  val = ((buf[buf_byte_idx & (BUFSIZE-1)] & putmask[buf_bit_idx]) >>
      (buf_bit_idx - 1));
  buf_bit_idx--;

  return(val);
#else
  return(hgetbits(1));
#endif
}


/* Write N bits into the bit stream */
static void hputbuf(
    unsigned int val,       /* val to write into the buffer */
    int N)                  /* number of bits of val */
{
  if (N != 8) { fprintf(stderr, "Not Supported yet!!\n"); exit(-3); }
  buf[offset % BUFSIZE] = val;
  offset++;
}

static void rewindNbits(int N)
{
  totbit -= N;
  buf_bit_idx += N;
  while( buf_bit_idx >= 8 )
  {  buf_bit_idx -= 8;
    buf_byte_idx--;
  }
}

static void rewindNbytes(int N)
{
  totbit -= N*8;
  buf_byte_idx -= N;
}

/* Return the number of slots for main data of current frame */

static int main_data_slots(frame_params fr_ps)
{
  int nSlots =
    (144 * bitrate[fr_ps.header.version][2][fr_ps.header.bitrate_index]) /
    s_freq[fr_ps.header.version][fr_ps.header.sampling_frequency];

  if (fr_ps.header.version != MPEG_PHASE2_LSF) {
    if (fr_ps.stereo == 1)
      nSlots -= 17;
    else
      nSlots -=32;
  } else {
    nSlots = nSlots / 2;
    if (fr_ps.stereo == 1)
      nSlots -= 9;
    else
      nSlots -=17;
  }

  if (fr_ps.header.padding)
    nSlots++;
  nSlots -= 4;
  if (fr_ps.header.error_protection)
    nSlots -= 2;

  return nSlots;
}

struct {
  int l[5];
  int s[3];} sfbtable = {{0, 6, 11, 16, 21},
    {0, 6, 12}};

int slen[2][16] = {{0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
  {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}};
struct  {
  int l[23];
  int s[14];} sfBandIndex[6] =
{{{0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
  {0,4,8,12,18,24,32,42,56,74,100,132,174,192}},
{{0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
  {0,4,8,12,18,26,36,48,62,80,104,136,180,192}},
{{0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
  {0,4,8,12,18,26,36,48,62,80,104,134,174,192}},

{{0,4,8,12,16,20,24,30,36,44,52,62,74,90,110,134,162,196,238,288,342,418,576},
  {0,4,8,12,16,22,30,40,52,66,84,106,136,192}},
{{0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576},
  {0,4,8,12,16,22,28,38,50,64,80,100,126,192}},
{{0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576},
  {0,4,8,12,16,22,30,42,58,78,104,138,180,192}}};


static void III_get_scale_factors(
    III_scalefac_t      *scalefac,
    III_side_info_t     *si,
    int                  gr,
    int                  ch,
    frame_params        *fr_ps)
{
  int                  sfb, i, window;
  gr_info_s    *gr_info = &(si->ch[ch].gr[gr]);

  if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {

    if (gr_info->mixed_block_flag) {        /* MIXED */ /* NEW - ag 11/25 */
      for (sfb = 0; sfb < 8; sfb++)
        (*scalefac)[ch].l[sfb] =
          hgetbits(slen[0][gr_info->scalefac_compress]);
      for (sfb = 3; sfb < 6; sfb++)
        for (window=0; window<3; window++)
          (*scalefac)[ch].s[window][sfb] =
            hgetbits(slen[0][gr_info->scalefac_compress]);
      for (sfb = 6; sfb < 12; sfb++)
        for (window=0; window<3; window++)
          (*scalefac)[ch].s[window][sfb] =
            hgetbits(slen[1][gr_info->scalefac_compress]);
      for (sfb=12,window=0; window<3; window++)
        (*scalefac)[ch].s[window][sfb] = 0;

    } else {                                /* SHORT*/

      for (i=0; i<2; i++)
        for (sfb = sfbtable.s[i]; sfb < sfbtable.s[i+1]; sfb++)
          for (window=0; window<3; window++)
            (*scalefac)[ch].s[window][sfb] =
              hgetbits(slen[i][gr_info->scalefac_compress]);
      for (sfb=12,window=0; window<3; window++)
        (*scalefac)[ch].s[window][sfb] = 0;
    }

  } else {   /* LONG types 0,1,3 */

    for (i=0; i<4; i++) {
      if ((si->ch[ch].scfsi[i] == 0) || (gr == 0))
        for (sfb = sfbtable.l[i]; sfb < sfbtable.l[i+1]; sfb++)
          (*scalefac)[ch].l[sfb] =
            hgetbits(slen[(i<2)?0:1][gr_info->scalefac_compress]);
    }
    (*scalefac)[ch].l[22] = 0;
  }
}

/****************** new MPEG2 stuf  ***********/

static unsigned nr_of_sfb_block[6][3][4] = {{{6, 5, 5, 5},{ 9, 9, 9, 9 },{6, 9, 9, 9}},
  {{6, 5, 7, 3},{ 9, 9, 12, 6},{6, 9, 12, 6}},
  {{11, 10, 0, 0},{ 18, 18, 0, 0},{15,18,0,0 }},
  {{7, 7, 7, 0},{ 12, 12, 12, 0},{6, 15, 12, 0}},
  {{6, 6, 6, 3},{12, 9, 9, 6},{6, 12, 9, 6}},
  {{8, 8, 5, 0},{15,12,9,0},{6,18,9,0}}};
static unsigned scalefac_buffer[54];

static void III_get_LSF_scale_data(
    III_scalefac_t *scalefac,
    III_side_info_t *si,
    int gr, int ch,
    frame_params *fr_ps)
{
  short i, j, k;
  short blocktypenumber, blocknumber = 0;

  gr_info_s *gr_info = &(si->ch[ch].gr[gr]);
  unsigned scalefac_comp, int_scalefac_comp, new_slen[4];

  layer *hdr = & fr_ps->header;
  scalefac_comp =  gr_info->scalefac_compress;

  blocktypenumber = 0;
  if ((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 0))
    blocktypenumber = 1;

  if ((gr_info->block_type == 2) && (gr_info->mixed_block_flag == 1))
    blocktypenumber = 2;

  if(!((( hdr->mode_ext == 1) || (hdr->mode_ext == 3)) && (ch == 1)))
  {
    if(scalefac_comp < 400)
    {
      new_slen[0] = (scalefac_comp >> 4) / 5 ;
      new_slen[1] = (scalefac_comp >> 4) % 5 ;
      new_slen[2] = (scalefac_comp % 16) >> 2 ;
      new_slen[3] = (scalefac_comp % 4);
      si->ch[ch].gr[gr].preflag = 0;

      blocknumber = 0;
    }

    else if( scalefac_comp  < 500)
    {
      new_slen[0] = ((scalefac_comp - 400 )  >> 2) / 5 ;
      new_slen[1] = ((scalefac_comp - 400) >> 2) % 5 ;
      new_slen[2] = (scalefac_comp - 400 ) % 4 ;
      new_slen[3] = 0;
      si->ch[ch].gr[gr].preflag = 0;
      blocknumber = 1;

    }

    else if( scalefac_comp  < 512)
    {
      new_slen[0] = (scalefac_comp - 500 ) / 3 ;
      new_slen[1] = (scalefac_comp - 500)  % 3 ;
      new_slen[2] = 0 ;
      new_slen[3] = 0;
      si->ch[ch].gr[gr].preflag = 1;
      blocknumber = 2;

    }
  }

  if((((hdr->mode_ext == 1) || (hdr->mode_ext == 3)) && (ch == 1)))
  {
    /*   intensity_scale = scalefac_comp %2; */
    int_scalefac_comp = scalefac_comp >> 1;

    if(int_scalefac_comp  < 180)
    {
      new_slen[0] = int_scalefac_comp  / 36 ;
      new_slen[1] = (int_scalefac_comp % 36 ) / 6 ;
      new_slen[2] = (int_scalefac_comp % 36) % 6;
      new_slen[3] = 0;
      si->ch[ch].gr[gr].preflag = 0;
      blocknumber = 3;

    }

    else if( int_scalefac_comp  < 244)
    {
      new_slen[0] = ((int_scalefac_comp - 180 )  % 64 ) >> 4 ;
      new_slen[1] = ((int_scalefac_comp - 180) % 16) >> 2 ;
      new_slen[2] = (int_scalefac_comp - 180 ) % 4 ;
      new_slen[3] = 0;
      si->ch[ch].gr[gr].preflag = 0;
      blocknumber = 4;

    }

    else if( int_scalefac_comp  < 255)
    {
      new_slen[0] = (int_scalefac_comp - 244 ) / 3 ;
      new_slen[1] = (int_scalefac_comp - 244 )  % 3 ;
      new_slen[2] = 0 ;
      new_slen[3] = 0;
      si->ch[ch].gr[gr].preflag = 0;
      blocknumber = 5;

    }
  }

  for (i=0;i< 45;i++) scalefac_buffer[i] = 0;

  k = 0;
  for (i = 0;i < 4;i++)
  {
    for(j = 0; j < nr_of_sfb_block[blocknumber][blocktypenumber][i]; j++)
    {
      if(new_slen[i] == 0)
      {
        scalefac_buffer[k] = 0;
      }
      else
      {
        scalefac_buffer[k] =  hgetbits(new_slen[i]);
      }
      k++;

    }
  }

}


static void III_get_LSF_scale_factors(
    III_scalefac_t      *scalefac,
    III_side_info_t     *si,
    int                  gr,
    int                  ch,
    frame_params        *fr_ps)
{
  int                  sfb, /*i,*/k = 0, window;
  gr_info_s    *gr_info = &(si->ch[ch].gr[gr]);

  III_get_LSF_scale_data(scalefac, si, gr, ch, fr_ps);

  if (gr_info->window_switching_flag && (gr_info->block_type == 2)) {

    if (gr_info->mixed_block_flag) {        /* MIXED */ /* NEW - ag 11/25 */
      for (sfb = 0; sfb < 8; sfb++) {
        (*scalefac)[ch].l[sfb] = scalefac_buffer[k];
        k++;
      }
      for (sfb = 3; sfb < 12; sfb++)
        for (window=0; window<3; window++) {
          (*scalefac)[ch].s[window][sfb] = scalefac_buffer[k];
          k++;
        }
      for (sfb=12,window=0; window<3; window++)
        (*scalefac)[ch].s[window][sfb] = 0;

    } else {                                /* SHORT*/

      for (sfb = 0; sfb < 12; sfb++)
        for (window=0; window<3; window++) {
          (*scalefac)[ch].s[window][sfb] = scalefac_buffer[k];
          k++;
        }
      for (sfb=12,window=0; window<3; window++)
        (*scalefac)[ch].s[window][sfb] = 0;
    }

  } else {                                    /* LONG types 0,1,3 */

    for (sfb = 0; sfb < 21; sfb++) {
      (*scalefac)[ch].l[sfb] = scalefac_buffer[k];
      k++;
    }
    (*scalefac)[ch].l[22] = 0;
  }
}



/* header */
#define HUFFBITS unsigned long int
#define HTN     34
#define MXOFF   250

struct huffcodetab {
  char tablename[3];    /*string, containing table_description  */
  unsigned int xlen;    /*max. x-index+                         */
  unsigned int ylen;    /*max. y-index+                         */
  unsigned int linbits; /*number of linbits                     */
  unsigned int linmax;  /*max number to be stored in linbits    */
  int ref;              /*a positive value indicates a reference*/
  HUFFBITS *table;      /*pointer to array[xlen][ylen]          */
  unsigned char *hlen;  /*pointer to array[xlen][ylen]          */
  unsigned char(*val)[2];/*decoder tree                         */
  unsigned int treelen; /*length of decoder tree                */
};

//extern struct huffcodetab ht[HTN];/* global memory block                */
/* array of all huffcodtable headers    */
/* 0..31 Huffman code table 0..31       */
/* 32,33 count1-tables                  */
/* implementation functions */
static HUFFBITS dmask = (HUFFBITS)1 << (sizeof(HUFFBITS)*8-1);
// unsigned int hs = sizeof(HUFFBITS)*8;

static struct huffcodetab ht[HTN];     /* array of all huffcodtable headers    */
/* 0..31 Huffman code table 0..31       */
/* 32,33 count1-tables                  */

/******************** Layer III stuff ***********************/

/* .table  0   0  0  0  0*/
/* table 0 has no tree data*/

/* .table  1   7  2  2  0*/
static unsigned char treedata_1[] = {
  0x2, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x10, 0x2, 0x1, 0x0, 0x1, 0x0, 0x11
};

/* .table  2  17  3  3  0*/
static unsigned char treedata_2[] = {
  0x2, 0x1, 0x0, 0x0, 0x4, 0x1, 0x2, 0x1, 0x0, 0x10,
  0x0, 0x1, 0x2, 0x1, 0x0, 0x11, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x21,
  0x2, 0x1, 0x0, 0x12, 0x2, 0x1, 0x0, 0x2, 0x0, 0x22
};

/* .table  3  17  3  3  0*/
static unsigned char treedata_3[] = {
  0x4, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x1, 0x2, 0x1,
  0x0, 0x11, 0x2, 0x1, 0x0, 0x10, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x21,
  0x2, 0x1, 0x0, 0x12, 0x2, 0x1, 0x0, 0x2, 0x0, 0x22
};

/* .table  4   0  0  0  0*/
/* table 4 has no tree data*/

/* .table  5  31  4  4  0*/
static unsigned char treedata_5[] = {
  0x2, 0x1, 0x0, 0x0, 0x4, 0x1, 0x2, 0x1, 0x0, 0x10,
  0x0, 0x1, 0x2, 0x1, 0x0, 0x11, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20,
  0x0, 0x2, 0x2, 0x1, 0x0, 0x21, 0x0, 0x12, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x22, 0x0, 0x30, 0x2, 0x1, 0x0, 0x3, 0x0, 0x13,
  0x2, 0x1, 0x0, 0x31, 0x2, 0x1, 0x0, 0x32, 0x2, 0x1, 0x0, 0x23, 0x0, 0x33
};

/* .table  6  31  4  4  0*/
static unsigned char treedata_6[] = {
  0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x10,
  0x0, 0x11, 0x6, 0x1, 0x2, 0x1, 0x0, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x21,
  0x6, 0x1, 0x2, 0x1, 0x0, 0x12, 0x2, 0x1, 0x0, 0x2,
  0x0, 0x22, 0x4, 0x1, 0x2, 0x1, 0x0, 0x31, 0x0, 0x13, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x30, 0x0, 0x32, 0x2, 0x1, 0x0, 0x23, 0x2, 0x1, 0x0, 0x3, 0x0, 0x33
};

/* .table  7  71  6  6  0*/
static unsigned char treedata_7[] = {
  0x2, 0x1, 0x0, 0x0, 0x4, 0x1, 0x2, 0x1, 0x0, 0x10, 0x0,
  0x1, 0x8, 0x1, 0x2, 0x1, 0x0, 0x11, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20,
  0x0, 0x2, 0x0, 0x21, 0x12, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0,
  0x12, 0x2, 0x1, 0x0, 0x22, 0x0, 0x30, 0x4, 0x1, 0x2, 0x1, 0x0, 0x31,
  0x0, 0x13, 0x4, 0x1, 0x2, 0x1, 0x0, 0x3, 0x0, 0x32, 0x2,
  0x1, 0x0, 0x23, 0x0, 0x4, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x40,
  0x0, 0x41, 0x2, 0x1, 0x0, 0x14, 0x2, 0x1, 0x0, 0x42, 0x0,
  0x24, 0xc, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x33, 0x0, 0x43,
  0x0, 0x50, 0x4, 0x1, 0x2, 0x1, 0x0, 0x34, 0x0, 0x5, 0x0,
  0x51, 0x6, 0x1, 0x2, 0x1, 0x0, 0x15, 0x2, 0x1, 0x0, 0x52, 0x0, 0x25,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x44, 0x0, 0x35,  0x4,
  0x1, 0x2, 0x1, 0x0, 0x53, 0x0, 0x54, 0x2, 0x1, 0x0, 0x45, 0x0, 0x55
};

/* .table  8  71  6  6  0*/
static unsigned char treedata_8[] = {
  0x6, 0x1, 0x2, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x10, 0x0,
  0x1, 0x2, 0x1, 0x0, 0x11, 0x4, 0x1, 0x2, 0x1, 0x0, 0x21, 0x0, 0x12,
  0xe, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x2,
  0x2, 0x1, 0x0, 0x22, 0x4, 0x1, 0x2, 0x1, 0x0, 0x30, 0x0, 0x3, 0x2, 0x1,
  0x0, 0x31, 0x0, 0x13, 0xe, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2,
  0x1, 0x0, 0x32, 0x0, 0x23, 0x2, 0x1, 0x0, 0x40, 0x0, 0x4, 0x2, 0x1,
  0x0, 0x41, 0x2, 0x1, 0x0, 0x14, 0x0, 0x42, 0xc, 0x1,
  0x6, 0x1, 0x2, 0x1, 0x0, 0x24, 0x2, 0x1, 0x0, 0x33, 0x0, 0x50, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x43, 0x0, 0x34, 0x0, 0x51, 0x6, 0x1,
  0x2, 0x1, 0x0, 0x15, 0x2, 0x1, 0x0, 0x5, 0x0, 0x52, 0x6, 0x1, 0x2, 0x1,
  0x0, 0x25, 0x2, 0x1, 0x0, 0x44, 0x0, 0x35, 0x2,
  0x1, 0x0, 0x53, 0x2, 0x1, 0x0, 0x45, 0x2, 0x1, 0x0, 0x54, 0x0, 0x55
};

/* .table  9  71  6  6  0*/
static unsigned char treedata_9[] = {
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x10, 0x2,
  0x1, 0x0, 0x1, 0x0, 0x11, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20,
  0x0, 0x21, 0x2, 0x1, 0x0, 0x12, 0x2, 0x1, 0x0, 0x2,
  0x0, 0x22, 0xc, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x30, 0x0, 0x3,
  0x0, 0x31, 0x2, 0x1, 0x0, 0x13, 0x2, 0x1, 0x0, 0x32,
  0x0, 0x23, 0xc, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x41, 0x0, 0x14, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x40, 0x0, 0x33, 0x2, 0x1, 0x0, 0x42,
  0x0, 0x24, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x4, 0x0, 0x50,
  0x0, 0x43, 0x2, 0x1, 0x0, 0x34, 0x0, 0x51, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x15, 0x0, 0x52, 0x2, 0x1, 0x0, 0x25, 0x0, 0x44,
  0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x5, 0x0,
  0x54, 0x0, 0x53, 0x2, 0x1, 0x0, 0x35, 0x2, 0x1, 0x0, 0x45, 0x0, 0x55
};

/*.table 10 127  8  8  0*/
static unsigned char treedata_10[] = {
  0x2, 0x1, 0x0, 0x0, 0x4, 0x1, 0x2, 0x1, 0x0, 0x10,
  0x0, 0x1, 0xa, 0x1, 0x2, 0x1, 0x0, 0x11, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20,
  0x0, 0x2, 0x2, 0x1, 0x0, 0x21, 0x0, 0x12, 0x1c, 0x1,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x22, 0x0, 0x30, 0x2, 0x1, 0x0, 0x31,
  0x0, 0x13, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x3,
  0x0, 0x32, 0x2, 0x1, 0x0, 0x23, 0x0, 0x40, 0x4, 0x1, 0x2, 0x1, 0x0, 0x41,
  0x0, 0x14, 0x4, 0x1, 0x2, 0x1, 0x0, 0x4, 0x0, 0x33,
  0x2, 0x1, 0x0, 0x42, 0x0, 0x24, 0x1c, 0x1, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x50, 0x0, 0x5, 0x0, 0x60, 0x2, 0x1,
  0x0, 0x61, 0x0, 0x16, 0xc, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x43,
  0x0, 0x34, 0x0, 0x51, 0x2, 0x1, 0x0, 0x15, 0x2, 0x1,
  0x0, 0x52, 0x0, 0x25, 0x4, 0x1, 0x2, 0x1, 0x0, 0x26, 0x0, 0x36, 0x0, 0x71,
  0x14, 0x1, 0x8, 0x1, 0x2, 0x1, 0x0, 0x17, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x44, 0x0, 0x53, 0x0, 0x6, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x35, 0x0, 0x45, 0x0, 0x62, 0x2, 0x1, 0x0, 0x70,
  0x2, 0x1, 0x0, 0x7, 0x0, 0x64, 0xe, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x72,
  0x0, 0x27, 0x6, 0x1, 0x2, 0x1, 0x0, 0x63, 0x2, 0x1,
  0x0, 0x54, 0x0, 0x55, 0x2, 0x1, 0x0, 0x46, 0x0, 0x73, 0x8, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x37, 0x0, 0x65, 0x2, 0x1, 0x0, 0x56,
  0x0, 0x74, 0x6, 0x1, 0x2, 0x1, 0x0, 0x47, 0x2, 0x1, 0x0, 0x66, 0x0, 0x75,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x57, 0x0, 0x76, 0x2, 0x1, 0x0, 0x67, 0x0, 0x77
};

/* .table 11 127  8  8  0*/
static unsigned char treedata_11[] = {
  0x6, 0x1, 0x2, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x10,
  0x0, 0x1, 0x8, 0x1, 0x2, 0x1, 0x0, 0x11, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20,
  0x0, 0x2, 0x0, 0x12, 0x18, 0x1, 0x8, 0x1, 0x2, 0x1,
  0x0, 0x21, 0x2, 0x1, 0x0, 0x22, 0x2, 0x1, 0x0, 0x30, 0x0, 0x3, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x31, 0x0, 0x13, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x32, 0x0, 0x23, 0x4, 0x1, 0x2, 0x1, 0x0, 0x40, 0x0, 0x4, 0x2, 0x1,
  0x0, 0x41, 0x0, 0x14, 0x1e, 0x1, 0x10, 0x1, 0xa, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x42, 0x0, 0x24, 0x4, 0x1, 0x2, 0x1, 0x0, 0x33,
  0x0, 0x43, 0x0, 0x50, 0x4, 0x1, 0x2, 0x1, 0x0, 0x34,
  0x0, 0x51, 0x0, 0x61, 0x6, 0x1, 0x2, 0x1, 0x0, 0x16, 0x2, 0x1, 0x0, 0x6,
  0x0, 0x26, 0x2, 0x1, 0x0, 0x62, 0x2, 0x1, 0x0, 0x15,
  0x2, 0x1, 0x0, 0x5, 0x0, 0x52, 0x10, 0x1, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x25, 0x0, 0x44, 0x0, 0x60, 0x2, 0x1,
  0x0, 0x63, 0x0, 0x36, 0x4, 0x1, 0x2, 0x1, 0x0, 0x70, 0x0, 0x17, 0x0, 0x71,
  0x10, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x7,
  0x0, 0x64, 0x0, 0x72, 0x2, 0x1, 0x0, 0x27, 0x4, 0x1, 0x2, 0x1, 0x0, 0x53,
  0x0, 0x35, 0x2, 0x1, 0x0, 0x54, 0x0, 0x45, 0xa, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x46, 0x0, 0x73, 0x2, 0x1, 0x0, 0x37, 0x2, 0x1,
  0x0, 0x65, 0x0, 0x56, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x55, 0x0, 0x57, 0x0, 0x74, 0x2, 0x1, 0x0, 0x47, 0x0, 0x66,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x75, 0x0, 0x76, 0x2, 0x1, 0x0, 0x67, 0x0, 0x77
};

/* .table 12 127  8  8  0*/
static unsigned char treedata_12[] = {
  0xc, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x10, 0x0, 0x1,
  0x2, 0x1, 0x0, 0x11, 0x2, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x20, 0x0, 0x2,
  0x10, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x21, 0x0, 0x12,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x22, 0x0, 0x31, 0x2, 0x1, 0x0, 0x13, 0x2, 0x1,
  0x0, 0x30, 0x2, 0x1, 0x0, 0x3, 0x0, 0x40, 0x1a, 0x1,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x32, 0x0, 0x23, 0x2, 0x1, 0x0, 0x41,
  0x0, 0x33, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x14,
  0x0, 0x42, 0x2, 0x1, 0x0, 0x24, 0x2, 0x1, 0x0, 0x4, 0x0, 0x50, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x43, 0x0, 0x34, 0x2, 0x1, 0x0, 0x51,
  0x0, 0x15, 0x1c, 0x1, 0xe, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x52,
  0x0, 0x25, 0x2, 0x1, 0x0, 0x53, 0x0, 0x35, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x60, 0x0, 0x16, 0x0, 0x61, 0x4, 0x1, 0x2, 0x1, 0x0, 0x62,
  0x0, 0x26, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x5,
  0x0, 0x6, 0x0, 0x44, 0x2, 0x1, 0x0, 0x54, 0x0, 0x45, 0x12, 0x1, 0xa, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x63, 0x0, 0x36, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x70, 0x0, 0x7, 0x0, 0x71, 0x4, 0x1, 0x2, 0x1, 0x0, 0x17,
  0x0, 0x64, 0x2, 0x1, 0x0, 0x46, 0x0, 0x72, 0xa, 0x1,
  0x6, 0x1, 0x2, 0x1, 0x0, 0x27, 0x2, 0x1, 0x0, 0x55, 0x0, 0x73, 0x2, 0x1,
  0x0, 0x37, 0x0, 0x56, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x65, 0x0, 0x74, 0x2, 0x1, 0x0, 0x47, 0x0, 0x66, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x75, 0x0, 0x57, 0x2, 0x1, 0x0, 0x76, 0x2, 0x1, 0x0, 0x67, 0x0, 0x77
};

/* .table 13 511 16 16  0*/
static unsigned char treedata_13[] = {
  0x2, 0x1, 0x0, 0x0, 0x6, 0x1, 0x2, 0x1, 0x0, 0x10, 0x2, 0x1, 0x0, 0x1, 0x0,
  0x11, 0x1c, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x2, 0x2, 0x1,
  0x0, 0x21, 0x0, 0x12, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x22, 0x0, 0x30,
  0x2, 0x1, 0x0, 0x3, 0x0, 0x31, 0x6, 0x1, 0x2, 0x1, 0x0, 0x13, 0x2, 0x1,
  0x0, 0x32, 0x0, 0x23, 0x4, 0x1, 0x2, 0x1, 0x0, 0x40, 0x0, 0x4, 0x0, 0x41,
  0x46, 0x1, 0x1c, 0x1, 0xe, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x14, 0x2, 0x1,
  0x0, 0x33, 0x0, 0x42, 0x4, 0x1, 0x2, 0x1, 0x0, 0x24, 0x0, 0x50, 0x2, 0x1,
  0x0, 0x43, 0x0, 0x34, 0x4, 0x1, 0x2, 0x1, 0x0, 0x51, 0x0, 0x15, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x5, 0x0, 0x52, 0x2, 0x1, 0x0, 0x25, 0x2, 0x1, 0x0, 0x44,
  0x0, 0x53, 0xe, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x60, 0x0, 0x6,
  0x2, 0x1, 0x0, 0x61, 0x0, 0x16, 0x4, 0x1, 0x2, 0x1, 0x0, 0x80, 0x0, 0x8,
  0x0, 0x81, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x35, 0x0, 0x62,
  0x2, 0x1, 0x0, 0x26, 0x0, 0x54, 0x4, 0x1, 0x2, 0x1, 0x0, 0x45, 0x0, 0x63,
  0x2, 0x1, 0x0, 0x36, 0x0, 0x70, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x7,
  0x0, 0x55, 0x0, 0x71, 0x2, 0x1, 0x0, 0x17, 0x2, 0x1, 0x0, 0x27, 0x0, 0x37,
  0x48, 0x1, 0x18, 0x1, 0xc, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x18, 0x0, 0x82,
  0x2, 0x1, 0x0, 0x28, 0x4, 0x1, 0x2, 0x1, 0x0, 0x64, 0x0, 0x46, 0x0, 0x72,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x84, 0x0, 0x48, 0x2, 0x1, 0x0, 0x90,
  0x0, 0x9, 0x2, 0x1, 0x0, 0x91, 0x0, 0x19, 0x18, 0x1, 0xe, 0x1, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x73, 0x0, 0x65, 0x2, 0x1, 0x0, 0x56, 0x0, 0x74,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x47, 0x0, 0x66, 0x0, 0x83, 0x6, 0x1, 0x2, 0x1,
  0x0, 0x38, 0x2, 0x1, 0x0, 0x75, 0x0, 0x57, 0x2, 0x1, 0x0, 0x92, 0x0, 0x29,
  0xe, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x67, 0x0, 0x85, 0x2, 0x1,
  0x0, 0x58, 0x0, 0x39, 0x2, 0x1, 0x0, 0x93, 0x2, 0x1, 0x0, 0x49, 0x0, 0x86,
  0x6, 0x1, 0x2, 0x1, 0x0, 0xa0, 0x2, 0x1, 0x0, 0x68, 0x0, 0xa, 0x2, 0x1,
  0x0, 0xa1, 0x0, 0x1a, 0x44, 0x1, 0x18, 0x1, 0xc, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xa2, 0x0, 0x2a, 0x4, 0x1, 0x2, 0x1, 0x0, 0x95, 0x0, 0x59, 0x2, 0x1,
  0x0, 0xa3, 0x0, 0x3a, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x4a, 0x0, 0x96,
  0x2, 0x1, 0x0, 0xb0, 0x0, 0xb, 0x2, 0x1, 0x0, 0xb1, 0x0, 0x1b, 0x14, 0x1,
  0x8, 0x1, 0x2, 0x1, 0x0, 0xb2, 0x4, 0x1, 0x2, 0x1, 0x0, 0x76, 0x0, 0x77,
  0x0, 0x94, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x87, 0x0, 0x78, 0x0, 0xa4,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x69, 0x0, 0xa5, 0x0, 0x2b, 0xc, 0x1, 0x6, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x5a, 0x0, 0x88, 0x0, 0xb3, 0x2, 0x1, 0x0, 0x3b,
  0x2, 0x1, 0x0, 0x79, 0x0, 0xa6, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x6a,
  0x0, 0xb4, 0x0, 0xc0, 0x4, 0x1, 0x2, 0x1, 0x0, 0xc, 0x0, 0x98, 0x0, 0xc1,
  0x3c, 0x1, 0x16, 0x1, 0xa, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x1c, 0x2, 0x1,
  0x0, 0x89, 0x0, 0xb5, 0x2, 0x1, 0x0, 0x5b, 0x0, 0xc2, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x2c, 0x0, 0x3c, 0x4, 0x1, 0x2, 0x1, 0x0, 0xb6, 0x0, 0x6b, 0x2, 0x1,
  0x0, 0xc4, 0x0, 0x4c, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa8,
  0x0, 0x8a, 0x2, 0x1, 0x0, 0xd0, 0x0, 0xd, 0x2, 0x1, 0x0, 0xd1, 0x2, 0x1,
  0x0, 0x4b, 0x2, 0x1, 0x0, 0x97, 0x0, 0xa7, 0xc, 0x1, 0x6, 0x1, 0x2, 0x1,
  0x0, 0xc3, 0x2, 0x1, 0x0, 0x7a, 0x0, 0x99, 0x4, 0x1, 0x2, 0x1, 0x0, 0xc5,
  0x0, 0x5c, 0x0, 0xb7, 0x4, 0x1, 0x2, 0x1, 0x0, 0x1d, 0x0, 0xd2, 0x2, 0x1,
  0x0, 0x2d, 0x2, 0x1, 0x0, 0x7b, 0x0, 0xd3, 0x34, 0x1, 0x1c, 0x1, 0xc, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x3d, 0x0, 0xc6, 0x4, 0x1, 0x2, 0x1, 0x0, 0x6c,
  0x0, 0xa9, 0x2, 0x1, 0x0, 0x9a, 0x0, 0xd4, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xb8, 0x0, 0x8b, 0x2, 0x1, 0x0, 0x4d, 0x0, 0xc7, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x7c, 0x0, 0xd5, 0x2, 0x1, 0x0, 0x5d, 0x0, 0xe0, 0xa, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xe1, 0x0, 0x1e, 0x4, 0x1, 0x2, 0x1, 0x0, 0xe, 0x0, 0x2e,
  0x0, 0xe2, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xe3, 0x0, 0x6d, 0x2, 0x1,
  0x0, 0x8c, 0x0, 0xe4, 0x4, 0x1, 0x2, 0x1, 0x0, 0xe5, 0x0, 0xba, 0x0, 0xf0,
  0x26, 0x1, 0x10, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf1, 0x0, 0x1f, 0x6, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xaa, 0x0, 0x9b, 0x0, 0xb9, 0x2, 0x1, 0x0, 0x3e,
  0x2, 0x1, 0x0, 0xd6, 0x0, 0xc8, 0xc, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x4e,
  0x2, 0x1, 0x0, 0xd7, 0x0, 0x7d, 0x2, 0x1, 0x0, 0xab, 0x2, 0x1, 0x0, 0x5e,
  0x0, 0xc9, 0x6, 0x1, 0x2, 0x1, 0x0, 0xf, 0x2, 0x1, 0x0, 0x9c, 0x0, 0x6e,
  0x2, 0x1, 0x0, 0xf2, 0x0, 0x2f, 0x20, 0x1, 0x10, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xd8, 0x0, 0x8d, 0x0, 0x3f, 0x6, 0x1, 0x2, 0x1, 0x0, 0xf3,
  0x2, 0x1, 0x0, 0xe6, 0x0, 0xca, 0x2, 0x1, 0x0, 0xf4, 0x0, 0x4f, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xbb, 0x0, 0xac, 0x2, 0x1, 0x0, 0xe7, 0x0, 0xf5,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xd9, 0x0, 0x9d, 0x2, 0x1, 0x0, 0x5f, 0x0, 0xe8,
  0x1e, 0x1, 0xc, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x6f, 0x2, 0x1, 0x0, 0xf6,
  0x0, 0xcb, 0x4, 0x1, 0x2, 0x1, 0x0, 0xbc, 0x0, 0xad, 0x0, 0xda, 0x8, 0x1,
  0x2, 0x1, 0x0, 0xf7, 0x4, 0x1, 0x2, 0x1, 0x0, 0x7e, 0x0, 0x7f, 0x0, 0x8e,
  0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9e, 0x0, 0xae, 0x0, 0xcc, 0x2, 0x1,
  0x0, 0xf8, 0x0, 0x8f, 0x12, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xdb,
  0x0, 0xbd, 0x2, 0x1, 0x0, 0xea, 0x0, 0xf9, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9f,
  0x0, 0xeb, 0x2, 0x1, 0x0, 0xbe, 0x2, 0x1, 0x0, 0xcd, 0x0, 0xfa, 0xe, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xdd, 0x0, 0xec, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xe9, 0x0, 0xaf, 0x0, 0xdc, 0x2, 0x1, 0x0, 0xce, 0x0, 0xfb, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xbf, 0x0, 0xde, 0x2, 0x1, 0x0, 0xcf, 0x0, 0xee,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xdf, 0x0, 0xef, 0x2, 0x1, 0x0, 0xff, 0x2, 0x1,
  0x0, 0xed, 0x2, 0x1, 0x0, 0xfd, 0x2, 0x1, 0x0, 0xfc, 0x0, 0xfe
};

/* .table 14   0  0  0  0*/
/* table 14 has no tree data*/

/* .table 15 511 16 16  0*/
static unsigned char treedata_15[] = {
  0x10, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x0, 0x2, 0x1, 0x0, 0x10, 0x0, 0x1, 0x2,
  0x1, 0x0, 0x11, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x2, 0x2, 0x1, 0x0, 0x21,
  0x0, 0x12, 0x32, 0x1, 0x10, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x22, 0x2, 0x1,
  0x0, 0x30, 0x0, 0x31, 0x6, 0x1, 0x2, 0x1, 0x0, 0x13, 0x2, 0x1, 0x0, 0x3,
  0x0, 0x40, 0x2, 0x1, 0x0, 0x32, 0x0, 0x23, 0xe, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x4, 0x0, 0x14, 0x0, 0x41, 0x4, 0x1, 0x2, 0x1, 0x0, 0x33,
  0x0, 0x42, 0x2, 0x1, 0x0, 0x24, 0x0, 0x43, 0xa, 0x1, 0x6, 0x1, 0x2, 0x1,
  0x0, 0x34, 0x2, 0x1, 0x0, 0x50, 0x0, 0x5, 0x2, 0x1, 0x0, 0x51, 0x0, 0x15,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x52, 0x0, 0x25, 0x4, 0x1, 0x2, 0x1, 0x0, 0x44,
  0x0, 0x53, 0x0, 0x61, 0x5a, 0x1, 0x24, 0x1, 0x12, 0x1, 0xa, 0x1, 0x6, 0x1,
  0x2, 0x1, 0x0, 0x35, 0x2, 0x1, 0x0, 0x60, 0x0, 0x6, 0x2, 0x1, 0x0, 0x16,
  0x0, 0x62, 0x4, 0x1, 0x2, 0x1, 0x0, 0x26, 0x0, 0x54, 0x2, 0x1, 0x0, 0x45,
  0x0, 0x63, 0xa, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x36, 0x2, 0x1, 0x0, 0x70,
  0x0, 0x7, 0x2, 0x1, 0x0, 0x71, 0x0, 0x55, 0x4, 0x1, 0x2, 0x1, 0x0, 0x17,
  0x0, 0x64, 0x2, 0x1, 0x0, 0x72, 0x0, 0x27, 0x18, 0x1, 0x10, 0x1, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x46, 0x0, 0x73, 0x2, 0x1, 0x0, 0x37, 0x0, 0x65,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x56, 0x0, 0x80, 0x2, 0x1, 0x0, 0x8, 0x0, 0x74,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x81, 0x0, 0x18, 0x2, 0x1, 0x0, 0x82, 0x0, 0x28,
  0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x47, 0x0, 0x66, 0x2, 0x1,
  0x0, 0x83, 0x0, 0x38, 0x4, 0x1, 0x2, 0x1, 0x0, 0x75, 0x0, 0x57, 0x2, 0x1,
  0x0, 0x84, 0x0, 0x48, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x90, 0x0, 0x19,
  0x0, 0x91, 0x4, 0x1, 0x2, 0x1, 0x0, 0x92, 0x0, 0x76, 0x2, 0x1, 0x0, 0x67,
  0x0, 0x29, 0x5c, 0x1, 0x24, 0x1, 0x12, 0x1, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x85, 0x0, 0x58, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9, 0x0, 0x77, 0x0, 0x93,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x39, 0x0, 0x94, 0x2, 0x1, 0x0, 0x49, 0x0, 0x86,
  0xa, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x68, 0x2, 0x1, 0x0, 0xa0, 0x0, 0xa,
  0x2, 0x1, 0x0, 0xa1, 0x0, 0x1a, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa2, 0x0, 0x2a,
  0x2, 0x1, 0x0, 0x95, 0x0, 0x59, 0x1a, 0x1, 0xe, 0x1, 0x6, 0x1, 0x2, 0x1,
  0x0, 0xa3, 0x2, 0x1, 0x0, 0x3a, 0x0, 0x87, 0x4, 0x1, 0x2, 0x1, 0x0, 0x78,
  0x0, 0xa4, 0x2, 0x1, 0x0, 0x4a, 0x0, 0x96, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x69, 0x0, 0xb0, 0x0, 0xb1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x1b, 0x0, 0xa5,
  0x0, 0xb2, 0xe, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x5a, 0x0, 0x2b,
  0x2, 0x1, 0x0, 0x88, 0x0, 0x97, 0x2, 0x1, 0x0, 0xb3, 0x2, 0x1, 0x0, 0x79,
  0x0, 0x3b, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x6a, 0x0, 0xb4, 0x2, 0x1,
  0x0, 0x4b, 0x0, 0xc1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x98, 0x0, 0x89, 0x2, 0x1,
  0x0, 0x1c, 0x0, 0xb5, 0x50, 0x1, 0x22, 0x1, 0x10, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x5b, 0x0, 0x2c, 0x0, 0xc2, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xb, 0x0, 0xc0, 0x0, 0xa6, 0x2, 0x1, 0x0, 0xa7, 0x0, 0x7a, 0xa, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xc3, 0x0, 0x3c, 0x4, 0x1, 0x2, 0x1, 0x0, 0xc,
  0x0, 0x99, 0x0, 0xb6, 0x4, 0x1, 0x2, 0x1, 0x0, 0x6b, 0x0, 0xc4, 0x2, 0x1,
  0x0, 0x4c, 0x0, 0xa8, 0x14, 0x1, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x8a,
  0x0, 0xc5, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd0, 0x0, 0x5c, 0x0, 0xd1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xb7, 0x0, 0x7b, 0x2, 0x1, 0x0, 0x1d, 0x2, 0x1, 0x0, 0xd,
  0x0, 0x2d, 0xc, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd2, 0x0, 0xd3, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x3d, 0x0, 0xc6, 0x2, 0x1, 0x0, 0x6c, 0x0, 0xa9, 0x6, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x9a, 0x0, 0xb8, 0x0, 0xd4, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x8b, 0x0, 0x4d, 0x2, 0x1, 0x0, 0xc7, 0x0, 0x7c, 0x44, 0x1, 0x22, 0x1,
  0x12, 0x1, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd5, 0x0, 0x5d, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xe0, 0x0, 0xe, 0x0, 0xe1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x1e,
  0x0, 0xe2, 0x2, 0x1, 0x0, 0xaa, 0x0, 0x2e, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xb9, 0x0, 0x9b, 0x2, 0x1, 0x0, 0xe3, 0x0, 0xd6, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x6d, 0x0, 0x3e, 0x2, 0x1, 0x0, 0xc8, 0x0, 0x8c, 0x10, 0x1, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xe4, 0x0, 0x4e, 0x2, 0x1, 0x0, 0xd7, 0x0, 0x7d,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xe5, 0x0, 0xba, 0x2, 0x1, 0x0, 0xab, 0x0, 0x5e,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xc9, 0x0, 0x9c, 0x2, 0x1, 0x0, 0xf1,
  0x0, 0x1f, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf0, 0x0, 0x6e, 0x0, 0xf2,
  0x2, 0x1, 0x0, 0x2f, 0x0, 0xe6, 0x26, 0x1, 0x12, 0x1, 0x8, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xd8, 0x0, 0xf3, 0x2, 0x1, 0x0, 0x3f, 0x0, 0xf4, 0x6, 0x1,
  0x2, 0x1, 0x0, 0x4f, 0x2, 0x1, 0x0, 0x8d, 0x0, 0xd9, 0x2, 0x1, 0x0, 0xbb,
  0x0, 0xca, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xac, 0x0, 0xe7, 0x2, 0x1,
  0x0, 0x7e, 0x0, 0xf5, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9d, 0x0, 0x5f,
  0x2, 0x1, 0x0, 0xe8, 0x0, 0x8e, 0x2, 0x1, 0x0, 0xf6, 0x0, 0xcb, 0x22, 0x1,
  0x12, 0x1, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf, 0x0, 0xae,
  0x0, 0x6f, 0x2, 0x1, 0x0, 0xbc, 0x0, 0xda, 0x4, 0x1, 0x2, 0x1, 0x0, 0xad,
  0x0, 0xf7, 0x2, 0x1, 0x0, 0x7f, 0x0, 0xe9, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x9e, 0x0, 0xcc, 0x2, 0x1, 0x0, 0xf8, 0x0, 0x8f, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xdb, 0x0, 0xbd, 0x2, 0x1, 0x0, 0xea, 0x0, 0xf9, 0x10, 0x1, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x9f, 0x0, 0xdc, 0x2, 0x1, 0x0, 0xcd, 0x0, 0xeb,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xbe, 0x0, 0xfa, 0x2, 0x1, 0x0, 0xaf, 0x0, 0xdd,
  0xe, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xec, 0x0, 0xce, 0x0, 0xfb,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xbf, 0x0, 0xed, 0x2, 0x1, 0x0, 0xde, 0x0, 0xfc,
  0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xcf, 0x0, 0xfd, 0x0, 0xee, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xdf, 0x0, 0xfe, 0x2, 0x1, 0x0, 0xef, 0x0, 0xff
};

/* .table 16 511 16 16  1*/
static unsigned char treedata_16[] = {
  0x2, 0x1, 0x0, 0x0, 0x6, 0x1, 0x2, 0x1, 0x0, 0x10, 0x2, 0x1, 0x0, 0x1, 0x0,
  0x11, 0x2a, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x2, 0x2, 0x1,
  0x0, 0x21, 0x0, 0x12, 0xa, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x22, 0x2, 0x1,
  0x0, 0x30, 0x0, 0x3, 0x2, 0x1, 0x0, 0x31, 0x0, 0x13, 0xa, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x32, 0x0, 0x23, 0x4, 0x1, 0x2, 0x1, 0x0, 0x40, 0x0, 0x4,
  0x0, 0x41, 0x6, 0x1, 0x2, 0x1, 0x0, 0x14, 0x2, 0x1, 0x0, 0x33, 0x0, 0x42,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x24, 0x0, 0x50, 0x2, 0x1, 0x0, 0x43, 0x0, 0x34,
  0x8a, 0x1, 0x28, 0x1, 0x10, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x5,
  0x0, 0x15, 0x0, 0x51, 0x4, 0x1, 0x2, 0x1, 0x0, 0x52, 0x0, 0x25, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x44, 0x0, 0x35, 0x0, 0x53, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x60, 0x0, 0x6, 0x0, 0x61, 0x2, 0x1, 0x0, 0x16, 0x0, 0x62,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x26, 0x0, 0x54, 0x2, 0x1, 0x0, 0x45,
  0x0, 0x63, 0x4, 0x1, 0x2, 0x1, 0x0, 0x36, 0x0, 0x70, 0x0, 0x71, 0x28, 0x1,
  0x12, 0x1, 0x8, 0x1, 0x2, 0x1, 0x0, 0x17, 0x2, 0x1, 0x0, 0x7, 0x2, 0x1,
  0x0, 0x55, 0x0, 0x64, 0x4, 0x1, 0x2, 0x1, 0x0, 0x72, 0x0, 0x27, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x46, 0x0, 0x65, 0x0, 0x73, 0xa, 0x1, 0x6, 0x1, 0x2, 0x1,
  0x0, 0x37, 0x2, 0x1, 0x0, 0x56, 0x0, 0x8, 0x2, 0x1, 0x0, 0x80, 0x0, 0x81,
  0x6, 0x1, 0x2, 0x1, 0x0, 0x18, 0x2, 0x1, 0x0, 0x74, 0x0, 0x47, 0x2, 0x1,
  0x0, 0x82, 0x2, 0x1, 0x0, 0x28, 0x0, 0x66, 0x18, 0x1, 0xe, 0x1, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x83, 0x0, 0x38, 0x2, 0x1, 0x0, 0x75, 0x0, 0x84,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x48, 0x0, 0x90, 0x0, 0x91, 0x6, 0x1, 0x2, 0x1,
  0x0, 0x19, 0x2, 0x1, 0x0, 0x9, 0x0, 0x76, 0x2, 0x1, 0x0, 0x92, 0x0, 0x29,
  0xe, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x85, 0x0, 0x58, 0x2, 0x1,
  0x0, 0x93, 0x0, 0x39, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa0, 0x0, 0xa, 0x0, 0x1a,
  0x8, 0x1, 0x2, 0x1, 0x0, 0xa2, 0x2, 0x1, 0x0, 0x67, 0x2, 0x1, 0x0, 0x57,
  0x0, 0x49, 0x6, 0x1, 0x2, 0x1, 0x0, 0x94, 0x2, 0x1, 0x0, 0x77, 0x0, 0x86,
  0x2, 0x1, 0x0, 0xa1, 0x2, 0x1, 0x0, 0x68, 0x0, 0x95, 0xdc, 0x1, 0x7e, 0x1,
  0x32, 0x1, 0x1a, 0x1, 0xc, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x2a, 0x2, 0x1,
  0x0, 0x59, 0x0, 0x3a, 0x2, 0x1, 0x0, 0xa3, 0x2, 0x1, 0x0, 0x87, 0x0, 0x78,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa4, 0x0, 0x4a, 0x2, 0x1, 0x0, 0x96,
  0x0, 0x69, 0x4, 0x1, 0x2, 0x1, 0x0, 0xb0, 0x0, 0xb, 0x0, 0xb1, 0xa, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x1b, 0x0, 0xb2, 0x2, 0x1, 0x0, 0x2b, 0x2, 0x1,
  0x0, 0xa5, 0x0, 0x5a, 0x6, 0x1, 0x2, 0x1, 0x0, 0xb3, 0x2, 0x1, 0x0, 0xa6,
  0x0, 0x6a, 0x4, 0x1, 0x2, 0x1, 0x0, 0xb4, 0x0, 0x4b, 0x2, 0x1, 0x0, 0xc,
  0x0, 0xc1, 0x1e, 0x1, 0xe, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xb5,
  0x0, 0xc2, 0x0, 0x2c, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa7, 0x0, 0xc3, 0x2, 0x1,
  0x0, 0x6b, 0x0, 0xc4, 0x8, 0x1, 0x2, 0x1, 0x0, 0x1d, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x88, 0x0, 0x97, 0x0, 0x3b, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd1, 0x0, 0xd2,
  0x2, 0x1, 0x0, 0x2d, 0x0, 0xd3, 0x12, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x1e, 0x0, 0x2e, 0x0, 0xe2, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x79,
  0x0, 0x98, 0x0, 0xc0, 0x2, 0x1, 0x0, 0x1c, 0x2, 0x1, 0x0, 0x89, 0x0, 0x5b,
  0xe, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x3c, 0x2, 0x1, 0x0, 0x7a, 0x0, 0xb6,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x4c, 0x0, 0x99, 0x2, 0x1, 0x0, 0xa8, 0x0, 0x8a,
  0x6, 0x1, 0x2, 0x1, 0x0, 0xd, 0x2, 0x1, 0x0, 0xc5, 0x0, 0x5c, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x3d, 0x0, 0xc6, 0x2, 0x1, 0x0, 0x6c, 0x0, 0x9a, 0x58, 0x1,
  0x56, 0x1, 0x24, 0x1, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x8b,
  0x0, 0x4d, 0x2, 0x1, 0x0, 0xc7, 0x0, 0x7c, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd5,
  0x0, 0x5d, 0x2, 0x1, 0x0, 0xe0, 0x0, 0xe, 0x8, 0x1, 0x2, 0x1, 0x0, 0xe3,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xd0, 0x0, 0xb7, 0x0, 0x7b, 0x6, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xa9, 0x0, 0xb8, 0x0, 0xd4, 0x2, 0x1, 0x0, 0xe1, 0x2, 0x1,
  0x0, 0xaa, 0x0, 0xb9, 0x18, 0x1, 0xa, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x9b, 0x0, 0xd6, 0x0, 0x6d, 0x2, 0x1, 0x0, 0x3e, 0x0, 0xc8, 0x6, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x8c, 0x0, 0xe4, 0x0, 0x4e, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xd7, 0x0, 0xe5, 0x2, 0x1, 0x0, 0xba, 0x0, 0xab, 0xc, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x9c, 0x0, 0xe6, 0x4, 0x1, 0x2, 0x1, 0x0, 0x6e, 0x0, 0xd8,
  0x2, 0x1, 0x0, 0x8d, 0x0, 0xbb, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xe7,
  0x0, 0x9d, 0x2, 0x1, 0x0, 0xe8, 0x0, 0x8e, 0x4, 0x1, 0x2, 0x1, 0x0, 0xcb,
  0x0, 0xbc, 0x0, 0x9e, 0x0, 0xf1, 0x2, 0x1, 0x0, 0x1f, 0x2, 0x1, 0x0, 0xf,
  0x0, 0x2f, 0x42, 0x1, 0x38, 0x1, 0x2, 0x1, 0x0, 0xf2, 0x34, 0x1, 0x32, 0x1,
  0x14, 0x1, 0x8, 0x1, 0x2, 0x1, 0x0, 0xbd, 0x2, 0x1, 0x0, 0x5e, 0x2, 0x1,
  0x0, 0x7d, 0x0, 0xc9, 0x6, 0x1, 0x2, 0x1, 0x0, 0xca, 0x2, 0x1, 0x0, 0xac,
  0x0, 0x7e, 0x4, 0x1, 0x2, 0x1, 0x0, 0xda, 0x0, 0xad, 0x0, 0xcc, 0xa, 0x1,
  0x6, 0x1, 0x2, 0x1, 0x0, 0xae, 0x2, 0x1, 0x0, 0xdb, 0x0, 0xdc, 0x2, 0x1,
  0x0, 0xcd, 0x0, 0xbe, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xeb, 0x0, 0xed,
  0x0, 0xee, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd9, 0x0, 0xea, 0x0, 0xe9,
  0x2, 0x1, 0x0, 0xde, 0x4, 0x1, 0x2, 0x1, 0x0, 0xdd, 0x0, 0xec, 0x0, 0xce,
  0x0, 0x3f, 0x0, 0xf0, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf3, 0x0, 0xf4, 0x2, 0x1,
  0x0, 0x4f, 0x2, 0x1, 0x0, 0xf5, 0x0, 0x5f, 0xa, 0x1, 0x2, 0x1, 0x0, 0xff,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xf6, 0x0, 0x6f, 0x2, 0x1, 0x0, 0xf7, 0x0, 0x7f,
  0xc, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x8f, 0x2, 0x1, 0x0, 0xf8, 0x0, 0xf9,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x9f, 0x0, 0xfa, 0x0, 0xaf, 0x8, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xfb, 0x0, 0xbf, 0x2, 0x1, 0x0, 0xfc, 0x0, 0xcf, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xfd, 0x0, 0xdf, 0x2, 0x1, 0x0, 0xfe, 0x0, 0xef
};

/* .table 17 511 16 16  2*/
/* .reference 16*/

/* .table 18 511 16 16  3*/
/* .reference 16*/

/* .table 19 511 16 16  4*/
/* .reference 16*/

/* .table 20 511 16 16  6*/
/* .reference 16*/

/* .table 21 511 16 16  8*/
/* .reference 16*/

/* .table 22 511 16 16 10*/
/* .reference 16*/

/* .table 23 511 16 16 13*/
/* .reference 16*/

/* .table 24 512 16 16  4*/
static unsigned char treedata_24[] = {
  0x3c, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x10, 0x2, 0x1, 0x0,
  0x1, 0x0, 0x11, 0xe, 0x1, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x20, 0x0, 0x2,
  0x0, 0x21, 0x2, 0x1, 0x0, 0x12, 0x2, 0x1, 0x0, 0x22, 0x2, 0x1, 0x0, 0x30,
  0x0, 0x3, 0xe, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x31, 0x0, 0x13, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x32, 0x0, 0x23, 0x4, 0x1, 0x2, 0x1, 0x0, 0x40, 0x0, 0x4,
  0x0, 0x41, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x14, 0x0, 0x33, 0x2, 0x1,
  0x0, 0x42, 0x0, 0x24, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x43, 0x0, 0x34,
  0x0, 0x51, 0x6, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x50, 0x0, 0x5, 0x0, 0x15,
  0x2, 0x1, 0x0, 0x52, 0x0, 0x25, 0xfa, 0x1, 0x62, 0x1, 0x22, 0x1, 0x12, 0x1,
  0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x44, 0x0, 0x53, 0x2, 0x1, 0x0, 0x35,
  0x2, 0x1, 0x0, 0x60, 0x0, 0x6, 0x4, 0x1, 0x2, 0x1, 0x0, 0x61, 0x0, 0x16,
  0x2, 0x1, 0x0, 0x62, 0x0, 0x26, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x54,
  0x0, 0x45, 0x2, 0x1, 0x0, 0x63, 0x0, 0x36, 0x4, 0x1, 0x2, 0x1, 0x0, 0x71,
  0x0, 0x55, 0x2, 0x1, 0x0, 0x64, 0x0, 0x46, 0x20, 0x1, 0xe, 0x1, 0x6, 0x1,
  0x2, 0x1, 0x0, 0x72, 0x2, 0x1, 0x0, 0x27, 0x0, 0x37, 0x2, 0x1, 0x0, 0x73,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x70, 0x0, 0x7, 0x0, 0x17, 0xa, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x65, 0x0, 0x56, 0x4, 0x1, 0x2, 0x1, 0x0, 0x80, 0x0, 0x8,
  0x0, 0x81, 0x4, 0x1, 0x2, 0x1, 0x0, 0x74, 0x0, 0x47, 0x2, 0x1, 0x0, 0x18,
  0x0, 0x82, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x28, 0x0, 0x66,
  0x2, 0x1, 0x0, 0x83, 0x0, 0x38, 0x4, 0x1, 0x2, 0x1, 0x0, 0x75, 0x0, 0x57,
  0x2, 0x1, 0x0, 0x84, 0x0, 0x48, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x91,
  0x0, 0x19, 0x2, 0x1, 0x0, 0x92, 0x0, 0x76, 0x4, 0x1, 0x2, 0x1, 0x0, 0x67,
  0x0, 0x29, 0x2, 0x1, 0x0, 0x85, 0x0, 0x58, 0x5c, 0x1, 0x22, 0x1, 0x10, 0x1,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x93, 0x0, 0x39, 0x2, 0x1, 0x0, 0x94,
  0x0, 0x49, 0x4, 0x1, 0x2, 0x1, 0x0, 0x77, 0x0, 0x86, 0x2, 0x1, 0x0, 0x68,
  0x0, 0xa1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa2, 0x0, 0x2a, 0x2, 0x1,
  0x0, 0x95, 0x0, 0x59, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa3, 0x0, 0x3a, 0x2, 0x1,
  0x0, 0x87, 0x2, 0x1, 0x0, 0x78, 0x0, 0x4a, 0x16, 0x1, 0xc, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xa4, 0x0, 0x96, 0x4, 0x1, 0x2, 0x1, 0x0, 0x69, 0x0, 0xb1,
  0x2, 0x1, 0x0, 0x1b, 0x0, 0xa5, 0x6, 0x1, 0x2, 0x1, 0x0, 0xb2, 0x2, 0x1,
  0x0, 0x5a, 0x0, 0x2b, 0x2, 0x1, 0x0, 0x88, 0x0, 0xb3, 0x10, 0x1, 0xa, 0x1,
  0x6, 0x1, 0x2, 0x1, 0x0, 0x90, 0x2, 0x1, 0x0, 0x9, 0x0, 0xa0, 0x2, 0x1,
  0x0, 0x97, 0x0, 0x79, 0x4, 0x1, 0x2, 0x1, 0x0, 0xa6, 0x0, 0x6a, 0x0, 0xb4,
  0xc, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x1a, 0x2, 0x1, 0x0, 0xa, 0x0, 0xb0,
  0x2, 0x1, 0x0, 0x3b, 0x2, 0x1, 0x0, 0xb, 0x0, 0xc0, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x4b, 0x0, 0xc1, 0x2, 0x1, 0x0, 0x98, 0x0, 0x89, 0x43, 0x1, 0x22, 0x1,
  0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x1c, 0x0, 0xb5, 0x2, 0x1,
  0x0, 0x5b, 0x0, 0xc2, 0x4, 0x1, 0x2, 0x1, 0x0, 0x2c, 0x0, 0xa7, 0x2, 0x1,
  0x0, 0x7a, 0x0, 0xc3, 0xa, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x3c, 0x2, 0x1,
  0x0, 0xc, 0x0, 0xd0, 0x2, 0x1, 0x0, 0xb6, 0x0, 0x6b, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xc4, 0x0, 0x4c, 0x2, 0x1, 0x0, 0x99, 0x0, 0xa8, 0x10, 0x1, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x8a, 0x0, 0xc5, 0x2, 0x1, 0x0, 0x5c, 0x0, 0xd1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xb7, 0x0, 0x7b, 0x2, 0x1, 0x0, 0x1d, 0x0, 0xd2,
  0x9, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x2d, 0x0, 0xd3, 0x2, 0x1, 0x0, 0x3d,
  0x0, 0xc6, 0x55, 0xfa, 0x4, 0x1, 0x2, 0x1, 0x0, 0x6c, 0x0, 0xa9, 0x2, 0x1,
  0x0, 0x9a, 0x0, 0xd4, 0x20, 0x1, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0xb8, 0x0, 0x8b, 0x2, 0x1, 0x0, 0x4d, 0x0, 0xc7, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x7c, 0x0, 0xd5, 0x2, 0x1, 0x0, 0x5d, 0x0, 0xe1, 0x8, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x1e, 0x0, 0xe2, 0x2, 0x1, 0x0, 0xaa, 0x0, 0xb9, 0x4, 0x1,
  0x2, 0x1, 0x0, 0x9b, 0x0, 0xe3, 0x2, 0x1, 0x0, 0xd6, 0x0, 0x6d, 0x14, 0x1,
  0xa, 0x1, 0x6, 0x1, 0x2, 0x1, 0x0, 0x3e, 0x2, 0x1, 0x0, 0x2e, 0x0, 0x4e,
  0x2, 0x1, 0x0, 0xc8, 0x0, 0x8c, 0x4, 0x1, 0x2, 0x1, 0x0, 0xe4, 0x0, 0xd7,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x7d, 0x0, 0xab, 0x0, 0xe5, 0xa, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xba, 0x0, 0x5e, 0x2, 0x1, 0x0, 0xc9, 0x2, 0x1, 0x0, 0x9c,
  0x0, 0x6e, 0x8, 0x1, 0x2, 0x1, 0x0, 0xe6, 0x2, 0x1, 0x0, 0xd, 0x2, 0x1,
  0x0, 0xe0, 0x0, 0xe, 0x4, 0x1, 0x2, 0x1, 0x0, 0xd8, 0x0, 0x8d, 0x2, 0x1,
  0x0, 0xbb, 0x0, 0xca, 0x4a, 0x1, 0x2, 0x1, 0x0, 0xff, 0x40, 0x1, 0x3a, 0x1,
  0x20, 0x1, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xac, 0x0, 0xe7,
  0x2, 0x1, 0x0, 0x7e, 0x0, 0xd9, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9d, 0x0, 0xe8,
  0x2, 0x1, 0x0, 0x8e, 0x0, 0xcb, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xbc,
  0x0, 0xda, 0x2, 0x1, 0x0, 0xad, 0x0, 0xe9, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9e,
  0x0, 0xcc, 0x2, 0x1, 0x0, 0xdb, 0x0, 0xbd, 0x10, 0x1, 0x8, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xea, 0x0, 0xae, 0x2, 0x1, 0x0, 0xdc, 0x0, 0xcd, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xeb, 0x0, 0xbe, 0x2, 0x1, 0x0, 0xdd, 0x0, 0xec, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xce, 0x0, 0xed, 0x2, 0x1, 0x0, 0xde, 0x0, 0xee,
  0x0, 0xf, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf0, 0x0, 0x1f, 0x0, 0xf1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xf2, 0x0, 0x2f, 0x2, 0x1, 0x0, 0xf3, 0x0, 0x3f, 0x12, 0x1,
  0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf4, 0x0, 0x4f, 0x2, 0x1, 0x0, 0xf5,
  0x0, 0x5f, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf6, 0x0, 0x6f, 0x2, 0x1, 0x0, 0xf7,
  0x2, 0x1, 0x0, 0x7f, 0x0, 0x8f, 0xa, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0xf8,
  0x0, 0xf9, 0x4, 0x1, 0x2, 0x1, 0x0, 0x9f, 0x0, 0xaf, 0x0, 0xfa, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xfb, 0x0, 0xbf, 0x2, 0x1, 0x0, 0xfc, 0x0, 0xcf,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xfd, 0x0, 0xdf, 0x2, 0x1, 0x0, 0xfe, 0x0, 0xef
};

/* .table 25 512 16 16  5*/
/* .reference 24*/

/* .table 26 512 16 16  6*/
/* .reference 24*/

/* .table 27 512 16 16  7*/
/* .reference 24*/

/* .table 28 512 16 16  8*/
/* .reference 24*/

/* .table 29 512 16 16  9*/
/* .reference 24*/

/* .table 30 512 16 16 11*/
/* .reference 24*/

/* .table 31 512 16 16 13*/
/* .reference 24*/

/* .table 32  31  1 16  0*/
static unsigned char treedata_32[] = {
  0x2, 0x1, 0x0, 0x0, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1,
  0x0, 0x8, 0x0, 0x4, 0x2, 0x1, 0x0, 0x1, 0x0, 0x2, 0x8, 0x1, 0x4, 0x1,
  0x2, 0x1, 0x0, 0xc, 0x0, 0xa, 0x2, 0x1, 0x0, 0x3,
  0x0, 0x6, 0x6, 0x1, 0x2, 0x1, 0x0, 0x9, 0x2, 0x1, 0x0, 0x5, 0x0, 0x7,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xe, 0x0, 0xd, 0x2, 0x1, 0x0, 0xf, 0x0, 0xb,
};

/* .table 33  31  1 16  0*/
static unsigned char treedata_33[] = {
  0x10, 0x1, 0x8, 0x1, 0x4, 0x1, 0x2, 0x1, 0x0, 0x0,
  0x0, 0x1, 0x2, 0x1, 0x0, 0x2, 0x0, 0x3, 0x4, 0x1, 0x2, 0x1, 0x0, 0x4,
  0x0, 0x5, 0x2, 0x1, 0x0, 0x6, 0x0, 0x7, 0x8, 0x1,
  0x4, 0x1, 0x2, 0x1, 0x0, 0x8, 0x0, 0x9, 0x2, 0x1, 0x0, 0xa, 0x0, 0xb,
  0x4, 0x1, 0x2, 0x1, 0x0, 0xc, 0x0, 0xd, 0x2, 0x1, 0x0, 0xe, 0x0, 0xf
};

/* Information needed to recover .table lines*/
struct huffinfo {
  int            treelen;     /* 3rd col*/
  int            xlen;        /* 4th col*/
  int            ylen;        /* 5th col*/
  int            linbits;     /* 6th col*/
  /* Information for .treedata or .reference lines*/
  int            ref;         /* .reference table, or .treedata if -1*/
  unsigned char *data;        /* ptr to treedata array*/
};

struct huffinfo hufftab[HTN] = {
  {  0,  0,  0,  0, -1, NULL},                /* 0*/
  {  7,  2,  2,  0, -1, treedata_1},          /* 1*/
  { 17,  3,  3,  0, -1, treedata_2},          /* 2*/
  { 17,  3,  3,  0, -1, treedata_3},          /* 3*/
  {  0,  0,  0,  0, -1, NULL},                /* 4*/
  { 31,  4,  4,  0, -1, treedata_5},          /* 5*/
  { 31,  4,  4,  0, -1, treedata_6},          /* 6*/
  { 71,  6,  6,  0, -1, treedata_7},          /* 7*/
  { 71,  6,  6,  0, -1, treedata_8},          /* 8*/
  { 71,  6,  6,  0, -1, treedata_9},          /* 9*/
  {127,  8,  8,  0, -1, treedata_10},         /* 10*/
  {127,  8,  8,  0, -1, treedata_11},         /* 11*/
  {127,  8,  8,  0, -1, treedata_12},         /* 12*/
  {511, 16, 16,  0, -1, treedata_13},         /* 13*/
  {  0,  0,  0,  0, -1, NULL},                /* 14*/
  {511, 16, 16,  0, -1, treedata_15},         /* 15*/
  {511, 16, 16,  1, -1, treedata_16},         /* 16*/
  {511, 16, 16,  2, 16, NULL},                /* 17*/
  {511, 16, 16,  3, 16, NULL},                /* 18*/
  {511, 16, 16,  4, 16, NULL},                /* 19*/
  {511, 16, 16,  6, 16, NULL},                /* 20*/
  {511, 16, 16,  8, 16, NULL},                /* 21*/
  {511, 16, 16, 10, 16, NULL},                /* 22*/
  {511, 16, 16, 13, 16, NULL},                /* 23*/
  {512, 16, 16,  4, -1, treedata_24},         /* 24*/
  {512, 16, 16,  5, 24, NULL},                /* 25*/
  {512, 16, 16,  6, 24, NULL},                /* 26*/
  {512, 16, 16,  7, 24, NULL},                /* 27*/
  {512, 16, 16,  8, 24, NULL},                /* 28*/
  {512, 16, 16,  9, 24, NULL},                /* 29*/
  {512, 16, 16, 11, 24, NULL},                /* 30*/
  {512, 16, 16, 13, 24, NULL},                /* 31*/
  { 31,  1, 16,  0, -1, treedata_32},         /* 32*/
  { 31,  1, 16,  0, -1, treedata_33}          /* 33*/
};

/* Read the huffman decoder table */
static int tables_read_decoder_table()
{
  int                 n, nn, t;

  for (n = 0; n < HTN; n++) {

    sprintf(ht[n].tablename, "%d", n);
    ht[n].treelen   = hufftab[n].treelen;
    ht[n].xlen      = hufftab[n].xlen;
    ht[n].ylen      = hufftab[n].ylen;
    ht[n].linbits   = hufftab[n].linbits;

    ht[n].linmax = (1 << ht[n].linbits) - 1;

    /* Check table name   */
    sscanf(ht[n].tablename, "%u", &nn);
    if (nn != n) {
      fprintf(stderr, "wrong table number %u\n", n);
      return -2;
    }

    t = hufftab[n].ref;

    if (t >= 0) {
      ht[n].ref           = t;
      ht[n].val           = ht[t].val;
      ht[n].treelen       = ht[t].treelen;
      if ((ht[n].xlen != ht[t].xlen) || (ht[n].ylen != ht[t].ylen)) {
        fprintf(stderr,"wrong table %u reference\n",n);
        return -3;
      };

    } else if (t == -1) {
      unsigned char *p;
      int i;

      ht[n].ref   = -1;
      ht[n].val   = (unsigned char (*)[2])
        calloc(2 * (ht[n].treelen)+1, sizeof(unsigned char));
      if (ht[n].val == NULL) {
        fprintf(stderr, "tables.c: heap error at table %d\n", n);
        fprintf(stderr, "attempting malloc %d %d\n",
            2 * (ht[n].treelen), sizeof(unsigned char));
        exit(-10);
      }
      p = hufftab[n].data;
      for (i = 0; i < ht[n].treelen; i++) {
        ht[n].val[i][0] = *p++;
        ht[n].val[i][1] = *p++;
      }
    } else {
      fprintf(stderr,"huffman decodertable error at table %d\n",n);
    }
  }
  return n;
}


static void initialize_huffman() {
  static int   huffman_initialized = FALSE;

  if (huffman_initialized)
    return;
  if (tables_read_decoder_table() != HTN) {
    fprintf(stderr,"decoder table read error\n");
    exit(4);
  }
  huffman_initialized = TRUE;
}


/* do the huffman coding,  */
/* note! for counta,countb - the 4 bit value is passed in y, set x to 0 */
/* return value: 0-no error, 1 decode error                             */
/*
   static void huffman_coder(
   unsigned int x,             // x-value
   unsigned int y,             // y-value
   struct huffcodetab *h,      // pointer to huffman code record
   Bit_stream_struc *bs)       // pointer to open write bitstream
   {
   HUFFBITS huffbits; // data left aligned
   HUFFBITS linbitsX;
   HUFFBITS linbitsY;
   unsigned int len;
   unsigned int xl1 = h->xlen-1;
   unsigned int yl1 = h->ylen-1;
   linbitsX = 0;
   linbitsY = 0;
   if (h->table == NULL) return;
   if (((x < xl1) || (xl1==0)) && (y < yl1)) {
   huffbits = h->table[x*(h->xlen)+y];
   len = h->hlen[x*(h->xlen)+y];
   putbits(bs,huffbits,len);
   return;
   }
   else if (x >= xl1) {
   linbitsX = x-xl1;
   if (linbitsX > h->linmax) {
   fprintf(stderr,"warning: Huffman X table overflow\n");
   linbitsX= h->linmax;
   };
   if (y >= yl1) {
   huffbits = h->table[(h->ylen)*(h->xlen)-1];
   len = h->hlen[(h->ylen)*(h->xlen)-1];
   putbits(bs,huffbits,len);
   linbitsY = y-yl1;
   if (linbitsY > h->linmax) {
   fprintf(stderr,"warning: Huffman Y table overflow\n");
   linbitsY = h->linmax;
   };
   if (h->linbits) {
   putbits(bs,linbitsX,h->linbits);
   putbits(bs,linbitsY,h->linbits);
   }
   }
   else { // x>= h->xlen, y<h->ylen
   huffbits = h->table[(h->ylen)*xl1+y];
   len = h->hlen[(h->ylen)*xl1+y];
   putbits(bs,huffbits,len);
   if (h->linbits) {
   putbits(bs,linbitsX,h->linbits);
   }
   }
   }
   else  { // ((x < h->xlen) && (y>=h->ylen))
   huffbits = h->table[(h->ylen)*x+yl1];
   len = h->hlen[(h->ylen)*x+yl1];
   putbits(bs,huffbits,len);
   linbitsY = y-yl1;
   if (linbitsY > h->linmax) {
   fprintf(stderr,"warning: Huffman Y table overflow\n");
   linbitsY = h->linmax;
   };
   if (h->linbits) {
   putbits(bs,linbitsY,h->linbits);
   }
   }
   }
   */

/*
 *  Do the huffman-decoding
 *  Note! for counta,countb -the 4 bit value is returned in y, discard x
 */
static int huffman_decoder(
    struct huffcodetab *h,      /* pointer to huffman code record*/
    /* unsigned */ int *x,      /* returns decoded x value*/
    /* unsigned */ int *y,      /* returns decoded y value*/
    int *v,
    int *w)
{
  HUFFBITS    level;
  int         point = 0;
  int         error = 1;

  level = dmask;
  if (h->val == NULL)
    return 2;

  /* Table 0 needs no bits */
  if ( h->treelen == 0) {
    *x = *y = 0;
    return 0;
  }

  /* Lookup in Huffman table */

  do {
    if (h->val[point][0]==0) {      /* end of tree */
      *x = h->val[point][1] >> 4;
      *y = h->val[point][1] & 0xf;

      error = 0;
      break;
    }
    if (hget1bit()) {
      while (h->val[point][1] >= MXOFF) point += h->val[point][1];
      point += h->val[point][1];
    } else {
      while (h->val[point][0] >= MXOFF) point += h->val[point][0];
      point += h->val[point][0];
    }
    level >>= 1;
  } while (level || (point < ht->treelen) );

  /* Check for error */

  if (error) { /* set x and y to a medium value as a simple concealment */
    fprintf(stderr, "Illegal Huffman code in data.\n");
    *x = ((h->xlen-1) << 1);
    *y = ((h->ylen-1) << 1);
  }

  /* Process sign encodings for quadruples tables */

  if (h->tablename[0] == '3' && (h->tablename[1] == '2' ||
        h->tablename[1] == '3')) {
    *v = (*y>>3) & 1;
    *w = (*y>>2) & 1;
    *x = (*y>>1) & 1;
    *y = *y & 1;

    /* v, w, x and y are reversed in the bitstream. */
    /* Switch them around to make test bistream work.*/

    /* {int i=*v; *v=*y; *y=i; i=*w; *w=*x; *x=i;}  MI */

    if (*v) {
      if (hget1bit() == 1)
        *v = -*v;
    }
    if (*w) {
      if (hget1bit() == 1)
        *w = -*w;
    }
    if (*x) {
      if (hget1bit() == 1)
        *x = -*x;
    }
    if (*y) {
      if (hget1bit() == 1)
        *y = -*y;
    }
  } else {
    /* Process sign and escape encodings for dual tables */

    /* x and y are reversed in the test bitstream.*/
    /* Reverse x and y here to make test bitstream work.*/

    /*    removed 11/11/92 -ag  
     *      {int i=*x; *x=*y; *y=i;} 
     */

    if (h->linbits)
      if ((h->xlen-1) == *x)
        *x += hgetbits(h->linbits);
    if (*x) {
      if (hget1bit() == 1)
        *x = -*x;
    }
    if (h->linbits)
      if ((h->ylen-1) == *y)
        *y += hgetbits(h->linbits);
    if (*y) {
      if (hget1bit() == 1)
        *y = -*y;
    }
  }
  return error;
}

/*#define OPTIMIZETHIS*/

static void III_hufman_decode(
    long int             is[SBLIMIT][SSLIMIT],
    III_side_info_t     *si,
    int                  ch,
    int                  gr,
    int                  part2_start,
    frame_params        *fr_ps)
{
  int                  i, x, y;
  int                  v, w;
  struct huffcodetab  *h;
  int                  region1Start;
  int                  region2Start;
  int                  sfreq;
  int                  currentBit, grBits;
  my_gr_info          *gi;
#ifdef OPTIMIZETHIS
  long int            *isptr;
#endif
  /*int                bt = (*si).ch[ch].gr[gr].window_switching_flag &&
    ((*si).ch[ch].gr[gr].block_type == 2);*/

  gi = (my_gr_info *) &(*si).ch[ch].gr[gr];
  sfreq = fr_ps->header.sampling_frequency + (fr_ps->header.version * 3);
  initialize_huffman();

  /* Find region boundary for short block case */

  if ( ((*si).ch[ch].gr[gr].window_switching_flag) &&
      ((*si).ch[ch].gr[gr].block_type == 2) ) {

    /* Region2 */
    region1Start = 36;      /* sfb[9/3]*3=36 */
    region2Start = 576;     /* No Region2 for short block case */

  } else {       /* Find region boundary for long block case */

    region1Start = sfBandIndex[sfreq]
      .l[(*si).ch[ch].gr[gr].region0_count + 1]; /* MI */
    region2Start = sfBandIndex[sfreq]
      .l[(*si).ch[ch].gr[gr].region0_count +
      (*si).ch[ch].gr[gr].region1_count + 2]; /* MI */
  }

  grBits     = part2_start + (*si).ch[ch].gr[gr].part2_3_length;
  currentBit = hsstell();

  /* Read bigvalues area */
  for (i = 0; i < (*si).ch[ch].gr[gr].big_values * 2; i += 2) {
    if (i < region1Start)
      h = &ht[(*si).ch[ch].gr[gr].table_select[0]];
    else if (i<region2Start)
      h = &ht[(*si).ch[ch].gr[gr].table_select[1]];
    else
      h = &ht[(*si).ch[ch].gr[gr].table_select[2]];
    huffman_decoder(h, &x, &y, &v, &w);
    is[i / SSLIMIT][i % SSLIMIT] = x;
    is[(i+1) / SSLIMIT][(i+1) % SSLIMIT] = y;
  }

  grBits     = part2_start + (*si).ch[ch].gr[gr].part2_3_length;
  currentBit = hsstell();

  /* Read count1 area */
  h = &ht[(*si).ch[ch].gr[gr].count1table_select + 32];
#ifdef OPTIMIZETHIS
  isptr = &is[i / SSLIMIT][i % SSLIMIT];
  while ((hsstell() < part2_start + (*si).ch[ch].gr[gr].part2_3_length ) &&
      (isptr < &is[SBLIMIT-1][SSLIMIT-1]) ) {
    huffman_decoder(h, (int *)&isptr[2], (int *)&isptr[3],
        (int *)&isptr[0], (int *)&isptr[1]);
    isptr += 4;
  }
#else
  while ((hsstell() < part2_start + (*si).ch[ch].gr[gr].part2_3_length ) &&
      ( i < SSLIMIT*SBLIMIT )) {
    huffman_decoder(h, &x, &y, &v, &w);
    is[i / SSLIMIT][i % SSLIMIT] = v;
    is[(i+1) / SSLIMIT][(i+1) % SSLIMIT] = w;
    is[(i+2) / SSLIMIT][(i+2) % SSLIMIT] = x;
    is[(i+3) / SSLIMIT][(i+3) % SSLIMIT] = y;
    i += 4;
  }
#endif

  grBits     = part2_start + (*si).ch[ch].gr[gr].part2_3_length;
  currentBit = hsstell();

  if (hsstell() > part2_start + (*si).ch[ch].gr[gr].part2_3_length) {
    i -=4;
    rewindNbits(hsstell()-part2_start - (*si).ch[ch].gr[gr].part2_3_length);
  }

  /* Dismiss stuffing Bits */
  grBits     = part2_start + (*si).ch[ch].gr[gr].part2_3_length;
  currentBit = hsstell();
  if ( currentBit < grBits )
    hgetbits( grBits - currentBit );

  /* Zero out rest */
  for (; i < SSLIMIT * SBLIMIT; i++)
    is[i / SSLIMIT][i % SSLIMIT] = 0;
}

/************ Layer I, Layer II & Layer III ******************/

static unsigned int get1bit(Bit_stream_struc *bs);
static unsigned long getbits( Bit_stream_struc *bs, int N);

static void decode_info(
    Bit_stream_struc    *bs,
    frame_params        *fr_ps)
{
  layer *hdr = &fr_ps->header;

  hdr->version        = get1bit(bs);
  hdr->lay            = 4 - getbits(bs,2);
  hdr->error_protection = !get1bit(bs); /* error protect. TRUE/FALSE */
  hdr->bitrate_index  = getbits(bs,4);
  hdr->sampling_frequency = getbits(bs,2);
  hdr->padding        = get1bit(bs);
  hdr->extension      = get1bit(bs);
  hdr->mode = getbits(bs,2);
  hdr->mode_ext       = getbits(bs,2);
  hdr->copyright      = get1bit(bs);
  hdr->original       = get1bit(bs);
  hdr->emphasis       = getbits(bs,2);
}

STATIC struct MP3Data output_0;
STATIC III_scalefac_t scaleFactor_1;
STATIC int scaleFactor_27_phase;
STATIC gr_info_s groupInformation_2[2];
STATIC int groupInformation_28;
STATIC frame_params frameHeader_3;
STATIC int frameHeader_29_phase;
STATIC int channel_4[2];
STATIC int channel_30;
STATIC int scaleFactor_39_phase;
STATIC int groupInformation_40;
STATIC int frameHeader_41_phase;
STATIC int channel_42;
STATIC int output_43;
STATIC int input_46;
STATIC int groupInformation_47;
STATIC int frameHeader_48_phase;
STATIC int groupInformation_50;
STATIC int frameHeader_51_phase;
STATIC int groupInformation_52;
STATIC int channel_53;
STATIC int frameHeader_54_phase;
STATIC int channel_55;
STATIC int output_56;


TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_output;
// ##DEFINE_PORT_SECTION::END


/////////////////////////////////////
// internal variables
/////////////////////////////////////

static Packet1 packet;
static Packet1 packets[2];

/////////////////////////////////////
// init code
/////////////////////////////////////
TASK_INIT
{
  // ##INIT_PORT_SECTION::START
  port_output = PORT_INITIALIZE(TASK_ID, "output");
  // ##INIT_PORT_SECTION::END
  // TODO: task initialize code
  if (bs.pt!=NULL) close_bit_stream_r(&bs);

  //open_bit_stream_r(&bs, "$val(fileName)", $val(bufferSize));

  //frameHeader_3.tab_num=-1;
  packet.frameHeader.tab_num=-1;

  sample_frames_33=0;

  Max_gr_34=0;
  stereo=0;

  gotBits=0;
  bitsPerSlot = 0;
  samplesPerFrame = 0;
  frame_start = 0;


  sync1=0;
  error_protection=0;
  old_crc=0;
  frameBits=0;
  nSlots=0;
  group_35=0;
  group_temp_36=0;
  channelNumber_37=0;
  ss=sb=0;
  main_data_end=0;
  flush_main=0;
  bytes_to_discard=0;

  bs.buf_size=0;
  bs.totbit=0;
  bs.buf_byte_idx=0;
  bs.buf_bit_idx=0;
  bs.mode=READ_MODE;
  bs.eob=0;
  bs.eobs=0;
  bs.format=0;

  offset=0;
  totbit=0;
  buf_byte_idx=0;
  buf_bit_idx=8;



  scaleFactor_27_phase = 0;
  groupInformation_28 = 0;
  frameHeader_29_phase = 0;
  {int i; for(i=0;i<2;i++) channel_4[i] = 0;}
  channel_30 = 0;
  if (bs.pt!=NULL) close_bit_stream_r(&bs);

  open_bit_stream_r(&bs, "./sample.mp3", 4096);
  //frameHeader_3.tab_num=-1;
  packet.frameHeader.tab_num=-1;

  sample_frames_33=0;

  Max_gr_34=0;
  stereo=0;

  gotBits=0;
  bitsPerSlot = 0;
  samplesPerFrame = 0;
  frame_start = 0;
  scaleFactor_39_phase = 0;
  groupInformation_40 = 0;
  frameHeader_41_phase = 0;
  channel_42 = 0;
  output_43 = 0;
  input_46 = 0;
  groupInformation_47 = 0;
  frameHeader_48_phase = 0;
  groupInformation_50 = 0;
  frameHeader_51_phase = 0;
  groupInformation_52 = 0;
  channel_53 = 0;
  frameHeader_54_phase = 0;
  channel_55 = 0;
  output_56 = 0;
}


/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
  // TODO: task main code
  int i=0;
  int terminate = 0; 
  for(i=0; i<2; i++){
    if(terminate == 0){
      if(Max_gr_34 == 0 && stereo==0){
        sync1 = seek_sync(&bs, SYNC_WORD, SYNC_WORD_LNGTH);
        frameBits = sstell(&bs) - gotBits;
        gotBits += frameBits;

        if(!sync1){
          printf("Frame cannot be allocated, input stream may be empty!\n");
          SYS_REQ(END_TASK, "MP3Dec");
          terminate = 1; 
          break;
          // exit(-1);
        }



        decode_info(&bs, &packet.frameHeader);
        hdr_to_frps(&packet.frameHeader);
        stereo = packet.frameHeader.stereo;

        if(packet.frameHeader.header.version == MPEG_PHASE2_LSF)    Max_gr_34 = 1;
        else                                                   Max_gr_34 = 2;

        error_protection = packet.frameHeader.header.error_protection;
        if(error_protection)    buffer_CRC(&bs, &old_crc);

        if(packet.frameHeader.header.lay != 3){
          printf("can only decode layer!\n");
          //exit(-1);
        }

        bitsPerSlot = 8;

        if(packet.frameHeader.header.version == MPEG_PHASE2_LSF)    samplesPerFrame = 576;
        else                                                   samplesPerFrame = 1152;

        III_get_side_info(&bs, &sideInformation_38, &packet.frameHeader);
        nSlots = main_data_slots(packet.frameHeader);

        for(; nSlots > 0; nSlots--)    hputbuf((unsigned int)getbits(&bs, 8), 8);
        main_data_end = hsstell() / 8;

        if ((flush_main = (hsstell() % bitsPerSlot))) {
          hgetbits((int)(bitsPerSlot - flush_main));
          main_data_end ++;
        }
        bytes_to_discard = frame_start - main_data_end - sideInformation_38.main_data_begin ;
        if (main_data_end > 4096) {
          frame_start -= 4096;
          rewindNbytes(4096);
        }

        frame_start += main_data_slots(packet.frameHeader);
        if (bytes_to_discard < 0) {
          printf("not enough main data to decode, frame discarded\n");
        }

        for(; bytes_to_discard > 0; bytes_to_discard--)    hgetbits(8);

        channelNumber_37 = 0;
        group_35=0;
        group_temp_36=0;
      }

      channel_4[channel_30]=channelNumber_37;

      channelNumber_37++;
      group_35 = group_temp_36;

      if ( channelNumber_37 >= 2 ){
        if ( group_temp_36 >= Max_gr_34-1 ) {
          Max_gr_34=0;
          stereo=0;
        } else {
          group_temp_36++;
          channelNumber_37=0;
        }
      }
      tpart2_start_31=hsstell();

      // functions are changed somewhat differently
      if ( packet.frameHeader.header.version!=MPEG_PHASE2_LSF )
        III_get_scale_factors(&packet.scaleFactor,
            &sideInformation_38, group_35, channel_4[channel_30], &packet.frameHeader);
      else
        III_get_LSF_scale_factors(&scaleFactor_1,
            &sideInformation_38, group_35, channel_4[channel_30], &packet.frameHeader);
      III_hufman_decode(packet.output.data, &sideInformation_38, channel_4[channel_30], group_35, tpart2_start_31, &packet.frameHeader);

      packet.groupInformation=sideInformation_38.ch[channel_4[channel_30]].gr[group_35];

      packet.channel = channel_4[channel_30];

      scaleFactor_27_phase = (scaleFactor_27_phase+1)%2;
      frameHeader_29_phase = (frameHeader_29_phase+1)%2;
      groupInformation_28 += 1;
      channel_30 += 1;

      memcpy(&packets[i], &packet, sizeof(Packet1));
    }
  }
  //    printf("VLDStream\n"); fflush(stdout);
  MQ_SEND(port_output, (unsigned char*)&packets, sizeof(Packet1) * 2);
  groupInformation_28 = 0;
  channel_30 = 0;
}



/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
  // TODO: task wrapup code

}

TASK_CODE_END
