/************************************
 *
 * File : De.cic
 * Date : Sep 9, 2012 3:48 PM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "h264decoder.h"
#include "h264dec_struct.h"
// ##DEFINE_SECTION::START
// ##DEFINE_SECTION::END


TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_inFrame;
STATIC int port_outMB_interY;
STATIC int port_outMB_interU;
STATIC int port_outMB_interV;
STATIC int port_outMB_intraY;
STATIC int port_outMB_intraU;
STATIC int port_outMB_intraV;
// ##DEFINE_PORT_SECTION::END


/////////////////////////////////////
// internal variables
/////////////////////////////////////

struct Block4x4 {
	int data[4][4];
};
		
struct intarr4 {
	int data[4];
};

STATIC FramePacket fp;
STATIC MacroBlockPacket_Y mbY;
STATIC MacroBlockPacket_UV mbU;
STATIC MacroBlockPacket_UV mbV;

STATIC FramePacket_Y frameY;
STATIC FramePacket_UV frameU;
STATIC FramePacket_UV frameV;

STATIC FrameInfo fi;
STATIC MotionVector mv[4];
STATIC int mv_idx;

STATIC int ipredmode[IMG_WIDTH/BLOCK_SIZE+2][IMG_HEIGHT/BLOCK_SIZE+2];
STATIC int nz_coeff[IMG_WIDTH/16][IMG_HEIGHT/16][4][6];
STATIC int cof[4][6][4][4];
STATIC int cofu[4];
STATIC int m7[4][4];

STATIC Macroblock *mb_data;
STATIC int (*refFrArr) [IMG_WIDTH/BLOCK_SIZE];
STATIC int (*img_mv)[IMG_HEIGHT/BLOCK_SIZE][3];

extern byte imgUV[2][IMG_HEIGHT/2][IMG_WIDTH/2];

STATIC Bitstream *bstream;
STATIC SliceParams *sliceparams;
STATIC int mb_phase;
STATIC int block_phase;   // 0 --> 15
STATIC int cod_counter;
STATIC int mb_x, mb_y;
STATIC int block_x, block_y;
STATIC int pix_x, pix_y;
STATIC int pix_c_x, pix_c_y;

STATIC int allrefzero;


static void SetMotionVectorPredictor (int             *pmv_x,
                                      int             *pmv_y,
                                      int             ref_frame,
 int refFrArr1[IMG_HEIGHT/BLOCK_SIZE][IMG_WIDTH/BLOCK_SIZE],
 int tmp_mv[IMG_WIDTH/BLOCK_SIZE + 4][IMG_HEIGHT/BLOCK_SIZE][3],
                                      int             block_x,
                                      int             block_y,
                                      int             blockshape_x,
                                      int             blockshape_y);


static int uvlc_startcode_follows(Bitstream *currStream);
static void read_ipred_modes(void);
static void readMotionInfoFromNAL (void);
static void readCBPandCoeffsFromNAL(void);
static void CheckAvailabilityOfNeighbors(void);
static void itransform(int input[4][4], int output[4][4]);
static int get_prev_block(int refframe, int x_pos, int y_pos, int block[4][4]);
static void itrans_2(void);
//static int  sign(int a , int b);


static int  readSyntaxElement_Intra4x4PredictionMode(SyntaxElement *sym, Bitstream *currStream);
static void readCoeff4x4_CAVLC (int block_type, int i, int j, int levarr[16], int runarr[16], int *number_coefficients);

static void get_prev_Ublock(int refframe[4], int x_pos[4], int y_pos[4], int block[4][4]);
static void get_prev_Vblock(int refframe[4], int x_pos[4], int y_pos[4], int block[4][4]);

static int intrapred_luma_16x16(int,int, int[2][17], int[16][16]);


//! single scan pattern
static const byte SNGL_SCAN[16][2] =
{
  {0,0},{1,0},{0,1},{0,2},
  {1,1},{2,0},{3,0},{2,1},
  {1,2},{0,3},{1,3},{2,2},
  {3,1},{3,2},{2,3},{3,3}
};


//! gives CBP value from codeword number, both for intra and inter
static const byte NCBP[48][2]=
{
  {47, 0},{31,16},{15, 1},{ 0, 2},{23, 4},{27, 8},{29,32},{30, 3},{ 7, 5},{11,10},{13,12},{14,15},
  {39,47},{43, 7},{45,11},{46,13},{16,14},{ 3, 6},{ 5, 9},{10,31},{12,35},{19,37},{21,42},{26,44},
  {28,33},{35,34},{37,36},{42,40},{44,39},{ 1,43},{ 2,45},{ 4,46},{ 8,17},{17,18},{18,20},{20,24},
  {24,19},{ 6,21},{ 9,26},{22,28},{25,23},{32,27},{33,29},{34,30},{36,22},{40,25},{38,38},{41,41},
};

//! used to control block sizes : Not used/16x16/16x8/8x16/8x8/8x4/4x8/4x4
static const int BLOCK_STEP[8][2]=
{
  {0,0},{4,4},{4,2},{2,4},{2,2},{2,1},{1,2},{1,1}
};

//! Dequantization coefficients
static const int dequant_coef[6][4][4] = {
  {{10, 13, 10, 13},{ 13, 16, 13, 16},{10, 13, 10, 13},{ 13, 16, 13, 16}},
  {{11, 14, 11, 14},{ 14, 18, 14, 18},{11, 14, 11, 14},{ 14, 18, 14, 18}},
  {{13, 16, 13, 16},{ 16, 20, 16, 20},{13, 16, 13, 16},{ 16, 20, 16, 20}},
  {{14, 18, 14, 18},{ 18, 23, 18, 23},{14, 18, 14, 18},{ 18, 23, 18, 23}},
  {{16, 20, 16, 20},{ 20, 25, 20, 25},{16, 20, 16, 20},{ 20, 25, 20, 25}},
  {{18, 23, 18, 23},{ 23, 29, 23, 29},{18, 23, 18, 23},{ 23, 29, 23, 29}}
};

static const byte QP_SCALE_CR[52]=
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,
   12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
   28,29,29,30,31,32,32,33,34,34,35,35,36,36,37,37,
   37,38,38,38,39,39,39,39
};


//! for the linfo_levrun_inter routine
static const byte NTAB1[4][8][2] =
{
  {{1,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}},
  {{1,1},{1,2},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}},
  {{2,0},{1,3},{1,4},{1,5},{0,0},{0,0},{0,0},{0,0}},
  {{3,0},{2,1},{2,2},{1,6},{1,7},{1,8},{1,9},{4,0}},
};
static const byte LEVRUN1[16]=
{
  4,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,
};


//! for the linfo_levrun__c2x2 routine
static const byte LEVRUN3[4] =
{
  2,1,0,0
};
static const byte NTAB3[2][2][2] =
{
  {{1,0},{0,0}},
  {{2,0},{1,1}},
};


//char errortext[ET_SIZE];
/*!
 ************************************************************************
 * \brief
 *    Error handling procedure. Print error message to stderr and exit
 *    with supplied code.
 * \param text
 *    Error message
 ************************************************************************
 */

static void error(char *text, int code)
{
  //fprintf(stderr, "%s\n", text);
  //exit(code);
  printf("%s\n", text);
}


/*!
 ************************************************************************
 * \brief
 *    Exit program if memory allocation failed (using error())
 * \param where
 *    string indicating which memory allocation failed
 ************************************************************************
 */
static void no_mem_exit(char *where)
{
//   snprintf(errortext, ET_SIZE, "Could not allocate memory: %s",where);
   error (where, 100);
}


/*!
 ************************************************************************
 * \brief
 *  Reads bits from the bitstream buffer
 *
 * \param byte buffer[]
 *    containing VLC-coded data bits
 * \param int totbitoffset
 *    bit offset from start of partition
 * \param int bytecount
 *    total bytes in bitstream
 * \param int numbits
 *    number of bits to read
 *
 ************************************************************************
 */

static int ShowBits (byte buffer[],int totbitoffset,int bytecount, int numbits)
{

  register int inf;
  long byteoffset;      // byte from start of buffer
  int bitoffset;      // bit from start of byte

  byteoffset= totbitoffset/8;
  bitoffset= 7-(totbitoffset%8);

  inf=0;
  while (numbits)
  {
    inf <<=1;
    inf |= (buffer[byteoffset] & (0x01<<bitoffset))>>bitoffset;
    numbits--;
    bitoffset--;
    if (bitoffset < 0)
    {
      byteoffset++;
      bitoffset += 8;
      if (byteoffset > bytecount)
      {
        return -1;
      }
    }
  }

  return inf;           // return absolute offset in bit from start of frame
}     




/////////////////////////
// vlc.c ////////////////
/////////////////////////

/*!
 ************************************************************************
 * \brief
 *    mapping rule for ue(v) syntax elements
 * \par Input:
 *    lenght and info
 * \par Output:
 *    number in the code table
 ************************************************************************
 */
static void linfo_ue(int len, int info, int *value1, int *dummy)
{
//  *value1 = (int)pow(2,(len/2))+info-1; // *value1 = (int)(2<<(len>>1))+info-1;
  *value1 = (int)(1<<(len>>1))+info-1; 
}

/*!
 ************************************************************************
 * \brief
 *    mapping rule for se(v) syntax elements
 * \par Input:
 *    lenght and info
 * \par Output:
 *    signed mvd
 ************************************************************************
 */
static void linfo_se(int len,  int info, int *value1, int *dummy)
{
  int n;
//  n = (int)pow(2,(len/2))+info-1;
  int len2 = len/2;
  if (len2<0) {
          len2 = -len2;
          n = (int)(1>>len2)+info-1;
  }
  else
          n = (int)(1<<len2)+info-1;

  *value1 = (n+1)/2;
  if((n & 0x01)==0)                           // lsb is signed bit
    *value1 = -*value1;
}

/*!
 ************************************************************************
 * \brief
 *  Moves the read pointer of the partition forward by one symbol
 *
 * \param byte buffer[]
 *    containing VLC-coded data bits
 * \param int totbitoffset
 *    bit offset from start of partition
 * \param int type
 *    expected data type (Partiotion ID)
 * \return  int info, len
 *    Length and Value of the next symbol
 *
 * \note
 *    As in both nal_bits.c and nal_part.c all data of one partition, slice,
 *    picture was already read into a buffer, there is no need to read any data
 *    here again.
 * \par
 *    GetVLCInfo was extracted because there should be only one place in the
 *    source code that has knowledge about symbol extraction, regardless of
 *    the number of different NALs.
 * \par
 *    This function could (and should) be optimized considerably
 * \par
 *    If it is ever decided to have different VLC tables for different symbol
 *    types, then this would be the place for the implementation
 * \par
 *    An alternate VLC table is implemented based on exponential Golomb codes.
 *    The encoder must have a matching define selected.
 *  
 ************************************************************************
 */
static int GetVLCSymbol (byte buffer[],int totbitoffset,int *info, int bytecount)
{

  register int inf;
  long byteoffset;      // byte from start of buffer
  int bitoffset;      // bit from start of byte
  int ctr_bit=0;      // control bit for current bit posision
  int bitcounter=1;
  int len;
  int info_bit;

  byteoffset= totbitoffset/8;
  bitoffset= 7-(totbitoffset%8);
  ctr_bit = (buffer[byteoffset] & (0x01<<bitoffset));   // set up control bit

  len=1;
  while (ctr_bit==0)
  {                 // find leading 1 bit
    len++;
    bitoffset-=1;           
    bitcounter++;
    if (bitoffset<0)
    {                 // finish with current byte ?
      bitoffset=bitoffset+8;
      byteoffset++;
    }
    ctr_bit=buffer[byteoffset] & (0x01<<(bitoffset));
  }
    // make infoword
  inf=0;                          // shortest possible code is 1, then info is always 0
  for(info_bit=0;(info_bit<(len-1)); info_bit++)
  {
    bitcounter++;
    bitoffset-=1;
    if (bitoffset<0)
    {                 // finished with current byte ?
      bitoffset=bitoffset+8;
      byteoffset++;
    }
    if (byteoffset > bytecount)
    {
      return -1;
    }
    inf=(inf<<1);
    if(buffer[byteoffset] & (0x01<<(bitoffset)))
      inf |=1;
  }

  *info = inf;
  return bitcounter;           // return absolute offset in bit from start of frame
}


/*!
 ************************************************************************
 * \brief
 *  Reads bits from the bitstream buffer
 *
 * \param byte buffer[]
 *    containing VLC-coded data bits
 * \param int totbitoffset
 *    bit offset from start of partition
 * \param int bytecount
 *    total bytes in bitstream
 * \param int numbits
 *    number of bits to read
 *
 ************************************************************************
 */


static int GetBits (byte buffer[],int totbitoffset,int *info, int bytecount, 
             int numbits)
{

  register int inf;
  long byteoffset;      // byte from start of buffer
  int bitoffset;      // bit from start of byte

  int bitcounter=numbits;

  byteoffset= totbitoffset/8;
  bitoffset= 7-(totbitoffset%8);

  inf=0;
  while (numbits)
  {
    inf <<=1;
    inf |= (buffer[byteoffset] & (0x01<<bitoffset))>>bitoffset;
    numbits--;
    bitoffset--;
    if (bitoffset < 0)
    {
      byteoffset++;
      bitoffset += 8;
      if (byteoffset > bytecount)
      {
        return -1;
      }
    }
  }

  *info = inf;
  return bitcounter;           // return absolute offset in bit from start of frame
}     



/*!
 ************************************************************************
 * \brief
 *    read FLC codeword from UVLC-partition 
 ************************************************************************
 */
static int readSyntaxElement_FLC(SyntaxElement *sym, Bitstream *currStream)
{
  int frame_bitoffset = currStream->frame_bitoffset;
  byte *buf = currStream->streamBuffer;
  int BitstreamLengthInBytes = currStream->bitstream_length;

  if ((GetBits(buf, frame_bitoffset, &(sym->inf), BitstreamLengthInBytes, sym->len)) < 0)
    return -1;

  currStream->frame_bitoffset += sym->len; // move bitstream pointer
  sym->value1 = sym->inf;

  return 1;
}




/*!
 ************************************************************************
 * \par Input:
 *    lenght and info
 * \par Output:
 *    cbp (intra)
 ************************************************************************
 */
static void linfo_cbp_intra(int len,int info,int *cbp, int *dummy)
{
//  extern const byte NCBP[48][2];
    int cbp_idx;
  linfo_ue(len,info,&cbp_idx,dummy);
    *cbp=NCBP[cbp_idx][0];
}

/*!
 ************************************************************************
 * \par Input:
 *    lenght and info
 * \par Output:
 *    cbp (inter)
 ************************************************************************
 */
static void linfo_cbp_inter(int len,int info,int *cbp, int *dummy)
{
//  extern const byte NCBP[48][2];
  int cbp_idx;
  linfo_ue(len,info,&cbp_idx,dummy);
    *cbp=NCBP[cbp_idx][1];
}


/*!
 ************************************************************************
 * \brief
 *    read next UVLC codeword from UVLC-partition and
 *    map it to the corresponding syntax element
 ************************************************************************
 */
static int readSyntaxElement_UVLC(SyntaxElement *sym, Bitstream *currStream)
{
  //Bitstream   *currStream = dP->bitstream;
  int frame_bitoffset = currStream->frame_bitoffset;
  byte *buf = currStream->streamBuffer;
  int BitstreamLengthInBytes = currStream->bitstream_length;

  sym->len =  GetVLCSymbol (buf, frame_bitoffset, &(sym->inf), BitstreamLengthInBytes);
  if (sym->len == -1)
    return -1;
  currStream->frame_bitoffset += sym->len;
  sym->mapping(sym->len,sym->inf,&(sym->value1),&(sym->value2));

  return 1;
}


static int GetVLCSymbol_IntraMode (byte buffer[],int totbitoffset,int *info, int bytecount)
{

  register int inf;
  long byteoffset;      // byte from start of buffer
  int bitoffset;      // bit from start of byte
  int ctr_bit=0;      // control bit for current bit posision
  int bitcounter=1;
  int len;
  int info_bit;

  byteoffset = totbitoffset/8;
  bitoffset  = 7-(totbitoffset%8);
  ctr_bit    = (buffer[byteoffset] & (0x01<<bitoffset));   // set up control bit
  len        = 1;

  //First bit
  if (ctr_bit)
  {
    *info = 0;
    return bitcounter;
  }
  else
    len=4;

  // make infoword
  inf=0;                          // shortest possible code is 1, then info is always 0
  for(info_bit=0;(info_bit<(len-1)); info_bit++)
  {
    bitcounter++;
    bitoffset-=1;
    if (bitoffset<0)
    {                 // finished with current byte ?
      bitoffset=bitoffset+8;
      byteoffset++;
    }
    if (byteoffset > bytecount)
    {
      return -1;
    }
    inf=(inf<<1);
    if(buffer[byteoffset] & (0x01<<(bitoffset)))
      inf |=1;
  }

  *info = inf;
  return bitcounter;           // return absolute offset in bit from start of frame
}

/*!
 ************************************************************************
 * \brief
 *    read next VLC codeword for 4x4 Intra Prediction Mode and
 *    map it to the corresponding Intra Prediction Direction
 ************************************************************************
 */
static int readSyntaxElement_Intra4x4PredictionMode(SyntaxElement *sym, Bitstream *currStream)
{
  //Bitstream   *currStream            = dP->bitstream;
  int         frame_bitoffset        = currStream->frame_bitoffset;
  byte        *buf                   = currStream->streamBuffer;
  int         BitstreamLengthInBytes = currStream->bitstream_length;

  sym->len = GetVLCSymbol_IntraMode (buf, frame_bitoffset, &(sym->inf), BitstreamLengthInBytes);

  if (sym->len == -1)
    return -1;

  currStream->frame_bitoffset += sym->len;
  sym->value1                  = sym->len == 1 ? -1 : sym->inf;

  return 1;
}


/*!
 ************************************************************************
 * \brief
 *    test if bit buffer contains only stop bit
 *
 * \param byte buffer[]
 *    containing VLC-coded data bits
 * \param int totbitoffset
 *    bit offset from start of partition
 * \param int bytecont
 *    buffer length
 ************************************************************************
 */
static int more_rbsp_data (byte buffer[],int totbitoffset,int bytecount)
{

  long byteoffset;      // byte from start of buffer
  int bitoffset;      // bit from start of byte
  int ctr_bit=0;      // control bit for current bit posision

  int cnt=0;

  
  byteoffset= totbitoffset/8;
  bitoffset= 7-(totbitoffset%8);

  assert (byteoffset<bytecount);

  // there is more until we're in the last byte
  if (byteoffset<(bytecount-1)) return TRUE;

  // read one bit
  ctr_bit = (buffer[byteoffset] & (0x01<<bitoffset));
  
  // a stop bit has to be one
  if (ctr_bit==0) return TRUE;

  bitoffset--;

  while (bitoffset>=0)
  {
    ctr_bit = (buffer[byteoffset] & (0x01<<bitoffset));   // set up control bit
    if (ctr_bit>0) cnt++;
    bitoffset--;
  }

  return (0!=cnt);

}


/*!
 ************************************************************************
 * \brief
 *    Check if there are symbols for the next MB
 ************************************************************************
 */
static int uvlc_startcode_follows(Bitstream *currStream)
{
  //Bitstream   *currStream = dP->bitstream;
  byte *buf = currStream->streamBuffer;

  //KS: new function test for End of Buffer
  return (!(more_rbsp_data(buf, currStream->frame_bitoffset,currStream->bitstream_length)));
}

/*!
 ************************************************************************
 * \brief
 *    code from bitstream (2d tables)
 ************************************************************************
 */

static int code_from_bitstream_2d(SyntaxElement *sym, Bitstream *currStream,
                           int *lentab,
                           int *codtab,
                           int tabwidth,
                           int tabheight,
                           int *code)
{
  //Bitstream   *currStream = dP->bitstream;
  int frame_bitoffset = currStream->frame_bitoffset;
  byte *buf = currStream->streamBuffer;
  int BitstreamLengthInBytes = currStream->bitstream_length;

  int i,j;
  int len, cod;

  // this VLC decoding method is not optimized for speed
  for (j = 0; j < tabheight; j++) {
    for (i = 0; i < tabwidth; i++)
    {
      len = lentab[i];
      if (!len)
        continue;
      cod = codtab[i];

      if ((ShowBits(buf, frame_bitoffset, BitstreamLengthInBytes, len) == cod))
      {
        sym->value1 = i;
        sym->value2 = j;
        currStream->frame_bitoffset += len; // move bitstream pointer
        sym->len = len;
        goto found_code;
      }
    }
    lentab += tabwidth;
    codtab += tabwidth;
  }
  
  return -1;  // failed to find code

found_code:

  *code = cod;

  return 0;
}

/*!
 ************************************************************************
 * \brief
 *    read NumCoeff/TrailingOnes codeword from UVLC-partition 
 ************************************************************************
 */

static int readSyntaxElement_NumCoeffTrailingOnes(SyntaxElement *sym,
	Bitstream *currStream, char *type)
{
  //Bitstream   *currStream = dP->bitstream;
  int frame_bitoffset = currStream->frame_bitoffset;
  byte *buf = currStream->streamBuffer;
  int BitstreamLengthInBytes = currStream->bitstream_length;

  int vlcnum, retval;
  int code, *ct, *lt;

  int lentab[3][4][17] = 
  {
    {   // 0702
      { 1, 6, 8, 9,10,11,13,13,13,14,14,15,15,16,16,16,16},
      { 0, 2, 6, 8, 9,10,11,13,13,14,14,15,15,15,16,16,16},
      { 0, 0, 3, 7, 8, 9,10,11,13,13,14,14,15,15,16,16,16},
      { 0, 0, 0, 5, 6, 7, 8, 9,10,11,13,14,14,15,15,16,16},
    },                                                 
    {                                                  
      { 2, 6, 6, 7, 8, 8, 9,11,11,12,12,12,13,13,13,14,14},
      { 0, 2, 5, 6, 6, 7, 8, 9,11,11,12,12,13,13,14,14,14},
      { 0, 0, 3, 6, 6, 7, 8, 9,11,11,12,12,13,13,13,14,14},
      { 0, 0, 0, 4, 4, 5, 6, 6, 7, 9,11,11,12,13,13,13,14},
    },                                                 
    {                                                  
      { 4, 6, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9,10,10,10,10},
      { 0, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 9,10,10,10},
      { 0, 0, 4, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,10},
      { 0, 0, 0, 4, 4, 4, 4, 4, 5, 6, 7, 8, 8, 9,10,10,10},
    },

  };

  int codtab[3][4][17] = 
  {
    {
      { 1, 5, 7, 7, 7, 7,15,11, 8,15,11,15,11,15,11, 7,4}, 
      { 0, 1, 4, 6, 6, 6, 6,14,10,14,10,14,10, 1,14,10,6}, 
      { 0, 0, 1, 5, 5, 5, 5, 5,13, 9,13, 9,13, 9,13, 9,5}, 
      { 0, 0, 0, 3, 3, 4, 4, 4, 4, 4,12,12, 8,12, 8,12,8},
    },
    {
      { 3,11, 7, 7, 7, 4, 7,15,11,15,11, 8,15,11, 7, 9,7}, 
      { 0, 2, 7,10, 6, 6, 6, 6,14,10,14,10,14,10,11, 8,6}, 
      { 0, 0, 3, 9, 5, 5, 5, 5,13, 9,13, 9,13, 9, 6,10,5}, 
      { 0, 0, 0, 5, 4, 6, 8, 4, 4, 4,12, 8,12,12, 8, 1,4},
    },
    {
      {15,15,11, 8,15,11, 9, 8,15,11,15,11, 8,13, 9, 5,1}, 
      { 0,14,15,12,10, 8,14,10,14,14,10,14,10, 7,12, 8,4},
      { 0, 0,13,14,11, 9,13, 9,13,10,13, 9,13, 9,11, 7,3},
      { 0, 0, 0,12,11,10, 9, 8,13,12,12,12, 8,12,10, 6,2},
    },
  };

  vlcnum = sym->value1;

  if (vlcnum == 3)
  {
    // read 6 bit FLC
    code = ShowBits(buf, frame_bitoffset, BitstreamLengthInBytes, 6);
    currStream->frame_bitoffset += 6;
    sym->value2 = code & 3;
    sym->value1 = (code >> 2);

    if (!sym->value1 && sym->value2 == 3)
    {
      // #c = 0, #t1 = 3 =>  #c = 0
      sym->value2 = 0;
    }
    else
      sym->value1++;

    sym->len = 6;

    retval = 0;
  }
  else

  {
    lt = &lentab[vlcnum][0][0];
    ct = &codtab[vlcnum][0][0];
    retval = code_from_bitstream_2d(sym, currStream, lt, ct, 17, 4, &code);
  }

  if (retval)
  {
    printf("ERROR: failed to find NumCoeff/TrailingOnes\n");
    exit(-1);
  }

  return retval;
}


/*!
 ************************************************************************
 * \brief
 *    read NumCoeff/TrailingOnes codeword from UVLC-partition ChromaDC
 ************************************************************************
 */
static int readSyntaxElement_NumCoeffTrailingOnesChromaDC(SyntaxElement *sym, Bitstream *currStream)
{
  int retval;
  int code, *ct, *lt;

  int lentab[4][5] = 
  {
    { 2, 6, 6, 6, 6,},          
    { 0, 1, 6, 7, 8,}, 
    { 0, 0, 3, 7, 8,}, 
    { 0, 0, 0, 6, 7,},
  };

  int codtab[4][5] = 
  {
    {1,7,4,3,2},
    {0,1,6,3,3},
    {0,0,1,2,2},
    {0,0,0,5,0},
  };



  lt = &lentab[0][0];
  ct = &codtab[0][0];

  retval = code_from_bitstream_2d(sym, currStream, lt, ct, 5, 4, &code);

  if (retval)
  {
    printf("ERROR: failed to find NumCoeff/TrailingOnes ChromaDC\n");
    exit(-1);
  }

  return retval;
}




/*!
 ************************************************************************
 * \brief
 *    read Level VLC0 codeword from UVLC-partition 
 ************************************************************************
 */
static int readSyntaxElement_Level_VLC0(SyntaxElement *sym, Bitstream *currStream)
{
  //Bitstream   *currStream = dP->bitstream;
  int frame_bitoffset = currStream->frame_bitoffset;
  byte *buf = currStream->streamBuffer;
  int BitstreamLengthInBytes = currStream->bitstream_length;
  int len, sign, level, code;

  len = 0;
  while (!ShowBits(buf, frame_bitoffset+len, BitstreamLengthInBytes, 1))
    len++;

  len++;
  code = 1;
  frame_bitoffset += len;

  if (len < 15)
  {
    sign = (len - 1) & 1;
    level = (len-1) / 2 + 1;
  }
  else if (len == 15)
  {
    // escape code
    code = (code << 4) | ShowBits(buf, frame_bitoffset, BitstreamLengthInBytes, 4);
    len += 4;
    frame_bitoffset += 4;
    sign = (code & 1);
    level = ((code >> 1) & 0x7) + 8;
  }
  else if (len == 16)
  {
    // escape code
    code = (code << 12) | ShowBits(buf, frame_bitoffset, BitstreamLengthInBytes, 12);
    len += 12;
    frame_bitoffset += 12;
    sign =  (code & 1);
    level = ((code >> 1) & 0x7ff) + 16;
  }
  else
  {
    printf("ERROR reading Level code\n");
    exit(-1);
  }

  if (sign)
    level = -level;

  sym->inf = level;
  sym->len = len;

  currStream->frame_bitoffset = frame_bitoffset;
  return 0;

}

/*!
 ************************************************************************
 * \brief
 *    read Level VLC codeword from UVLC-partition 
 ************************************************************************
 */
static int readSyntaxElement_Level_VLCN(SyntaxElement *sym, int vlc, Bitstream *currStream)  
{
  //Bitstream   *currStream = dP->bitstream;
  int frame_bitoffset = currStream->frame_bitoffset;
  byte *buf = currStream->streamBuffer;
  int BitstreamLengthInBytes = currStream->bitstream_length;
  
  int levabs, sign;
  int len = 0;
  int code, sb;
  
  int numPrefix;
  int shift = vlc-1;
  int escape = (15<<shift)+1;
  
  // read pre zeros
  numPrefix = 0;
  while (!ShowBits(buf, frame_bitoffset+numPrefix, BitstreamLengthInBytes, 1))
    numPrefix++;
  
  
  len = numPrefix+1;
  code = 1;
  
  if (numPrefix < 15)
  {
    levabs = (numPrefix<<shift) + 1;
    
    // read (vlc-1) bits -> suffix
    if (vlc-1)
    {
      sb =  ShowBits(buf, frame_bitoffset+len, BitstreamLengthInBytes, vlc-1);
      code = (code << (vlc-1) )| sb;
      levabs += sb;
      len += (vlc-1);
    }
    
    // read 1 bit -> sign
    sign = ShowBits(buf, frame_bitoffset+len, BitstreamLengthInBytes, 1);
    code = (code << 1)| sign;
    len ++;
  }
  else  // escape
  {
    // read 11 bits -> levabs
    // levabs += escape
    sb = ShowBits(buf, frame_bitoffset+len, BitstreamLengthInBytes, 11);
    code = (code << 11 )| sb;
    
    levabs =  sb + escape;
    len+=11;
    
    // read 1 bit -> sign
    sign = ShowBits(buf, frame_bitoffset+len, BitstreamLengthInBytes, 1);
    code = (code << 1)| sign;
    len++;
  }
  
  sym->inf = (sign)?-levabs:levabs;
  sym->len = len;
  
  currStream->frame_bitoffset = frame_bitoffset+len;
  
  return 0;
}

/*!
 ************************************************************************
 * \brief
 *    read Total Zeros codeword from UVLC-partition 
 ************************************************************************
 */
static int readSyntaxElement_TotalZeros(SyntaxElement *sym, Bitstream *currStream)
{
  int vlcnum, retval;
  int code, *ct, *lt;

  int lentab[TOTRUN_NUM][16] = 
  {
    
    { 1,3,3,4,4,5,5,6,6,7,7,8,8,9,9,9},  
    { 3,3,3,3,3,4,4,4,4,5,5,6,6,6,6},  
    { 4,3,3,3,4,4,3,3,4,5,5,6,5,6},  
    { 5,3,4,4,3,3,3,4,3,4,5,5,5},  
    { 4,4,4,3,3,3,3,3,4,5,4,5},  
    { 6,5,3,3,3,3,3,3,4,3,6},  
    { 6,5,3,3,3,2,3,4,3,6},  
    { 6,4,5,3,2,2,3,3,6},  
    { 6,6,4,2,2,3,2,5},  
    { 5,5,3,2,2,2,4},  
    { 4,4,3,3,1,3},  
    { 4,4,2,1,3},  
    { 3,3,1,2},  
    { 2,2,1},  
    { 1,1},  
  };

  int codtab[TOTRUN_NUM][16] = 
  {
    {1,3,2,3,2,3,2,3,2,3,2,3,2,3,2,1},
    {7,6,5,4,3,5,4,3,2,3,2,3,2,1,0},
    {5,7,6,5,4,3,4,3,2,3,2,1,1,0},
    {3,7,5,4,6,5,4,3,3,2,2,1,0},
    {5,4,3,7,6,5,4,3,2,1,1,0},
    {1,1,7,6,5,4,3,2,1,1,0},
    {1,1,5,4,3,3,2,1,1,0},
    {1,1,1,3,3,2,2,1,0},
    {1,0,1,3,2,1,1,1,},
    {1,0,1,3,2,1,1,},
    {0,1,1,2,1,3},
    {0,1,1,1,1},
    {0,1,1,1},
    {0,1,1},
    {0,1},  
  };
  vlcnum = sym->value1;

  lt = &lentab[vlcnum][0];
  ct = &codtab[vlcnum][0];

  retval = code_from_bitstream_2d(sym, currStream, lt, ct, 16, 1, &code);

  if (retval)
  {
    printf("ERROR: failed to find Total Zeros\n");
    exit(-1);
  }

  return retval;
}    

/*!
 ************************************************************************
 * \brief
 *    read Total Zeros Chroma DC codeword from UVLC-partition 
 ************************************************************************
 */
static int readSyntaxElement_TotalZerosChromaDC(SyntaxElement *sym, Bitstream *currStream)
{
  int vlcnum, retval;
  int code, *ct, *lt;

  int lentab[3][4] = 
  {
    { 1, 2, 3, 3,},
    { 1, 2, 2, 0,},
    { 1, 1, 0, 0,}, 
  };

  int codtab[3][4] = 
  {
    { 1, 1, 1, 0,},
    { 1, 1, 0, 0,},
    { 1, 0, 0, 0,},
  };

  vlcnum = sym->value1;

  lt = &lentab[vlcnum][0];
  ct = &codtab[vlcnum][0];

  retval = code_from_bitstream_2d(sym, currStream, lt, ct, 4, 1, &code);

  if (retval)
  {
    printf("ERROR: failed to find Total Zeros\n");
    exit(-1);
  }

  return retval;
}    


/*!
 ************************************************************************
 * \brief
 *    read  Run codeword from UVLC-partition 
 ************************************************************************
 */
static int readSyntaxElement_Run(SyntaxElement *sym, Bitstream *currStream)
{
  int vlcnum, retval;
  int code, *ct, *lt;

  int lentab[TOTRUN_NUM][16] = 
  {
    {1,1},
    {1,2,2},
    {2,2,2,2},
    {2,2,2,3,3},
    {2,2,3,3,3,3},
    {2,3,3,3,3,3,3},
    {3,3,3,3,3,3,3,4,5,6,7,8,9,10,11},
  };

  int codtab[TOTRUN_NUM][16] = 
  {
    {1,0},
    {1,1,0},
    {3,2,1,0},
    {3,2,1,1,0},
    {3,2,3,2,1,0},
    {3,0,1,3,2,5,4},
    {7,6,5,4,3,2,1,1,1,1,1,1,1,1,1},
  };

  vlcnum = sym->value1;

  lt = &lentab[vlcnum][0];
  ct = &codtab[vlcnum][0];

  retval = code_from_bitstream_2d(sym, currStream, lt, ct, 16, 1, &code);

  if (retval)
  {
    printf("ERROR: failed to find Run\n");
    exit(-1);
  }

  return retval;
}    


#define DQ_BITS         6
#define DQ_ROUND        (1<<(DQ_BITS-1))


#define Q_BITS          15

static const int quant_coef[6][4][4] = {
  {{13107, 8066,13107, 8066},{ 8066, 5243, 8066, 5243},{13107, 8066,13107, 8066},{ 8066, 5243, 8066, 5243}},
  {{11916, 7490,11916, 7490},{ 7490, 4660, 7490, 4660},{11916, 7490,11916, 7490},{ 7490, 4660, 7490, 4660}},
  {{10082, 6554,10082, 6554},{ 6554, 4194, 6554, 4194},{10082, 6554,10082, 6554},{ 6554, 4194, 6554, 4194}},
  {{ 9362, 5825, 9362, 5825},{ 5825, 3647, 5825, 3647},{ 9362, 5825, 9362, 5825},{ 5825, 3647, 5825, 3647}},
  {{ 8192, 5243, 8192, 5243},{ 5243, 3355, 5243, 3355},{ 8192, 5243, 8192, 5243},{ 5243, 3355, 5243, 3355}},
  {{ 7282, 4559, 7282, 4559},{ 4559, 2893, 4559, 2893},{ 7282, 4559, 7282, 4559},{ 4559, 2893, 4559, 2893}}
};


// Notation for comments regarding prediction and predictors.
// The pels of the 4x4 block are labelled a..p. The predictor pels above
// are labelled A..H, from the left I..L, and from above left X, as follows:
//
//  X A B C D E F G H
//  I a b c d
//  J e f g h
//  K i j k l
//  L m n o p
//

// Predictor array index definitions
#define P_X (PredPel[0])
#define P_A (PredPel[1])
#define P_B (PredPel[2])
#define P_C (PredPel[3])
#define P_D (PredPel[4])
#define P_E (PredPel[5])
#define P_F (PredPel[6])
#define P_G (PredPel[7])
#define P_H (PredPel[8])
#define P_I (PredPel[9])
#define P_J (PredPel[10])
#define P_K (PredPel[11])
#define P_L (PredPel[12])


static int preintrapred(
  int img_block_x,      //!< location of block X, multiples of 4
  int img_block_y,      //!< location of block Y, multiples of 4
  int available[4])
{
  int i,j;
  int img_y,img_x;

  int block_available_up;
  int block_available_up_right;
  int block_available_left;
  int block_available_up_left; // new

  byte predmode = ipredmode[img_block_x+1][img_block_y+1];

  img_x=img_block_x*4;
  img_y=img_block_y*4;
  block_available_up        = (ipredmode[img_block_x+1][img_block_y] >=0);              /// can use frm
  block_available_up_right  = (ipredmode[img_block_x+2][img_block_y] >=0); // ???  /// can use frm
  block_available_left      = (ipredmode[img_block_x][img_block_y+1] >=0);            /// can use frm
  block_available_up_left   = (ipredmode[img_block_x][img_block_y] >=0);


  i = (img_x & 15);
  j = (img_y & 15);
  if (block_available_up_right)
  {
    if ((i == 4  && j == 4) ||
        (i == 12 && j == 4) ||
        (i == 12 && j == 8) ||
        (i == 4  && j == 12) ||
        (i == 12 && j == 12))
    {
      block_available_up_right = 0;
    }
  }

  available[0] = block_available_up;
  available[1] = block_available_up_right;
  available[2] = block_available_left;
  available[3] = block_available_up_left;

  // form predictor pels
  /*
  if (block_available_up)
  {
    P_A = imgY[img_y-1][img_x+0];
    P_B = imgY[img_y-1][img_x+1];
    P_C = imgY[img_y-1][img_x+2];
    P_D = imgY[img_y-1][img_x+3];

    if (block_available_up_right)
    {
      P_E = imgY[img_y-1][img_x+4];
      P_F = imgY[img_y-1][img_x+5];
      P_G = imgY[img_y-1][img_x+6];
      P_H = imgY[img_y-1][img_x+7];
    }
    else
    {
      P_E = P_F = P_G = P_H = P_D;
    }
  }
  else
  {
    P_A = P_B = P_C = P_D = P_E = P_F = P_G = P_H = 128;
  }

  if (block_available_left)
  {
    P_I = imgY[img_y+0][img_x-1];
    P_J = imgY[img_y+1][img_x-1];
    P_K = imgY[img_y+2][img_x-1];
    P_L = imgY[img_y+3][img_x-1];
  }
  else
  {
    P_I = P_J = P_K = P_L = 128;
  }

  if (block_available_up_left)
  {
    P_X = imgY[img_y-1][img_x-1];
  }
  else
  {
    P_X = 128;
  }
  */

  return predmode;
  
}



/*!
 ***********************************************************************
 * \brief
 *    invers  transform
 ***********************************************************************
 */
static void itrans_2(void) //!< image parameters
{
  int i,j,i1,j1;
  int M5[4];
  int M6[4];

  int qp_per = (sliceparams->qp-MIN_QP)/6;
  int qp_rem = (sliceparams->qp-MIN_QP)%6;

  // horizontal
  for (j=0;j<4;j++)
  {
    for (i=0;i<4;i++)
      M5[i]=cof[i][j][0][0];

    M6[0]=M5[0]+M5[2];
    M6[1]=M5[0]-M5[2];
    M6[2]=M5[1]-M5[3];
    M6[3]=M5[1]+M5[3];

    for (i=0;i<2;i++)
    {
      i1=3-i;
      cof[i ][j][0][0]= M6[i]+M6[i1];
      cof[i1][j][0][0]=M6[i]-M6[i1];
    }
  }

  // vertical
  for (i=0;i<4;i++)
  {
    for (j=0;j<4;j++)
      M5[j]=cof[i][j][0][0];

    M6[0]=M5[0]+M5[2];
    M6[1]=M5[0]-M5[2];
    M6[2]=M5[1]-M5[3];
    M6[3]=M5[1]+M5[3];

    for (j=0;j<2;j++)
    {
      j1=3-j;
      cof[i][j][0][0] = (((M6[j]+M6[j1])*dequant_coef[qp_rem][0][0]<<qp_per)+2)>>2;
      cof[i][j1][0][0]= (((M6[j]-M6[j1])*dequant_coef[qp_rem][0][0]<<qp_per)+2)>>2;
    }
  }
}


/*
static int sign(int a , int b)
{
  int x;

  x=abs(a);
  if (b>0)
    return(x);
  else return(-x);
}
*/


/*!
 ************************************************************************
 * \brief
 *    Checks the availability of neighboring macroblocks of
 *    the current macroblock for prediction and context determination;
 *    marks the unavailable MBs for intra prediction in the
 *    ipredmode-array by -1. Only neighboring MBs in the causal
 *    past of the current MB are checked.
 ************************************************************************
 */

//GB
static void CheckAvailabilityOfNeighbors()
{
  int i,j;
  const int mb_width = IMG_WIDTH/MB_BLOCK_SIZE;
  const int mb_nr = mb_phase;
  Macroblock *currMB = &mb_data[mb_nr];

  // mark all neighbors as unavailable
  for (i=0; i<3; i++)
    for (j=0; j<3; j++)
      mb_data[mb_nr].mb_available[i][j]=NULL;
  mb_data[mb_nr].mb_available[1][1]=currMB; // current MB

  // Check MB to the left
  if(pix_x >= MB_BLOCK_SIZE)
  {
    int remove_prediction = currMB->slice_nr != mb_data[mb_nr-1].slice_nr;
    // upper blocks
    if (remove_prediction )
    {
      ipredmode[block_x][block_y+1] = -1;
      ipredmode[block_x][block_y+2] = -1;
    }
    // lower blocks
    if (remove_prediction )
    {
      ipredmode[block_x][block_y+3] = -1;
      ipredmode[block_x][block_y+4] = -1;
    }
    if (!remove_prediction)
    {
      currMB->mb_available[1][0]=&(mb_data[mb_nr-1]);
    }
  }


  // Check MB above
  
  if(pix_y >= MB_BLOCK_SIZE)
  {
    int remove_prediction = currMB->slice_nr != mb_data[mb_nr-mb_width].slice_nr;
    // upper blocks
    if (remove_prediction )
    {
      ipredmode[block_x+1][block_y] = -1;
      ipredmode[block_x+2][block_y] = -1;
    }
    // lower blocks
    if (remove_prediction )
    {
      ipredmode[block_x+3][block_y] = -1;
      ipredmode[block_x+4][block_y] = -1;
    }
    if (!remove_prediction)
    {
      currMB->mb_available[0][1]=&(mb_data[mb_nr-mb_width]);
    }
  }

  


  // check MB above
  if(pix_y >= MB_BLOCK_SIZE && pix_x >= MB_BLOCK_SIZE)
  {
    int remove_prediction = currMB->slice_nr != mb_data[mb_nr-mb_width-1].slice_nr;

    if (remove_prediction )
    {
      ipredmode[block_x][block_y] = -1;
    }
    if (!remove_prediction)
    {
      currMB->mb_available[0][0]=&(mb_data[mb_nr-mb_width-1]);
    }
  }

  // Check MB right above
  if(pix_y >= MB_BLOCK_SIZE && pix_x < (IMG_WIDTH-MB_BLOCK_SIZE ))
  {
    if(currMB->slice_nr == mb_data[mb_nr-mb_width+1].slice_nr)
      currMB->mb_available[0][2]=&(mb_data[mb_nr-mb_width+1]);
  }

}


/*!
 ************************************************************************
 * \brief
 *    initializes the current macroblock
 ************************************************************************
 */
static void start_macroblock(int CurrentMBInScanOrder)
{
  int i,j,k,l;
  Macroblock *currMB;   // intialization code deleted, see below, StW

  assert (mb_phase >=0 && mb_phase < MAX_MB_NR);

        currMB = &mb_data[mb_phase];//GB

  /* Update coordinates of the current macroblock */

  mb_x = (mb_phase)%(IMG_WIDTH/MB_BLOCK_SIZE);
  mb_y = (mb_phase)/(IMG_WIDTH/MB_BLOCK_SIZE);
  
  /* Define vertical positions */
  block_y = mb_y * BLOCK_SIZE;      /* luma block position */
  pix_y   = mb_y * MB_BLOCK_SIZE;   /* luma macroblock position */
  pix_c_y = mb_y * MB_BLOCK_SIZE/2; /* chroma macroblock position */
  
  /* Define horizontal positions */
  block_x = mb_x * BLOCK_SIZE;      /* luma block position */
  pix_x   = mb_x * MB_BLOCK_SIZE;   /* luma pixel position */
  pix_c_x = mb_x * MB_BLOCK_SIZE/2; /* chroma pixel position */

  // Save the slice number of this macroblock. When the macroblock below
  // is coded it will use this to decide if prediction for above is possible
  //currMB->slice_nr = img->current_slice_nr;
  currMB->slice_nr = 0;
  
  // If MB is next to a slice boundary, mark neighboring blocks unavailable for prediction
  CheckAvailabilityOfNeighbors();      // support only slice mode 0 in MBINTLC1 at this time

  // Reset syntax element entries in MB struct
  currMB->qp          = sliceparams->qp ;
  currMB->mb_type     = 0;
  currMB->delta_quant = 0;
  currMB->cbp         = 0;
  currMB->cbp_blk     = 0;
  currMB->c_ipred_mode= DC_PRED_8; //GB

  for (l=0; l < 2; l++)
    for (j=0; j < BLOCK_MULTIPLE; j++)
      for (i=0; i < BLOCK_MULTIPLE; i++)
        for (k=0; k < 2; k++)
          currMB->mvd[l][j][i][k] = 0;

  currMB->cbp_bits   = 0;

  // initialize img->m7 for ABT
  for (j=0; j<4; j++)
    for (i=0; i<4; i++)
      m7[i][j] = 0;

}

/*!
 ************************************************************************
 * \brief
 *    set coordinates of the next macroblock
 *    check end_of_slice condition 
 ************************************************************************
 */
static int exit_macroblock(void)
{
  //! The if() statement below resembles the original code, which tested 
  //! img->current_mb_nr == img->max_mb_nr.  Both is, of course, nonsense
  //! In an error prone environment, one can only be sure to have a new
  //! picture by checking the tr of the next slice header!

    if(uvlc_startcode_follows(bstream) == FALSE) 
      return FALSE;

    if(sliceparams->type == I_SLICE )
      return TRUE;
    if(cod_counter<=0)
      return TRUE;
    return FALSE;
}

/*!
 ************************************************************************
 * \brief
 *    Interpret the mb mode for P-Frames
 ************************************************************************
 */
static void interpret_mb_mode_P(void)
{
  int i;
  const int ICBPTAB[6] = {0,16,32,15,31,47};
  Macroblock *currMB = &mb_data[mb_phase];//GB current_mb_nr];
  int         mbmode = currMB->mb_type;

#define ZERO_P8x8     (mbmode==5)
#define MODE_IS_P8x8  (mbmode==4 || mbmode==5)
#define MODE_IS_I4x4  (mbmode==6)
#define I16OFFSET     (mbmode-7)

  if(mbmode <4)
  {
    currMB->mb_type = mbmode;
    for (i=0;i<4;i++)
    {
      currMB->b8mode[i]   = mbmode;
      currMB->b8pdir[i]   = 0;
    }
  }
  else if(MODE_IS_P8x8)
  {
    currMB->mb_type = P8x8;
    allrefzero = ZERO_P8x8;
  }
  else if(MODE_IS_I4x4)
  {
    currMB->mb_type = I4MB;
    for (i=0;i<4;i++)
    {
      currMB->b8mode[i] = IBLOCK;
      currMB->b8pdir[i] = -1;
    }
  }
  else
  {
    currMB->mb_type = I16MB;
    for (i=0;i<4;i++) {currMB->b8mode[i]=0; currMB->b8pdir[i]=-1; }
    currMB->cbp= ICBPTAB[(I16OFFSET)>>2];
    currMB->i16mode = (I16OFFSET) & 0x03;
  }
}

/*!
 ************************************************************************
 * \brief
 *    Interpret the mb mode for I-Frames
 ************************************************************************
 */
static void interpret_mb_mode_I(void)
{
  int i;
  const int ICBPTAB[6] = {0,16,32,15,31,47};
  Macroblock *currMB   = &mb_data[mb_phase];
  int         mbmode   = currMB->mb_type;

  if (mbmode==0)
  {
    currMB->mb_type = I4MB;
    for (i=0;i<4;i++) {currMB->b8mode[i]=IBLOCK; currMB->b8pdir[i]=-1; }
  }
  else
  {
    currMB->mb_type = I16MB;
    for (i=0;i<4;i++) {currMB->b8mode[i]=0; currMB->b8pdir[i]=-1; }
    currMB->cbp= ICBPTAB[(mbmode-1)>>2];
    currMB->i16mode = (mbmode-1) & 0x03;
  }
}


/*!
 ************************************************************************
 * \brief
 *    init macroblock I and P frames
 ************************************************************************
 */
static void init_macroblock(void)
{
  int i,j;
  Macroblock *currMB = &mb_data[mb_phase];

  for (i=0;i<BLOCK_SIZE;i++)
  {                           // reset vectors and pred. modes
    for(j=0;j<BLOCK_SIZE;j++)
    {
      img_mv[block_x+i+4][block_y+j][0] = 0;
      img_mv[block_x+i+4][block_y+j][1] = 0;

      ipredmode[block_x+i+1][block_y+j+1] = DC_PRED;
    }
  }

  // Set the reference frame information for motion vector prediction
  if (IS_INTRA (currMB))
  {
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              refFrArr[block_y+j][block_x+i] = -1;
            }
  }
  else if (!IS_P8x8 (currMB))
  {
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
              refFrArr[block_y+j][block_x+i] = 0;
            }
  }
  else
  {
          for (j=0; j<4; j++)
            for (i=0; i<4; i++)
            {
                refFrArr[block_y+j][block_x+i] = (currMB->b8mode[2*(j/2)+(i/2)]==IBLOCK ? -1 : 0);
            }
  }
}


/*!
 ************************************************************************
 * \brief
 *    Sets mode for 8x8 block
 ************************************************************************
 */
static void SetB8Mode (Macroblock* currMB, int value, int i)
{
  static const int p_v2b8 [ 5] = {4, 5, 6, 7, IBLOCK};
  static const int p_v2pd [ 5] = {0, 0, 0, 0, -1};

    currMB->b8mode[i]   = p_v2b8[value];
    currMB->b8pdir[i]   = p_v2pd[value];
}


/*!
 ************************************************************************
 * \brief
 *    Get the syntax elements from the NAL
 ************************************************************************
 */
static int read_one_macroblock(void)
{
  int i;

  SyntaxElement currSE;
  Macroblock *currMB = &mb_data[mb_phase];//GB current_mb_nr];

  int  img_block_y;
  
  currMB->qp = sliceparams->qp ;

  currSE.type = SE_MBTYPE;

  // read MB mode **********************************************
    currSE.mapping = linfo_ue;
 
    if(sliceparams->type == I_SLICE ) //GB
    {
      //  read MB type
      readSyntaxElement_UVLC(&currSE, bstream);
      currMB->mb_type = currSE.value1;
      currMB->ei_flag = 0;
    } 
    else
    {
      if(cod_counter == -1)
      {
        readSyntaxElement_UVLC(&currSE, bstream);
        cod_counter = currSE.value1;
      }
      if (cod_counter==0)
      {
          // read MB type
        readSyntaxElement_UVLC(&currSE, bstream);
        if(sliceparams->type == P_SLICE )
          currSE.value1++;
        currMB->mb_type = currSE.value1;
        currMB->ei_flag = 0;
        cod_counter--;

      } 
      else
      {
        cod_counter--;
        currMB->mb_type = 0;
        currMB->ei_flag = 0;
      }
    }

  if ((sliceparams->type==P_SLICE ))    // inter frame
    interpret_mb_mode_P();
  else if (sliceparams->type==I_SLICE)                                  // intra frame
    interpret_mb_mode_I();


  //====== READ 8x8 SUB-PARTITION MODES (modes of 8x8 blocks) and Intra VBST block modes ======
  if (IS_P8x8 (currMB))
  {
    currSE.type    = SE_MBTYPE;

    for (i=0; i<4; i++)
    {
      currSE.mapping = linfo_ue;

      readSyntaxElement_UVLC (&currSE, bstream);
      SetB8Mode (currMB, currSE.value1, i);
    }
  }


  //--- init macroblock data ---
  init_macroblock();

  if (currMB->mb_type == 0 && sliceparams->type == P_SLICE) //keep last macroblock
  {
    int i, j, iii, jjj, pmv[2];
    int mb_available_up   = (mb_y == 0)  ? 0 : (currMB->slice_nr == mb_data[mb_phase-IMG_WIDTH/16].slice_nr);
    int mb_available_left = (mb_x == 0)  ? 0 : (currMB->slice_nr == mb_data[mb_phase-1].slice_nr);
    int zeroMotionAbove   = !mb_available_up  ? 1 : refFrArr[block_y-1][block_x]  == 0 && img_mv[4+block_x  ][block_y-1][0] == 0 && img_mv[4+block_x  ][block_y-1][1] == 0 ? 1 : 0;
    int zeroMotionLeft    = !mb_available_left? 1 : refFrArr[block_y][block_x-1]  == 0 && img_mv[4+block_x-1][block_y  ][0] == 0 && img_mv[4+block_x-1][block_y  ][1] == 0 ? 1 : 0;

    currMB->cbp = 0;

    for (i=0;i<BLOCK_SIZE;i++)
    { // reset luma coeffs
      for (j=0;j<BLOCK_SIZE;j++)
        for(iii=0;iii<BLOCK_SIZE;iii++)
          for(jjj=0;jjj<BLOCK_SIZE;jjj++)
            cof[i][j][iii][jjj]=0;
    }
    for (j=4;j<6;j++)
    { // reset chroma coeffs
      for (i=0;i<4;i++)
        for (iii=0;iii<4;iii++)
          for (jjj=0;jjj<4;jjj++)
            cof[i][j][iii][jjj]=0;
    }

    for (i=0; i < 4; i++)
      for (j=0; j < 6; j++)
        nz_coeff[mb_x ][mb_y][i][j]=0;  // CAVLC

    img_block_y   = block_y;
  
    if (zeroMotionAbove || zeroMotionLeft)
    {
        for(i=0;i<BLOCK_SIZE;i++)
          for(j=0;j<BLOCK_SIZE;j++)
          {
            img_mv[block_x+i+BLOCK_SIZE][block_y+j][0] = 0;
            img_mv[block_x+i+BLOCK_SIZE][block_y+j][1] = 0;
          }
    }
    else
    {
      SetMotionVectorPredictor (pmv, pmv+1, 0, refFrArr, img_mv, 0, 0, 16, 16);

      for(i=0;i<BLOCK_SIZE;i++)
        for(j=0;j<BLOCK_SIZE;j++)
        {
          img_mv[block_x+i+BLOCK_SIZE][img_block_y+j][0] = pmv[0];
          img_mv[block_x+i+BLOCK_SIZE][img_block_y+j][1] = pmv[1];
        }

    }

    for (j=0; j<BLOCK_SIZE;j++)
        for (i=0; i<BLOCK_SIZE;i++)
        {
          refFrArr[block_y+j][block_x+i] = 0;
        }

    return DECODE_MB;
  }


  // intra prediction modes for a macroblock 4x4 ****************************
  read_ipred_modes();    //changed this completely and moved it in the function below.


  /* read inter frame vector data *******************************************/
  if (IS_INTERMV (currMB))
  {
    readMotionInfoFromNAL ();
  }


  // read CBP and Coeffs  ***************************************************
  readCBPandCoeffsFromNAL ();

  return DECODE_MB;
}

static void read_ipred_modes(void)
{
  int b8,bs_x,bs_y,bbs_x,bbs_y,i,j,ii,jj,bi,bj,dec;
  SyntaxElement currSE;
  Macroblock *currMB;
  int ts, ls;
  int j2;
  int mostProbableIntraPredMode;
  int upIntraPredMode;
  int leftIntraPredMode;
  int IntraChromaPredModeFlag;
  
  currMB=&mb_data[mb_phase];//current_mb_nr;
  IntraChromaPredModeFlag = IS_INTRA(currMB);

  currSE.type = SE_INTRAPREDMODE;

  for(b8=0;b8<4;b8++)  //loop 8x8 blocks
  {
    if( currMB->b8mode[b8]==IBLOCK )
    {
      IntraChromaPredModeFlag = 1;
      bs_x=bs_y=4;
      bbs_x = (bs_x>>2);    // bug fix for solaris. mwi
      bbs_y = (bs_y>>2);    // bug fix for solaris. mwi
      for(j=0;j<2;j+=bbs_y)  //loop subblocks
        for(i=0;i<2;i+=bbs_x)
        {
          //get from stream
          readSyntaxElement_Intra4x4PredictionMode(&currSE, bstream);

          //get from array and decode
          bi = block_x + ((b8&1)<<1) + i ;
          bj = block_y +    (b8&2)   + j ;

          ts=ls=0;   // Check to see if the neighboring block is SI

          upIntraPredMode            = ts == 0 ? ipredmode[bi+1][bj] : DC_PRED;
          leftIntraPredMode          = ls == 0 ? ipredmode[bi][bj+1] : DC_PRED;
          mostProbableIntraPredMode  = (upIntraPredMode < 0 || leftIntraPredMode < 0) ? DC_PRED : upIntraPredMode < leftIntraPredMode ? upIntraPredMode : leftIntraPredMode;

          dec = (currSE.value1 == -1) ? mostProbableIntraPredMode : currSE.value1 + (currSE.value1 >= mostProbableIntraPredMode);

          //set
          for(jj=0;jj<(bs_y>>2);jj++)   //loop 4x4s in the subblock
            for(ii=0;ii<(bs_x>>2);ii++)
            {
              ipredmode[1+bi+ii][1+bj+jj]=dec;
            }
            j2 = bj;

        }
    }
  }

  if (IntraChromaPredModeFlag)
  {
    currSE.type = SE_INTRAPREDMODE;
    currSE.mapping = linfo_ue;

    readSyntaxElement_UVLC(&currSE, bstream);
    currMB->c_ipred_mode = currSE.value1;
    if (currMB->c_ipred_mode < DC_PRED_8 || currMB->c_ipred_mode > PLANE_8)
      error("illegal chroma intra pred mode!\n", 600);
  }
}



/*!
 ************************************************************************
 * \brief
 *    Set motion vector predictor
 ************************************************************************
 */
static void SetMotionVectorPredictor (int             *pmv_x,
                                      int             *pmv_y,
                                      int             ref_frame,
int refFrArr1[][IMG_WIDTH/BLOCK_SIZE],
int tmp_mv[][IMG_HEIGHT/BLOCK_SIZE][3],
                                      int             iblock_x,
                                      int             iblock_y,
                                      int             blockshape_x,
                                      int             blockshape_y)
{
  int imb_x                 = 4*iblock_x;
  int imb_y                 = 4*iblock_y;
  int pic_block_x          = block_x + iblock_x;
  int pic_block_y          = block_y + iblock_y;
  const int mb_width             = IMG_WIDTH/16;
  //int mb_nr = mb_phase;
  int mb_available_up   = (mb_y == 0 ) ? 0 : 1;
  int mb_available_left = (mb_x == 0 ) ? 0 : 1;
  int mb_available_upleft  = (mb_x == 0) ? 0 : (mb_y == 0) ? 0 : 1;
  int mb_available_upright = (mb_y == 0) ? 0 : ((mb_x >= (mb_width-1)) ? 0 : 1);

  int block_available_up, block_available_left, block_available_upright, block_available_upleft;
  int mv_a, mv_b, mv_c, mv_d, pred_vec=0;
  int mvPredType, rFrameL, rFrameU, rFrameUR;
  int hv;


  /* D B C */
  /* A X   */

  /* 1 A, B, D are set to 0 if unavailable       */
  /* 2 If C is not available it is replaced by D */
  block_available_up   = mb_available_up   || (imb_y > 0);
  block_available_left = mb_available_left || (imb_x > 0);

  if (imb_y > 0)
  {
    if (imb_x < 8)  // first column of 8x8 blocks
    {
      if (imb_y==8)
      {
        if (blockshape_x == 16)      block_available_upright = 0;
        else                         block_available_upright = 1;
      }
      else
      {
        if (imb_x+blockshape_x != 8)  block_available_upright = 1;
        else                         block_available_upright = 0;
      }
    }
    else
    {
      if (imb_x+blockshape_x != 16)   block_available_upright = 1;
      else                           block_available_upright = 0;
    }
  }
  else if (imb_x+blockshape_x != MB_BLOCK_SIZE)
  {
    block_available_upright = block_available_up;
  }
  else
  {
    block_available_upright = mb_available_upright;
  }

  if (imb_x > 0)
  {
    block_available_upleft = (imb_y > 0 ? 1 : mb_available_up);
  }
  else if (imb_y > 0)
  {
    block_available_upleft = mb_available_left;
  }
  else
  {
    block_available_upleft = mb_available_upleft;
  }


  mvPredType = MVPRED_MEDIAN;
  rFrameL    = block_available_left    ? refFrArr1[pic_block_y]  [pic_block_x-1             ] : -1;
  rFrameU    = block_available_up      ? refFrArr1[pic_block_y-1][pic_block_x               ]   : -1;
  rFrameUR   = block_available_upright ? refFrArr1[pic_block_y-1][pic_block_x+blockshape_x/4] :
               block_available_upleft  ? refFrArr1[pic_block_y-1][pic_block_x-1             ] : -1;


  /* Prediction if only one of the neighbors uses the reference frame
   * we are checking
   */
  if(rFrameL == ref_frame && rFrameU != ref_frame && rFrameUR != ref_frame)       mvPredType = MVPRED_L;
  else if(rFrameL != ref_frame && rFrameU == ref_frame && rFrameUR != ref_frame)  mvPredType = MVPRED_U;
  else if(rFrameL != ref_frame && rFrameU != ref_frame && rFrameUR == ref_frame)  mvPredType = MVPRED_UR;
  // Directional predictions 
  else if(blockshape_x == 8 && blockshape_y == 16)
  {
    if(imb_x == 0)
    {
      if(rFrameL == ref_frame)
        mvPredType = MVPRED_L;
    }
    else
    {
      if( rFrameUR == ref_frame)
        mvPredType = MVPRED_UR;
    }
  }
  else if(blockshape_x == 16 && blockshape_y == 8)
  {
    if(imb_y == 0)
    {
      if(rFrameU == ref_frame)
        mvPredType = MVPRED_U;
    }
    else
    {
      if(rFrameL == ref_frame)
        mvPredType = MVPRED_L;
    }
  }

  for (hv=0; hv < 2; hv++)
  {
    mv_a = block_available_left    ? tmp_mv[4+pic_block_x-1             ][pic_block_y  ][hv] : 0;
    mv_b = block_available_up      ? tmp_mv[4+pic_block_x               ][pic_block_y-1][hv] : 0;
    mv_d = block_available_upleft  ? tmp_mv[4+pic_block_x-1             ][pic_block_y-1][hv] : 0;
    mv_c = block_available_upright ? tmp_mv[4+pic_block_x+blockshape_x/4][pic_block_y-1][hv] : mv_d;


    switch (mvPredType)
    {
    case MVPRED_MEDIAN:
      if(!(block_available_upleft || block_available_up || block_available_upright))
        pred_vec = mv_a;
      else
        pred_vec = mv_a+mv_b+mv_c-min(mv_a,min(mv_b,mv_c))-max(mv_a,max(mv_b,mv_c));
      break;
    case MVPRED_L:
      pred_vec = mv_a;
      break;
    case MVPRED_U:
      pred_vec = mv_b;
      break;
    case MVPRED_UR:
      pred_vec = mv_c;
      break;
    default:
      break;
    }

    if (hv==0)  *pmv_x = pred_vec;
    else        *pmv_y = pred_vec;

  }
}

/*!
 ************************************************************************
 * \brief
 *    Read motion info
 ************************************************************************
 */
static void readMotionInfoFromNAL (void)
{
  int i,j,k,l,m;
  int step_h,step_v;
  int curr_mvd;
  Macroblock *currMB  = &mb_data[mb_phase];
  SyntaxElement currSE;
  int partmode        = (IS_P8x8(currMB)?4:currMB->mb_type);
  int step_h0         = BLOCK_STEP [partmode][0];
  int step_v0         = BLOCK_STEP [partmode][1];

  int mv_mode, i0, j0, refframe;
  int pmv[2];
  int j4, i4, ii,jj;
  int vec;

  //int ref;
  int img_block_y;

  //  If multiple ref. frames, read reference frame for the MB ***************
  assert(sliceparams->num_ref_pic_active_fwd > 0);
  if(sliceparams->num_ref_pic_active_fwd>1) 
  {
    currSE.type = SE_REFFRAME;
    currSE.mapping = linfo_ue;
    
    for (j0=0; j0<4; j0+=step_v0)
      for (i0=0; i0<4; i0+=step_h0)
      {
        k=2*(j0/2)+(i0/2);
        assert(currMB->b8pdir[k] == 0);
        assert(currMB->b8mode[k] != 0);
        if ((currMB->b8pdir[k]==0 || currMB->b8pdir[k]==2) && currMB->b8mode[k]!=0)
        {
          
          if (!IS_P8x8 (currMB) || (!allrefzero))
          {
            readSyntaxElement_UVLC(&currSE, bstream);
            refframe = currSE.value1;
          }
          else {
            refframe = 0;
          }
          
          for (j=j0; j<j0+step_v0;j++)
            for (i=i0; i<i0+step_h0;i++)
              refFrArr[block_y+j][block_x+i] = refframe;
      }
    }
  }
  
  // If backward multiple ref. frames, read backward reference frame for the MB
  assert(sliceparams->num_ref_pic_active_bwd == 1);

  //=====  READ FORWARD MOTION VECTORS =====
  currSE.type = SE_MVD;
  currSE.mapping = linfo_se;

  for (j0=0; j0<4; j0+=step_v0)
    for (i0=0; i0<4; i0+=step_h0)
    {
      k=2*(j0/2)+(i0/2);
      assert(currMB->b8pdir[k] == 0);
      assert(currMB->b8mode[k] != 0);

      if ((currMB->b8pdir[k]==0 || currMB->b8pdir[k]==2) && (currMB->b8mode[k] !=0))//has forward vector
      {
        mv_mode  = currMB->b8mode[k];
        step_h   = BLOCK_STEP [mv_mode][0];
        step_v   = BLOCK_STEP [mv_mode][1];
        
        refframe = refFrArr[block_y+j0][block_x+i0];
        
        for (j=j0; j<j0+step_v0; j+=step_v)
          for (i=i0; i<i0+step_h0; i+=step_h)
          {
            j4 = block_y+j;
            i4 = block_x+i;
            
            // first make mv-prediction
            SetMotionVectorPredictor (pmv, pmv+1, refframe, refFrArr, img_mv,  i, j, 4*step_h, 4*step_v);
            for (k=0; k < 2; k++) 
            {
              currSE.value2 = k; // identifies the component; only used for context determination
              readSyntaxElement_UVLC(&currSE, bstream);
              curr_mvd = currSE.value1; 
              
              vec=curr_mvd+pmv[k];           /* find motion vector */
              
              for(ii=0;ii<step_h;ii++)
                  for(jj=0;jj<step_v;jj++)
                      img_mv[i4+ii+BLOCK_SIZE][j4+jj][k]=vec;
              
              /* store (oversampled) mvd */
              for (l=0; l < step_v; l++) 
                for (m=0; m < step_h; m++)  
                  currMB->mvd[0][j+l][i+m][k] =  curr_mvd;
        }
      }
    }
  }
  

  //=====  READ BACKWARD MOTION VECTORS =====
  currSE.type = SE_MVD;
  currSE.mapping = linfo_se;

  img_block_y = block_y;
  
  for (j0=0; j0<4; j0+=step_v0)
  for (i0=0; i0<4; i0+=step_h0)
  {
    k=2*(j0/2)+(i0/2);
    assert(currMB->b8pdir[k] == 0 || currMB->b8pdir[k] == -1);
  }
}



/*!
 ************************************************************************
 * \brief
 *    Get the Prediction from the Neighboring BLocks for Number of Nonzero Coefficients 
 *    
 *    Luma Blocks
 ************************************************************************
 */
static int predict_nnz(int i,int j)
{
  int Left_block,Top_block, pred_nnz;
  int cnt=0;

  int mb_nr    = mb_phase;
  const int mb_width = IMG_WIDTH/16;

  int mb_available_up   = (mb_y == 0 ) ? 0 : (mb_data[mb_nr].slice_nr == mb_data[mb_nr-mb_width  ].slice_nr);
  int mb_available_left = (mb_x == 0 ) ? 0 : (mb_data[mb_nr].slice_nr == mb_data[mb_nr-1         ].slice_nr);

  if (i)
    Left_block= nz_coeff [mb_x ][mb_y ][i-1][j];
  else
    Left_block= mb_available_left ? nz_coeff [mb_x-1 ][mb_y ][3][j] : -1;

  if (j)
    Top_block=  nz_coeff [mb_x ][mb_y ][i][j-1];
  else
    Top_block=  mb_available_up ? nz_coeff [mb_x ][mb_y-1 ][i][3] : -1;
  

  pred_nnz=0;
  if (Left_block>-1)
  {
    pred_nnz=Left_block;
    cnt++;
  }
  if (Top_block>-1)
  {
    pred_nnz+=Top_block;
    cnt++;
  }

  if (cnt==2) 
    pred_nnz++;

  if (cnt)
    pred_nnz/=cnt; 
    return pred_nnz;
}
/*!
 ************************************************************************
 * \brief
 *    Get the Prediction from the Neighboring BLocks for Number of Nonzero Coefficients 
 *    
 *    Chroma Blocks   
 ************************************************************************
 */
static int predict_nnz_chroma(int i,int j)
{
    int Left_block,Top_block, pred_nnz;
  int cnt=0;

  int mb_nr    = mb_phase;
  const int mb_width = IMG_WIDTH/16;

  int mb_available_up   = (mb_y == 0 ) ? 0 : (mb_data[mb_nr].slice_nr == mb_data[mb_nr-mb_width  ].slice_nr);
  int mb_available_left = (mb_x == 0 ) ? 0 : (mb_data[mb_nr].slice_nr == mb_data[mb_nr-1         ].slice_nr);

  if (i==1 || i==3)
    Left_block= nz_coeff [mb_x ][mb_y ][i-1][j];
  else
    Left_block= mb_available_left ? nz_coeff [mb_x-1 ][mb_y ][i+1][j] : -1;

  if (j==5)
    Top_block=  nz_coeff [mb_x ][mb_y ][i][j-1];
  else
    Top_block=  mb_available_up ? nz_coeff [mb_x ][mb_y-1 ][i][5] : -1;

  
  pred_nnz=0;
  if (Left_block>-1)
  {
    pred_nnz=Left_block;
    cnt++;
  }
  if (Top_block>-1)
  {
    pred_nnz+=Top_block;
    cnt++;
  }
  
  if (cnt==2) 
    pred_nnz++;

  if (cnt)
    pred_nnz/=cnt; 
    return pred_nnz;
}


/*!
 ************************************************************************
 * \brief
 *    Reads coeff of an 4x4 block (CAVLC)
 *
 * \author
 *    Karl Lillevold <karll@real.com>
 *    contributions by James Au <james@ubvideo.com>
 ************************************************************************
 */


static void readCoeff4x4_CAVLC (int block_type, 
                        int i, int j, int levarr[16], int runarr[16],
                        int *number_coefficients)
{
  int mb_nr = mb_phase;
  Macroblock *currMB = &mb_data[mb_nr];
  SyntaxElement currSE;

  int k, code, vlcnum;
  int numcoeff, numtrailingones, numcoeff_vlc;
  int level_two_or_higher;
  int numones, totzeros, level, cdc=0, cac=0;
  int zerosleft, ntr, dptype = 0;
  int max_coeff_num = 0, nnz;
  char type[15];
  int incVlc[] = {0,3,6,12,24,48,32768};    // maximum vlc = 6

  numcoeff = 0;

  switch (block_type)
  {
  case LUMA:
    max_coeff_num = 16;
    sprintf(type, "%s", "Luma");
    if (IS_INTRA (currMB))
    {
      dptype = SE_LUM_AC_INTRA;
    }
    else
    {
      dptype = SE_LUM_AC_INTER;
    }
    break;
  case LUMA_INTRA16x16DC:
    max_coeff_num = 16;
    sprintf(type, "%s", "Lum16DC");
    dptype = SE_LUM_DC_INTRA;
    break;
  case LUMA_INTRA16x16AC:
    max_coeff_num = 15;
    sprintf(type, "%s", "Lum16AC");
    dptype = SE_LUM_AC_INTRA;
    break;

  case CHROMA_DC:
    max_coeff_num = 4;
    cdc = 1;

    sprintf(type, "%s", "ChrDC");
    if (IS_INTRA (currMB))
    {
      dptype = SE_CHR_DC_INTRA;
    }
    else
    {
      dptype = SE_CHR_DC_INTER;
    }
    break;
  case CHROMA_AC:
    max_coeff_num = 15;
    cac = 1;
    sprintf(type, "%s", "ChrAC");
    if (IS_INTRA (currMB))
    {
      dptype = SE_CHR_AC_INTRA;
    }
    else
    {
      dptype = SE_CHR_AC_INTER;
    }
    break;
  default:
    error ("readCoeff4x4_CAVLC: invalid block type", 600);
    break;
  }

  currSE.type = dptype;

  nz_coeff[mb_x ][mb_y][i][j] = 0;


  if (!cdc)
  {
    // luma or chroma AC
    if (!cac)
      nnz = predict_nnz(i, j);
    else
      nnz = predict_nnz_chroma(i, j);

    if (nnz < 2)
    {
      numcoeff_vlc = 0;
    }
    else if (nnz < 4)
    {
      numcoeff_vlc = 1;
    }
    else if (nnz < 8)
    {
      numcoeff_vlc = 2;
    }
    else //
    {
      numcoeff_vlc = 3;
    }

    currSE.value1 = numcoeff_vlc;

    readSyntaxElement_NumCoeffTrailingOnes(&currSE, bstream, type);

    numcoeff =  currSE.value1;
    numtrailingones =  currSE.value2;

    nz_coeff[mb_x ][mb_y][i][j] = numcoeff;
  }
  else
  {
    // chroma DC
    readSyntaxElement_NumCoeffTrailingOnesChromaDC(&currSE, bstream);

    numcoeff =  currSE.value1;
    numtrailingones =  currSE.value2;
  }


  for (k = 0; k < max_coeff_num; k++)
  {
    levarr[k] = 0;
    runarr[k] = 0;
  }

  numones = numtrailingones;
  *number_coefficients = numcoeff;

  if (numcoeff)
  {
    if (numtrailingones)
    {

      currSE.len = numtrailingones;

#if TRACE
      snprintf(currSE.tracestring, 
        TRACESTRING_SIZE, "%s trailing ones sign (%d,%d)", type, i, j);
#endif

      readSyntaxElement_FLC (&currSE, bstream);

      code = currSE.inf;
      ntr = numtrailingones;
      for (k = numcoeff-1; k > numcoeff-1-numtrailingones; k--)
      {
        ntr --;
        if ((code>>ntr)&1)
          levarr[k] = -1;
        else
          levarr[k] = 1;
      }
    }

    // decode levels
    level_two_or_higher = 1;
    if (numcoeff > 3 && numtrailingones == 3)
      level_two_or_higher = 0;

      if (numcoeff > 10 && numtrailingones < 3)
          vlcnum = 1;
      else
          vlcnum = 0;

    for (k = numcoeff - 1 - numtrailingones; k >= 0; k--)
    {

#if TRACE
      snprintf(currSE.tracestring, 
        TRACESTRING_SIZE, "%s lev (%d,%d) k=%d vlc=%d ", type,
          i, j, k, vlcnum);
#endif

      if (vlcnum == 0)
          readSyntaxElement_Level_VLC0(&currSE, bstream);
      else
          readSyntaxElement_Level_VLCN(&currSE, vlcnum, bstream);

      if (level_two_or_higher)
      {
          if (currSE.inf > 0)
          currSE.inf ++;
          else
          currSE.inf --;
          level_two_or_higher = 0;
      }

      level = levarr[k] = currSE.inf;
      if (abs(level) == 1)
        numones ++;

      // update VLC table
      if (abs(level)>incVlc[vlcnum])
        vlcnum++;

      if (k == numcoeff - 1 - numtrailingones && abs(level)>3)
        vlcnum = 2;

    }
    
    if (numcoeff < max_coeff_num)
    {
      // decode total run
      vlcnum = numcoeff-1;
      currSE.value1 = vlcnum;

#if TRACE
      snprintf(currSE.tracestring, 
        TRACESTRING_SIZE, "%s totalrun (%d,%d) vlc=%d ", type, i,j, vlcnum);
#endif
      if (cdc)
        readSyntaxElement_TotalZerosChromaDC(&currSE, bstream);
      else
        readSyntaxElement_TotalZeros(&currSE, bstream);

      totzeros = currSE.value1;
    }
    else
    {
      totzeros = 0;
    }

    // decode run before each coefficient
    zerosleft = totzeros;
    i = numcoeff-1;
    if (zerosleft > 0 && i > 0)
    {
      do 
      {
        // select VLC for runbefore
        vlcnum = zerosleft - 1;
        if (vlcnum > RUNBEFORE_NUM-1)
          vlcnum = RUNBEFORE_NUM-1;

        currSE.value1 = vlcnum;
#if TRACE
        snprintf(currSE.tracestring, 
          TRACESTRING_SIZE, "%s run (%d,%d) k=%d vlc=%d ",
            type, i, j, i, vlcnum);
#endif

        readSyntaxElement_Run(&currSE, bstream);
        runarr[i] = currSE.value1;

        zerosleft -= runarr[i];
        i --;
      } while (zerosleft != 0 && i != 0);
    }
    runarr[i] = zerosleft;

  } // if numcoeff
}



/*!
 ************************************************************************
 * \brief
 *    Get coded block pattern and coefficients (run/level)
 *    from the NAL
 ************************************************************************
 */
static void readCBPandCoeffsFromNAL(void)
{
  int i,j,k;
  int level;
  int mb_nr = mb_phase;
  int ii,jj;
  int i1,j1, m2,jg2;
  Macroblock *currMB = &mb_data[mb_nr];
  int cbp;
  SyntaxElement currSE;
  int iii,jjj;
  int coef_ctr, i0, j0, b8;
  int ll;
  int iblock_x,iblock_y;
  int start_scan;
  int uv;


  //int run, len;
  int levarr[16], runarr[16], numcoeff;

  int qp_per    = (sliceparams->qp-MIN_QP)/6;
  int qp_rem    = (sliceparams->qp-MIN_QP)%6;
  int qp_per_uv = QP_SCALE_CR[sliceparams->qp-MIN_QP]/6;
  int qp_rem_uv = QP_SCALE_CR[sliceparams->qp-MIN_QP]%6;

  // read CBP if not new intra mode
  if (!IS_NEWINTRA (currMB))
  {
    if (IS_OLDINTRA (currMB) || currMB->mb_type == SI4MB )   currSE.type = SE_CBP_INTRA;
    else         currSE.type = SE_CBP_INTER;

    if (IS_OLDINTRA (currMB) || currMB->mb_type == SI4MB)  currSE.mapping = linfo_cbp_intra;
    else         currSE.mapping = linfo_cbp_inter;

    readSyntaxElement_UVLC(&currSE, bstream);
    currMB->cbp = cbp = currSE.value1;
    // Delta quant only if nonzero coeffs
    if (cbp !=0)
    {
      if (IS_INTER (currMB))  currSE.type = SE_DELTA_QUANT_INTER;
      else                    currSE.type = SE_DELTA_QUANT_INTRA;

      currSE.mapping = linfo_se;

//    snprintf(currSE.tracestring, TRACESTRING_SIZE, "Delta quant ");
      readSyntaxElement_UVLC(&currSE, bstream);
      currMB->delta_quant = currSE.value1;
      sliceparams->qp= (sliceparams->qp-MIN_QP+currMB->delta_quant+(MAX_QP-MIN_QP+1))%(MAX_QP-MIN_QP+1)+MIN_QP;
    }
  }
  else
  {
    cbp = currMB->cbp;
  }

  for (i=0;i<BLOCK_SIZE;i++)
    for (j=0;j<BLOCK_SIZE;j++)
      for(iii=0;iii<BLOCK_SIZE;iii++)
        for(jjj=0;jjj<BLOCK_SIZE;jjj++)
          cof[i][j][iii][jjj]=0;// reset luma coeffs


  if (IS_NEWINTRA (currMB)) // read DC coeffs for new intra modes
  {
    currSE.type = SE_DELTA_QUANT_INTRA;

    currSE.mapping = linfo_se;

//    snprintf(currSE.tracestring, TRACESTRING_SIZE, "Delta quant ");
    readSyntaxElement_UVLC(&currSE, bstream);
    currMB->delta_quant = currSE.value1;
    sliceparams->qp= (sliceparams->qp-MIN_QP+currMB->delta_quant+(MAX_QP-MIN_QP+1))%(MAX_QP-MIN_QP+1)+MIN_QP;

    for (i=0;i<BLOCK_SIZE;i++)
      for (j=0;j<BLOCK_SIZE;j++)
        ipredmode[block_x+i+1][block_y+j+1]=DC_PRED;


    readCoeff4x4_CAVLC(LUMA_INTRA16x16DC, 0, 0,
                          levarr, runarr, &numcoeff);

    coef_ctr=-1;
    level = 1;                            // just to get inside the loop
    for(k = 0; k < numcoeff; k++)
    {
      if (levarr[k] != 0)                     // leave if len=1
      {
        coef_ctr=coef_ctr+runarr[k]+1;

        i0=SNGL_SCAN[coef_ctr][0];
        j0=SNGL_SCAN[coef_ctr][1];
        cof[i0][j0][0][0]=levarr[k];// add new intra DC coeff
      }
    }
    itrans_2();// transform new intra DC
  }

  qp_per    = (sliceparams->qp-MIN_QP)/6;
  qp_rem    = (sliceparams->qp-MIN_QP)%6;
  qp_per_uv = QP_SCALE_CR[sliceparams->qp-MIN_QP]/6;
  qp_rem_uv = QP_SCALE_CR[sliceparams->qp-MIN_QP]%6;
  currMB->qp = sliceparams->qp;

  // luma coefficients
  for (iblock_y=0; iblock_y < 4; iblock_y += 2) /* all modes */
  {
    for (iblock_x=0; iblock_x < 4; iblock_x += 2)
    {

      b8 = 2*(iblock_y/2) + iblock_x/2;
      for (j=iblock_y; j < iblock_y+2; j++)
      {
        for (i=iblock_x; i < iblock_x+2; i++)
        {
          ii = iblock_x/2; jj = iblock_y/2;
          b8 = 2*jj+ii;

          if (cbp & (1<<b8))  /* are there any coeff in current block at all */
          {
            if (IS_NEWINTRA(currMB))
            {
              readCoeff4x4_CAVLC(LUMA_INTRA16x16AC, i, j,
                                  levarr, runarr, &numcoeff);
              start_scan = 1;
            } else {
              readCoeff4x4_CAVLC(LUMA, i, j, levarr, runarr, &numcoeff);
              start_scan = 0;
            }

            coef_ctr = start_scan-1;
            for (k = 0; k < numcoeff; k++) {
              if (levarr[k] != 0) {
                coef_ctr += runarr[k]+1;

                i0=SNGL_SCAN[coef_ctr][0];
                j0=SNGL_SCAN[coef_ctr][1];
                currMB->cbp_blk      |= 1 << ((j<<2) + i) ;
                cof[i][j][i0][j0]= levarr[k]*dequant_coef[qp_rem][i0][j0]<<qp_per;
              }
            }
          }
          else {
            nz_coeff[mb_x][mb_y][i][j] = 0;
          }
        }
      }
    }
  }

  for (j=4;j<6;j++) // reset all chroma coeffs before read
    for (i=0;i<4;i++)
      for (iii=0;iii<4;iii++)
        for (jjj=0;jjj<4;jjj++)
          cof[i][j][iii][jjj]=0;

  m2 =mb_x*2;
  jg2=mb_y*2;

  // chroma 2x2 DC coeff
  if(cbp>15)
  {
    for (ll=0;ll<3;ll+=2)
    {
      for (i=0;i<4;i++)
        cofu[i]=0;

      readCoeff4x4_CAVLC( CHROMA_DC, 0, 0,
                          levarr, runarr, &numcoeff);
      coef_ctr=-1;
      level=1;
      for(k = 0; k < numcoeff; k++)
      {
        if (levarr[k] != 0)
        {
          currMB->cbp_blk |= 0xf0000 << (ll<<1) ;
          coef_ctr=coef_ctr+runarr[k]+1;
          cofu[coef_ctr]=levarr[k];
        }
      }

      for (i=0;i<4;i++)
        cofu[i]*=dequant_coef[qp_rem_uv][0][0]<<qp_per_uv;
      cof[0+ll][4][0][0]=(cofu[0]+cofu[1]+cofu[2]+cofu[3])>>1;
      cof[1+ll][4][0][0]=(cofu[0]-cofu[1]+cofu[2]-cofu[3])>>1;
      cof[0+ll][5][0][0]=(cofu[0]+cofu[1]-cofu[2]-cofu[3])>>1;
      cof[1+ll][5][0][0]=(cofu[0]-cofu[1]-cofu[2]+cofu[3])>>1;
    }
  }

  // chroma AC coeff, all zero fram start_scan
  if (cbp<=31)
    for (j=4; j < 6; j++)
      for (i=0; i < 4; i++)
        nz_coeff [mb_x ][mb_y ][i][j]=0;


  // chroma AC coeff, all zero fram start_scan
  uv=-1;
  if (cbp>31)
  {
    iblock_y=4;
    for (iblock_x=0; iblock_x < 4; iblock_x += 2)
    {
      for (j=iblock_y; j < iblock_y+2; j++)
      {
        jj=j/2;
        j1=j-4;
        for (i=iblock_x; i < iblock_x+2; i++)
        {

          ii=i/2;
          i1=i%2;

          readCoeff4x4_CAVLC( CHROMA_AC, i, j,
                              levarr, runarr, &numcoeff);
          coef_ctr=0;
          level=1;
          uv++;
          for(k = 0; k < numcoeff;k++)
          {
            if (levarr[k] != 0)
            {
              currMB->cbp_blk |= 1 << (16 + (j1<<1) + i1 + (iblock_x<<1) ) ;
              coef_ctr=coef_ctr+runarr[k]+1;

              i0=SNGL_SCAN[coef_ctr][0];
              j0=SNGL_SCAN[coef_ctr][1];
              cof[i][j][i0][j0]=levarr[k]*dequant_coef[qp_rem_uv][i0][j0]<<qp_per_uv;
            }
          }
        }
      }
    }
  }
}


/*!
 ************************************************************************
 * \brief
 *    decode one macroblock
 ************************************************************************
 */

/*
static int decode_one_macroblock_cr(void)
{
  int tmp2_block[BLOCK_SIZE][BLOCK_SIZE];
  int js[2][2];
  int i=0,j=0,ii=0,jj=0,j4=0,i4=0;
  int js0=0,js1=0,js2=0,js3=0;
  int uv;
  int ioff,joff;

  int mv_mul,f1,f2,f3,f4;

  Macroblock *currMB   = &mb_data[mb_phase];//GB current_mb_nr];
  int mv_mode, pred_dir, intra_prediction; // = currMB->ref_frame;
  int mb_available_up;
  int mb_available_left;

  int itmp4x4[4][4];
  int otmp4x4[4][4];


  mb_available_up   = (mb_y == 0) ? 0 : 1;
  mb_available_left = (mb_x == 0) ? 0 : 1; 

  mv_mul=4;
  f1=8;
  f2=7;

  f3=f1*f1;
  f4=f3/2;


  //////////////////////////
  //  CHROMA          //////
  //////////////////////////
  // chroma decoding *******************************************************
  
  for(uv=0;uv<2;uv++)
  {
    intra_prediction = IS_INTRA (currMB);

    if (intra_prediction)
    {
      js0=0;
      js1=0;
      js2=0;
      js3=0;
      for(i=0;i<4;i++)
      {
        if(mb_available_up)
        {
          js0=js0+imgUV[uv][pix_c_y-1][pix_c_x+i];
          js1=js1+imgUV[uv][pix_c_y-1][pix_c_x+i+4];
        }
        if(mb_available_left)
        {
          js2=js2+imgUV[uv][pix_c_y+i][pix_c_x-1];
          js3=js3+imgUV[uv][pix_c_y+i+4][pix_c_x-1];
        }
      }
      if(mb_available_up && mb_available_left)
      {
        js[0][0]=(js0+js2+4)/8;
        js[1][0]=(js1+2)/4;
        js[0][1]=(js3+2)/4;
        js[1][1]=(js1+js3+4)/8;
      }
      if(mb_available_up && !mb_available_left)
      {
        js[0][0]=(js0+2)/4;
        js[1][0]=(js1+2)/4;
        js[0][1]=(js0+2)/4;
        js[1][1]=(js1+2)/4;
      }
      if(mb_available_left && !mb_available_up)
      {
        js[0][0]=(js2+2)/4;
        js[1][0]=(js2+2)/4;
        js[0][1]=(js3+2)/4;
        js[1][1]=(js3+2)/4;
      }
      if(!mb_available_up && !mb_available_left)
      {
        js[0][0]=128;
        js[1][0]=128;
        js[0][1]=128;
        js[1][1]=128;
      }
    }

    for (j=4;j<6;j++)
    {
      joff=(j-4)*4;
      j4=pix_c_y+joff;
      for(i=0;i<2;i++)
      {
        ioff=i*4;
        i4=pix_c_x+ioff;

        mv_mode  = currMB->b8mode[2*(j-4)+i];
        pred_dir = currMB->b8pdir[2*(j-4)+i];
	assert(pred_dir == 0 || pred_dir == -1);

        // PREDICTION
        if (IS_INTRA (currMB))
        {
          //--- INTRA PREDICTION ---
          int pred;
          int ih, iv, ib, ic, iaa;

          switch (currMB->c_ipred_mode)
          {
          case DC_PRED_8:
            for (ii=0; ii<4; ii++)
            for (jj=0; jj<4; jj++)
            {
              mpr[ii+ioff][jj+joff]=js[i][j-4];
            }
            break;
          case HOR_PRED_8:
            if (!mb_available_left)
              error("unexpected HOR_PRED_8 chroma intra prediction mode",-1);
            for (jj=0; jj<4; jj++)
            {
              pred = imgUV[uv][pix_c_y+jj+joff][pix_c_x-1];
              for (ii=0; ii<4; ii++)
                mpr[ii+ioff][jj+joff]=pred;
            }
            break;
          case VERT_PRED_8:
            if (!mb_available_up)
              error("unexpected VERT_PRED_8 chroma intra prediction mode",-1);
            for (ii=0; ii<4; ii++)
            {
              pred = imgUV[uv][pix_c_y-1][pix_c_x+ii+ioff];
              for (jj=0; jj<4; jj++)
                mpr[ii+ioff][jj+joff]=pred;
            }
            break;
          case PLANE_8:
            if (!mb_available_left || !mb_available_up)
              error("unexpected PLANE_8 chroma intra prediction mode",-1);
            ih=iv=0;
            for (ii=1;ii<5;ii++)
            {
              ih += ii*(imgUV[uv][pix_c_y-1][pix_c_x+3+ii] - imgUV[uv][pix_c_y-1][pix_c_x+3-ii]);
              iv += ii*(imgUV[uv][pix_c_y+3+ii][pix_c_x-1] - imgUV[uv][pix_c_y+3-ii][pix_c_x-1]);
            }
            ib=(17*ih+16)>>5;
            ic=(17*iv+16)>>5;
            iaa=16*(imgUV[uv][pix_c_y-1][pix_c_x+7]+imgUV[uv][pix_c_y+7][pix_c_x-1]);
            for (ii=0; ii<4; ii++)
            for (jj=0; jj<4; jj++)
              mpr[ii+ioff][jj+joff]=max(0,min(255,(iaa+(ii+ioff-3)*ib +(jj+joff-3)*ic + 16)/32));
            break;
          default:
            error("illegal chroma intra prediction mode", 600);
            break;
          }
          for(ii=0;ii<4;ii++)
            for(jj=0;jj<4;jj++)
              tmp2_block[ii][jj] = mpr[ii+ioff][jj+joff];

        }
        else if (pred_dir != 2)
        {
          //--- FORWARD/BACKWARD PREDICTION ---
          int refFrame[4];
          int x_position[4];
          int y_position[4];

          refFrame[0] = refFrArr[j4/2]  [i4/2];
          refFrame[1] = refFrArr[j4/2]  [i4/2+1];
          refFrame[2] = refFrArr[j4/2+1][i4/2];
          refFrame[3] = refFrArr[j4/2+1][i4/2+1];

          x_position[0] = (pix_c_x+ioff)*8 + img_mv[i4/2+4][j4/2][0];
          y_position[0] = (pix_c_y+joff)*8 + img_mv[i4/2+4][j4/2][1];
          x_position[1] = (pix_c_x+ioff)*8 + img_mv[i4/2+5][j4/2][0];
          y_position[1] = (pix_c_y+joff)*8 + img_mv[i4/2+5][j4/2][1];
          x_position[2] = (pix_c_x+ioff)*8 + img_mv[i4/2+4][j4/2+1][0];
          y_position[2] = (pix_c_y+joff)*8 + img_mv[i4/2+4][j4/2+1][1];
          x_position[3] = (pix_c_x+ioff)*8 + img_mv[i4/2+5][j4/2+1][0];
          y_position[3] = (pix_c_y+joff)*8 + img_mv[i4/2+5][j4/2+1][1];

          if(uv == 0)
            get_prev_Ublock(refFrame, x_position, y_position, tmp2_block);
          else
            get_prev_Vblock(refFrame, x_position, y_position, tmp2_block);

        }

        for(ii = 0; ii < 4; ii++)
          for(jj = 0; jj < 4; jj++)
            itmp4x4[ii][jj] = cof[2*uv+i][j][ii][jj];

	itransform(itmp4x4, otmp4x4);

	for(ii = 0; ii < BLOCK_SIZE; ii++)
	  for(jj = 0; jj < BLOCK_SIZE; jj++)
            m7[ii][jj] = mmax(0, mmin(255, (otmp4x4[ii][jj] + (tmp2_block[ii][jj] << 6) + (1<<5) ) >>  6 ));


        for(ii=0;ii<4;ii++)
          for(jj=0;jj<4;jj++)
          {
            imgUV[uv][j4+jj][i4+ii]=m7[ii][jj];
          }
      }
    }

  }

  return 0;
}
*/



/*!
 ************************************************************************
 * \brief
 *    Initializes the parameters for a new frame
 ************************************************************************
 */
static void init_frame(void)
{
  int i,j,k,l;

  const int width = IMG_WIDTH;
  const int height = IMG_HEIGHT;

  //WYK: When entire non-B frames are lost, adjust the reference buffers
  //! TO 4.11.2001 Yes, but only for Bitstream mode! We do not loose anything in bitstream mode!
  //! Should remove this one time!

  for(i=0;i<width/BLOCK_SIZE+1;i++)          // set edge to -1, indicate nothing to predict from
  {
    ipredmode[i+1][0]=-1;
    ipredmode[i+1][height/BLOCK_SIZE+1]=-1;
  }
  for(j=0;j<height/BLOCK_SIZE+1;j++)
  {
    ipredmode[0][j+1]=-1;
    ipredmode[width/BLOCK_SIZE+1][j+1]=-1;
  }

  ipredmode[0][0]=-1;

  // CAVLC init
  for (i=0;i < width/MB_BLOCK_SIZE; i++)
    for (j=0; j < height/MB_BLOCK_SIZE; j++)
      for (k=0;k<4;k++)
        for (l=0;l<6;l++)
          nz_coeff[i][j][k][l]=-1;  // CAVLC

  // WYK: Oct. 8, 2001. Set the slice_nr member of each MB to -1, to ensure correct when packet loss occurs
  // TO set Macroblock Map (mark all MBs as 'have to be concealed')
  for(i=0; i < MAX_MB_NR; i++)
  {
    mb_data[i].slice_nr = 0; 
  }

  cod_counter=-1;
}

static void printPred13(int data[13])
{
	int i;
	for(i = 0; i < 13; i++) {
		printf("%4d", data[i]);
	}
	printf("\n");
}




/////////////////////////////////////
// init code
/////////////////////////////////////

TASK_INIT
{
// ##INIT_PORT_SECTION::START
    port_inFrame = PORT_INITIALIZE(TASK_ID, "inFrame");
    port_outMB_interY = PORT_INITIALIZE(TASK_ID, "outMB_interY");
    port_outMB_interU = PORT_INITIALIZE(TASK_ID, "outMB_interU");
    port_outMB_interV = PORT_INITIALIZE(TASK_ID, "outMB_interV");
    port_outMB_intraY = PORT_INITIALIZE(TASK_ID, "outMB_intraY");
    port_outMB_intraU = PORT_INITIALIZE(TASK_ID, "outMB_intraU");
    port_outMB_intraV = PORT_INITIALIZE(TASK_ID, "outMB_intraV");
// ##INIT_PORT_SECTION::END

    // TODO: task initialize code

}


/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
    // TODO: task main code
  int l, k;

  MQ_RECEIVE(port_inFrame, (unsigned char*)&fp, sizeof(FramePacket));

  for(l=0; l<396; l++){
  for(k=0; k<4; k++){
    const byte decode_block_scan[16] = {0,1,4,5,2,3,6,7,8,9,12,13,10,11,14,15};
    int i, j, ioff, joff, i4, j4;
    int ii, jj;
    Macroblock *currMB;
    int mv_mode, pred_dir;

      if(mb_phase == 0 && block_phase == 0){
          bstream = &fp.currStream;;
          sliceparams = &fp.sliceparams;
          mb_data = fi.mbdata;
          refFrArr = fi.refFrameArr;
          img_mv = fi.mv;
          init_frame();
      }

      currMB = &mb_data[mb_phase];
      if(block_phase == 0) {
          // Initializes the current macroblock
          start_macroblock(mb_phase);
          // Get the syntax elements from the NAL
          read_one_macroblock();

          //decode_one_macroblock_cr();
          // get prediction for INTRA_MB_16x16
          if (IS_NEWINTRA (currMB)) {
              mbY.mode16 = currMB->i16mode;
          }

      }

      mbU.mode = currMB->c_ipred_mode;
      mbV.mode = currMB->c_ipred_mode;

      if(block_phase%4 == 0) {
          int cr_phase = block_phase/4;
          int cr_x = cr_phase%2;
          int cr_y = cr_phase/2;

          for(ii = 0; ii < 4; ii++) {
              for(jj = 0; jj < 4; jj++) {
                  mbU.block[ii][jj] = cof[cr_x][cr_y+4][ii][jj];
                  mbV.block[ii][jj] = cof[cr_x+2][cr_y+4][ii][jj];
              }
          }
      }


      i = (decode_block_scan[block_phase] & 3);         // 0 --> 3
      j = ((decode_block_scan[block_phase] >> 2) & 3);  // 0 --> 3
      ioff=i*4;
      i4=block_x+i;
      joff=j*4;
      j4=block_y+j;
      mv_mode  = currMB->b8mode[2*(j/2)+(i/2)];
      pred_dir = currMB->b8pdir[2*(j/2)+(i/2)];

      if (mv_mode == IBLOCK) {  // INTRA prediction
          mbY.mode = preintrapred(i4,j4, mbY.available);
          mbY.ret = 0;
          mbU.ret[k] = 0;
          mbV.ret[k] = 0;

      } else if (!IS_NEWINTRA(currMB)) {
          //===== FORWARD/BACKWARD PREDICTION =====
          int refframe = refFrArr[j4][i4];
          int vec1_x = i4*16 + img_mv[i4+BLOCK_SIZE][j4][0];
          int vec1_y = j4*16 + img_mv[i4+BLOCK_SIZE][j4][1];

          mv[mv_idx].x = vec1_x;
          mv[mv_idx].y = vec1_y;
          mv[mv_idx].refframe = refframe;

          mbY.ret = 1;
          mbU.ret[k] = 1;
          mbV.ret[k] = 1;

      } else if (IS_NEWINTRA(currMB)) {
          mbY.ret = 2;
          mbU.ret[k] = 2;
          mbV.ret[k] = 2;
      } else {
          assert(0 == 1);
      }

      for(ii = 0; ii < BLOCK_SIZE; ii++)
          for(jj = 0; jj < BLOCK_SIZE; jj++) {
              mbY.block[ii][jj] = cof[i][j][ii][jj];
          }

      if(block_phase >= 15) {
          if(mb_phase >= (IMG_WIDTH/16)*(IMG_HEIGHT/16)-1) {
              mb_phase = 0;
          } else {
              mb_phase++;
          }

          block_phase = 0;
      } else {
          block_phase++;
      }

      memcpy(&mbY.mv, &mv[mv_idx], sizeof(MotionVector));
      memcpy(&mbU.mv[mv_idx], &mv[mv_idx], sizeof(MotionVector));
      memcpy(&mbV.mv[mv_idx], &mv[mv_idx], sizeof(MotionVector));

      memcpy(&frameY.blocks[l*4 + k], &mbY, sizeof(MacroBlockPacket_Y));
      
      mv_idx += 1;
      if(mv_idx >= 4)   mv_idx -= 4;
    }
    memcpy(&frameU.blocks[l], &mbU, sizeof(MacroBlockPacket_UV));
    memcpy(&frameV.blocks[l], &mbV, sizeof(MacroBlockPacket_UV));
  }
  memcpy(&frameY.deblockparams, &fp.deblockparams, sizeof(DeblockParams));
  memcpy(&frameY.frameinfo, &fi, sizeof(FrameInfo));

  char* mode_name = SYS_REQ(GET_CURRENT_MODE_NAME);
  if(strcmp(mode_name, "I_Frame")==0){
	MQ_SEND(port_outMB_intraY, (unsigned char*)&frameY, sizeof(FramePacket_Y));
    MQ_SEND(port_outMB_intraU, (unsigned char*)&frameU, sizeof(FramePacket_UV));
    MQ_SEND(port_outMB_intraV, (unsigned char*)&frameV, sizeof(FramePacket_UV));
  }
  else{
    MQ_SEND(port_outMB_interY, (unsigned char*)&frameY, sizeof(FramePacket_Y));
    MQ_SEND(port_outMB_interU, (unsigned char*)&frameU, sizeof(FramePacket_UV));
    MQ_SEND(port_outMB_interV, (unsigned char*)&frameV, sizeof(FramePacket_UV));
  }
}



/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
}

TASK_CODE_END
