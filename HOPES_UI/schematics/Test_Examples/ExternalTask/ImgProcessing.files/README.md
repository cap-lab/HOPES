Top-level Task graph             |  Task graph inside ImgProcessing_1
:-------------------------:|:-------------------------:
![](https://user-images.githubusercontent.com/84265864/200542192-b214bd5d-1358-4747-a576-68cf8c4db7b4.PNG)  |  ![](https://user-images.githubusercontent.com/84265864/200722077-3e9b23a5-7a95-4bb7-bbee-fbd79b7cc994.PNG)

<!--
Top-level Task graph             |  Task graph inside ImgProcessing_1             |  FSM inside Control task
:-------------------------:|:-------------------------:|:-------------------------:
![](https://user-images.githubusercontent.com/84265864/200542192-b214bd5d-1358-4747-a576-68cf8c4db7b4.PNG)  |  ![](https://user-images.githubusercontent.com/84265864/200722077-3e9b23a5-7a95-4bb7-bbee-fbd79b7cc994.PNG)  |  ![](https://user-images.githubusercontent.com/84265864/202096239-8cbd0ecd-8065-4caf-ad1f-1c7025971fe5.PNG)
-->

## Description
This example consists of 4 applications connected to a control task which controls the state of applications, and each application is structured in which a macro task and an external deep learning task are connected. There is a subgraph within macro task and it consists of 8 tasks to process the image. The control task is run on the dedicated core without contention.

After 30 seconds for the initialization, all applications run for 30 seconds concurrently.

<!--
There are 2 states in FSM as described in the below. Starting from the state0, the state is changed to state1 and all applications run for 10 seconds concurrently.
* state0: the initial state for the initialization such as loading networks
* state1: the state running all applications (Img_1+Jedi_1, Img_2+Jedi_2, Img_3+Jedi_3, Img_4+Jedi_4)
-->

In each application, 300 images (128x128) are read from the dataset one by one with 10 FPS (period = 100ms), and it is processed in two ways. 30 seconds X 10 FPS = 300 images are handled by each application. 
* Rescale it to 256x256, remove the noise, and pass it to the DL task(Jedi.cic) to perform object detection.
   * In each DL task, the network (yolov4, yolov2tiny, yolov3tiny, yolov4-csp) gets the data and process to detect the images.  
* Rescale it to 64x64, compress and save it.  

This example is generated by the [HOPES](https://github.com/cap-lab/HOPES) software synthesize framework.
The DL tasks are the wrapping tasks running the TensorRT-based networks by the use of the [JEDI](https://github.com/cap-lab/jedi.git) framework.
The mapping of the network is set by the JEDI framework while the mappings of other tasks are managed by [VPI](https://docs.nvidia.com/vpi/installation.html) library.

## Supported Platforms
* Executable on NVIDIA Jetson boards.
* We tested on NVIDIA Jetson AGX Xavier board with Jetpack 4.6 and TensorRT 8.0.1.

## Prerequisite
* OpenCV
* gdown
* [VPI](https://docs.nvidia.com/vpi/installation.html) (Vision Programming Interface)
* [JEDI](https://github.com/cap-lab/jedi/tree/tiny-lib) and all dependencies required by JEDI
* [tkDNN](https://github.com/urmydata/tkDNN) (The JEDI uses the tkDNN)
* Required files for the JEDI and tkDNN can be downloaded by the our script file which is explained in the "How to Compile" part.

## How to Compile
Clone the repository.
```
git clone https://github.com/sonjaewoo/hopes-jedi_example.git
```
Download the required files.
```
mkdir data && cd ./data/
gdown https://drive.google.com/uc?id=1tMc-aNpCP0YULRRzZiMDfDSUDVUGvrvI
```
If the download is not working, then download the file in the this [address](https://drive.google.com/file/d/1tMc-aNpCP0YULRRzZiMDfDSUDVUGvrvI/view?usp=share_link)

```
unzip ImgProcessing.zip
find . -name "*.gz" -exec tar xvfz {} \;
sudo ldconfig ${PWD}/lib
```
Compile
```
cd ../Jetson_Xavier/
dos2unix preinstall.sh
sh preinstall.sh
./configure
make
```

## How to Run
```
sudo jetson_clocks
sudo ./proc
```
It uses a "real-time" policies with the fixed-priority for CPU-mapped tasks, so the "sudo" privilege is needed to run.

## Output
Output files are saved in the _results_ directory.

![img1](https://user-images.githubusercontent.com/84265864/200725529-012831d5-fa6a-4045-98b2-1819c8e869d6.PNG)

Input image (128x128) is processed in two ways.
* It is rescaled to 256x256 and detection is processed.
* It is rescaled to 64x64 and compressed.
