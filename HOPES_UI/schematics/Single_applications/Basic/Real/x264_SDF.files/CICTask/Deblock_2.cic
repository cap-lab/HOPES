/************************************
 *
 * File : Deblock_2.cic
 * Date : Jul 23, 2009 11:13 AM
 *
*************************************/

/////////////////////////////////////
// include header section
/////////////////////////////////////

// ##DEFINE_SECTION::START
// ##DEFINE_SECTION::END

TASK_CODE_BEGIN

/////////////////////////////////////
// global definition
/////////////////////////////////////

// ##DEFINE_PORT_SECTION::START
STATIC int port_p24;
STATIC int port_p42;
// ##DEFINE_PORT_SECTION::END

/* Define macro for prototyping functions on ANSI & non-ANSI compilers */
#ifndef ARGS
#if defined(__STDC__) || defined(__cplusplus)
#define ARGS(args) args
#else
#define ARGS(args) ()
#endif
#endif

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "x264.h"
// by jwlee 2008.05.28
#include "ME.h"


typedef struct{
    int intFrameType;
    int MB_index_Enc;
    struct Uint8_tArr64 recon_block_U;
    struct Uint8_tArr64 recon_block_V;
    struct Uint8_tArr256 recon_block_1313;
    struct Uint8_tArr256 recon_block_1382;
    struct IntArr48 non_zero_count;
    deblock_send_info d_s_info;
} EncDbkPacket;


/* Define constants TRUE and FALSE for portability */
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

/* Define a complex data type if one has not been defined */
#if !defined(COMPLEX_DATA)
#define COMPLEX_DATA 1
typedef struct complex_data { double real; double imag; } complex;
#endif

#define CGC_MOD(a,b) ((a)>=(b) ? (a-b):(a))
#ifndef __CIC__
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#endif
/* original global declaration */
#define SPS_MB_WIDTH ((176+15)/16)    
#define SPS_MB_HEIGHT ((144+15)/16)
#define IS_INTRA(type) ( (type) == I_4x4 || (type) == I_8x8 || (type) == I_16x16)

int intra4x4_pred_mode_frm_1662[(176+15)/16 * (144+15)/16][7];   
uint8_t *p_Y_frm_buf_1663;
uint8_t *p_U_frm_buf_1664;
uint8_t *p_V_frm_buf_1665;
typedef void (*x264_deblock_inter_t)( uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0 );
typedef void (*x264_deblock_intra_t)( uint8_t *pix, int stride, int alpha, int beta );
typedef struct {
    uint8_t data[176*144];
} Frame1;
typedef struct {
    uint8_t data[176*144/4];
} HalfFrame1;
uint8_t *plane0_1666;
uint8_t *plane1_1667;
uint8_t *plane2_1668;
uint8_t *plane0_1669;
uint8_t *filtered1_1670;
uint8_t *filtered2_1671;
uint8_t *filtered3_1672;
int expand_1673 = 0;
int quiet_1674 = 1;

int convmat_1675[8][4]
=
{
    {117504, 138453, 13954, 34903}, /* no sequence_display_extension */
    {117504, 138453, 13954, 34903}, /* ITU-R Rec. 709 (1990) */
    {104597, 132201, 25675, 53279}, /* unspecified */
    {104597, 132201, 25675, 53279}, /* reserved */
    {104448, 132798, 24759, 53109}, /* FCC */
    {104597, 132201, 25675, 53279}, /* ITU-R Rec. 624-4 System B, G */
    {104597, 132201, 25675, 53279}, /* SMPTE 170M */
    {117579, 136230, 16907, 35559}  /* SMPTE 240M (1987) */
};
unsigned char *clp_1676;
unsigned char clpGlobal_1677[1024];
#define max(a, b) (((a) > (b)) ? (a) : (b))
#define mmax(a, b) (((a) > (b)) ? (a) : (b))
#define min(a, b) (((a) < (b)) ? (a) : (b))
#define mmin(a, b) (((a) < (b)) ? (a) : (b))
struct FrameLuma recon_frame_Y_1599;
struct FrameChroma recon_frame_U_1600;
struct FrameChroma recon_frame_V_1601;
struct ref_mb ref_mb_1604;
struct mb_frm mb_frm_1609;
struct nzc_frm nzc_frm_1610;
struct ref_frm ref_frm_1611;
struct mv_frm mv_frm_1612;
struct FrameLuma recon_frame_Y_1613;
struct FrameChroma recon_frame_U_1614;
struct FrameChroma recon_frame_V_1615;
Frame1 display_Y_1616;
HalfFrame1 display_U_1617;
HalfFrame1 display_V_1618;
struct FrameLuma Filtered_frame_1_1619;
struct FrameLuma Filtered_frame_2_1620;
struct FrameLuma Filtered_frame_3_1621;
int output_1630;
int output_1708_phase;
struct Uint8_tArr256 output_1634;
struct Uint8_tArr256 output_1635;
struct Uint8_tArr64 output_1636;
struct Uint8_tArr64 output_1637;
struct IntArr48 output_1639;
int output_1642;



/* new global declaration */
/*
int fid_1709;//
int fid_1717;//
int fid_1719;//
int fid_1721;///
int fid_1723;//
int fid_1727;//
int fid_1735;//

int fid_5040;//
int fid_5041;//
int fid_5042;//
*/


// jwlee 080516
int mb_index_Debl;
int MB_Available[99];
STATIC int R_Available;
STATIC int LD_Available;


deblock_send_info d_r_info;
neighbour_info info_R;
neighbour_info info_LD;

neighbour_info info_Buffer[99];

#define GO_NOT          0
#define GO_RIGHT        1
#define GO_LEFTDOWN     2
#define GO_ALL          3

// find MB to process added by jwlee
//  [           ][     ][          ][     ][DONE? DO A!]
//  [           ][     ][ mb_index ][  A  ]
//  [DONE? DO B!][  B  ]
//  
//  XX = 0
//  AX = 1
//  XB = 2
//  AB = 3
//        else if (mb_index == SPS_MB_HEIGHT*SPS_MB_HEIGHT-1);
//

STATIC int get_MB_Available(int x, int y)
{
    if(x < 0 || x >= SPS_MB_WIDTH)
        return 1;
    if(y < 0 || y >= SPS_MB_HEIGHT)
        return 1;
    if(MB_Available[x + y * SPS_MB_WIDTH] == 1)
        return 1;
    else
        return 0;
}

void MB_finder ( int mb_index,int Y_stride, int * MB_Available )
{
    int mb_x = mb_index % Y_stride;
    int mb_y = mb_index / Y_stride;

    R_Available = LD_Available = 0;

    if(get_MB_Available(mb_x+2, mb_y-1)==1)
    {
        if(mb_x+1 < SPS_MB_WIDTH)
            R_Available = 1;
    }
    if(get_MB_Available(mb_x-2, mb_y+1)==1)
    {
        if(mb_x-1 >= 0 && mb_y+1 < SPS_MB_HEIGHT)
            LD_Available = 1;
    }
}



STATIC void construct_luma_frm(int mb_xy, int mb_width, int stride, uint8_t recon_block[256])
{
    int i;
    int x_pos = mb_xy % mb_width;
    int y_pos = mb_xy / mb_width;

    for (i = 0 ; i < 16 ; i++)
        memcpy(p_Y_frm_buf_1663 + (16*y_pos+i) * stride + (16*x_pos), &recon_block[i*16], sizeof(uint8_t)*16);
}
STATIC void construct_chroma_frm(int mb_xy, int mb_width, int stride, uint8_t recon_block[256], uint8_t *dst)
{
    int i;
    int x_pos = mb_xy % mb_width;
    int y_pos = mb_xy / mb_width;

    for (i = 0 ; i < 8 ; i++)
        memcpy(dst + (8*y_pos+i) * stride + (8*x_pos), &recon_block[i*8], sizeof(uint8_t)*8);
}
STATIC void save_i4x4_nzc(int i_mb_type, int i_mb_xy, int i_pred4x4[4][4], int non_zero_count[48], int nzc_frm[(176+15)/16 * (144+15)/16][16+4+4]) {
    int i;

    if( i_mb_type == I_4x4 )
    {
        intra4x4_pred_mode_frm_1662[i_mb_xy][0] = i_pred4x4[block_idx_x[10]][block_idx_y[10]];
        intra4x4_pred_mode_frm_1662[i_mb_xy][1] = i_pred4x4[block_idx_x[11]][block_idx_y[11]];
        intra4x4_pred_mode_frm_1662[i_mb_xy][2] = i_pred4x4[block_idx_x[14]][block_idx_y[14]];
        intra4x4_pred_mode_frm_1662[i_mb_xy][3] = i_pred4x4[block_idx_x[15]][block_idx_y[15]];
        intra4x4_pred_mode_frm_1662[i_mb_xy][4] = i_pred4x4[block_idx_x[5]][block_idx_y[5]];
        intra4x4_pred_mode_frm_1662[i_mb_xy][5] = i_pred4x4[block_idx_x[7]][block_idx_y[7]];
        intra4x4_pred_mode_frm_1662[i_mb_xy][6] = i_pred4x4[block_idx_x[13]][block_idx_y[13]];
    }
    else
    {
        intra4x4_pred_mode_frm_1662[i_mb_xy][0] =
            intra4x4_pred_mode_frm_1662[i_mb_xy][1] =
            intra4x4_pred_mode_frm_1662[i_mb_xy][2] =
            intra4x4_pred_mode_frm_1662[i_mb_xy][3] =
            intra4x4_pred_mode_frm_1662[i_mb_xy][4] =
            intra4x4_pred_mode_frm_1662[i_mb_xy][5] =
            intra4x4_pred_mode_frm_1662[i_mb_xy][6] = I_PRED_4x4_DC;
    }

    if( i_mb_type != I_PCM )
    {
        /* save non zero count */
        for( i = 0; i < 16 + 2*4; i++ )
        {
            nzc_frm[i_mb_xy][i] = non_zero_count[x264_scan8[i]];
        }
    }
}
STATIC void save_ref_mv(int i_mb_type, int i_mb_xy, int8_t ref_mb[2][48], int16_t mv_mb[2][48][2], 
        int8_t ref_frm[(176+15)/16 * (144+15)/16 * 4], int16_t mv_frm[(176+15)/16 * (144+15)/16 * 2 * 16][2])
{
    int i_mb_x = i_mb_xy % SPS_MB_WIDTH;
    int i_mb_y = i_mb_xy / SPS_MB_WIDTH;

    int s4x4 = SPS_MB_WIDTH * 4;
    int s8x8 = SPS_MB_WIDTH * 2;

    int i_mb_4x4 = 4 * (i_mb_y * s4x4 + i_mb_x);
    int i_mb_8x8 = 2 * (i_mb_y * s8x8 + i_mb_x);

    if( !IS_INTRA( i_mb_type ) )
    {
        int y,x;

        ref_frm[i_mb_8x8+0+0*s8x8] = ref_mb[0][x264_scan8[0]];
        ref_frm[i_mb_8x8+1+0*s8x8] = ref_mb[0][x264_scan8[4]];
        ref_frm[i_mb_8x8+0+1*s8x8] = ref_mb[0][x264_scan8[8]];
        ref_frm[i_mb_8x8+1+1*s8x8] = ref_mb[0][x264_scan8[12]];

        for( y = 0; y < 4; y++ )
        {
            for( x = 0; x < 4; x++ )
            {
                mv_frm[i_mb_4x4+x+y*s4x4][0] = mv_mb[0][x264_scan8[0]+x+8*y][0];
                mv_frm[i_mb_4x4+x+y*s4x4][1] = mv_mb[0][x264_scan8[0]+x+8*y][1];
            }
        }
    }
    else
    {
        int y,x;

        ref_frm[i_mb_8x8+0+0*s8x8] =
            ref_frm[i_mb_8x8+1+0*s8x8] =
            ref_frm[i_mb_8x8+0+1*s8x8] =
            ref_frm[i_mb_8x8+1+1*s8x8] = -1;
        for( y = 0; y < 4; y++ )
        {
            for( x = 0; x < 4; x++ )
            {
                mv_frm[i_mb_4x4+x+y*s4x4][0] = 0;
                mv_frm[i_mb_4x4+x+y*s4x4][1] = 0;
            }
        }
    }
}
STATIC void load_i4x4_nzc(int i_mb_type, int i_mb_xy, int *i_neighbour, int *b_fast_intra, int i_pred4x4[48], int non_zero_count[48], 
        int nzc_frm[(176+15)/16 * (144+15)/16][16+4+4], int8_t mb_frm[((176+15)/16) * ((144+15)/16)])
{
    int i_mb_x = i_mb_xy % SPS_MB_WIDTH;
    int i_mb_y = i_mb_xy / SPS_MB_WIDTH;

    int i_top_xy = i_mb_xy - SPS_MB_WIDTH;
    int i_left_xy = -1;
    int i_top_type = -1;
    int i_left_type = -1;

    int i_mb_type_top  = -1;
    int i_mb_type_left = -1;
    int i_mb_type_topleft = -1;
    int i_mb_type_topright = -1;

    *i_neighbour = 0;
    *b_fast_intra = 0;

    if( i_mb_xy >= SPS_MB_WIDTH ) // top available
    {
        i_mb_type_top = i_top_type =  mb_frm[i_top_xy];

        *i_neighbour |= MB_TOP;

        /* load intra4x4 */

        i_pred4x4[x264_scan8[0] - 8] = intra4x4_pred_mode_frm_1662[i_top_xy][0];
        i_pred4x4[x264_scan8[1] - 8] = intra4x4_pred_mode_frm_1662[i_top_xy][1];
        i_pred4x4[x264_scan8[4] - 8] = intra4x4_pred_mode_frm_1662[i_top_xy][2];
        i_pred4x4[x264_scan8[5] - 8] = intra4x4_pred_mode_frm_1662[i_top_xy][3];


        /* load non_zero_count */

        non_zero_count[x264_scan8[0] - 8] = nzc_frm[i_top_xy][10];
        non_zero_count[x264_scan8[1] - 8] = nzc_frm[i_top_xy][11];
        non_zero_count[x264_scan8[4] - 8] = nzc_frm[i_top_xy][14];
        non_zero_count[x264_scan8[5] - 8] = nzc_frm[i_top_xy][15];

        non_zero_count[x264_scan8[16+0] - 8] = nzc_frm[i_top_xy][16+2];
        non_zero_count[x264_scan8[16+1] - 8] = nzc_frm[i_top_xy][16+3];

        non_zero_count[x264_scan8[16+4+0] - 8] = nzc_frm[i_top_xy][16+4+2];
        non_zero_count[x264_scan8[16+4+1] - 8] = nzc_frm[i_top_xy][16+4+3];

    }
    else
    {
        i_mb_type_top = -1;

        /* load intra4x4 */
        i_pred4x4[x264_scan8[0] - 8] =
            i_pred4x4[x264_scan8[1] - 8] =
            i_pred4x4[x264_scan8[4] - 8] =
            i_pred4x4[x264_scan8[5] - 8] = -1;

        /* load non_zero_count */
        non_zero_count[x264_scan8[0] - 8] =
            non_zero_count[x264_scan8[1] - 8] =
            non_zero_count[x264_scan8[4] - 8] =
            non_zero_count[x264_scan8[5] - 8] =
            non_zero_count[x264_scan8[16+0] - 8] =
            non_zero_count[x264_scan8[16+1] - 8] =
            non_zero_count[x264_scan8[16+4+0] - 8] =
            non_zero_count[x264_scan8[16+4+1] - 8] = 0x80;

    }

    if( i_mb_x > 0 && i_mb_xy > 0) // left available
    {
        i_left_xy = i_mb_xy - 1;
        i_mb_type_left = i_left_type = mb_frm[i_left_xy];

        *i_neighbour |= MB_LEFT;

        /* load intra4x4 */
        i_pred4x4[x264_scan8[0 ] - 1] = intra4x4_pred_mode_frm_1662[i_left_xy][4];
        i_pred4x4[x264_scan8[2 ] - 1] = intra4x4_pred_mode_frm_1662[i_left_xy][5];
        i_pred4x4[x264_scan8[8 ] - 1] = intra4x4_pred_mode_frm_1662[i_left_xy][6];
        i_pred4x4[x264_scan8[10] - 1] = intra4x4_pred_mode_frm_1662[i_left_xy][3];

        /* load non_zero_count */
        non_zero_count[x264_scan8[0 ] - 1] = nzc_frm[i_left_xy][5];
        non_zero_count[x264_scan8[2 ] - 1] = nzc_frm[i_left_xy][7];
        non_zero_count[x264_scan8[8 ] - 1] = nzc_frm[i_left_xy][13];
        non_zero_count[x264_scan8[10] - 1] = nzc_frm[i_left_xy][15];

        non_zero_count[x264_scan8[16+0] - 1] = nzc_frm[i_left_xy][16+1];
        non_zero_count[x264_scan8[16+2] - 1] = nzc_frm[i_left_xy][16+3];

        non_zero_count[x264_scan8[16+4+0] - 1] = nzc_frm[i_left_xy][16+4+1];
        non_zero_count[x264_scan8[16+4+2] - 1] = nzc_frm[i_left_xy][16+4+3];
    }
    else
    {
        i_mb_type_left = -1;

        i_pred4x4[x264_scan8[0 ] - 1] =
            i_pred4x4[x264_scan8[2 ] - 1] =
            i_pred4x4[x264_scan8[8 ] - 1] =
            i_pred4x4[x264_scan8[10] - 1] = -1;

        /* load non_zero_count */
        non_zero_count[x264_scan8[0 ] - 1] =
            non_zero_count[x264_scan8[2 ] - 1] =
            non_zero_count[x264_scan8[8 ] - 1] =
            non_zero_count[x264_scan8[10] - 1] =
            non_zero_count[x264_scan8[16+0] - 1] =
            non_zero_count[x264_scan8[16+2] - 1] =
            non_zero_count[x264_scan8[16+4+0] - 1] =
            non_zero_count[x264_scan8[16+4+2] - 1] = 0x80;
    }

    if( i_mb_x < SPS_MB_WIDTH - 1 && i_top_xy + 1 >= 0 )
    {
        *i_neighbour |= MB_TOPRIGHT;
        i_mb_type_topright = mb_frm[ i_top_xy + 1 ];
    }
    else
        i_mb_type_topright = -1;

    if( i_mb_x > 0 && i_top_xy - 1 >= 0)
    {
        *i_neighbour |= MB_TOPLEFT;
        i_mb_type_topleft = mb_frm[ i_top_xy - 1 ];
    }
    else
        i_mb_type_topleft = -1;    

    if( i_mb_xy > 4 )
    {
        if(IS_INTRA(i_mb_type_left )
                || IS_INTRA(i_mb_type_top )
                || IS_INTRA(i_mb_type_topleft )
                || IS_INTRA(i_mb_type_topright ))
        { /* intra is likely */ }
        else
        {
            *b_fast_intra = 1;
        }
    }        
}
STATIC void load_ref_mv(int frame_type, int mb_type, int i_neighbour, int i_mb_xy, int8_t ref_mb[2][48], int16_t mv_mb[2][48][2], 
        int8_t ref_frm[(176+15)/16 * (144+15)/16 * 4], int16_t mv_frm[(176+15)/16 * (144+15)/16 * 2 * 16][2]) {
    if( frame_type )
    {
        int i;

        int i_mb_x = i_mb_xy % SPS_MB_WIDTH;
        int i_mb_y = i_mb_xy / SPS_MB_WIDTH;

        const int s4x4 = SPS_MB_WIDTH * 4;
        const int s8x8 = SPS_MB_WIDTH * 2;

        int i_mb_4x4 = 4 * (i_mb_y * s4x4 + i_mb_x);
        int i_mb_8x8 = 2 * (i_mb_y * s8x8 + i_mb_x);

        {
            if( i_neighbour & MB_TOPLEFT )
            {
                const int i8 = x264_scan8[0] - 1 - 1*8;
                const int ir = i_mb_8x8 - s8x8 - 1;
                const int iv = i_mb_4x4 - s4x4 - 1;

                ref_mb[0][i8]  = ref_frm[ir];
                mv_mb[0][i8][0] = mv_frm[iv][0];
                mv_mb[0][i8][1] = mv_frm[iv][1];
            }
            else
            {
                const int i8 = x264_scan8[0] - 1 - 1*8;

                ref_mb[0][i8] = -2;
                mv_mb[0][i8][0] = 0;
                mv_mb[0][i8][1] = 0;
            }

            if(i_neighbour & MB_TOP )
            {
                const int i8 = x264_scan8[0] - 8;
                const int ir = i_mb_8x8 - s8x8;
                const int iv = i_mb_4x4 - s4x4;

                ref_mb[0][i8+0] =
                    ref_mb[0][i8+1] = ref_frm[ir + 0];
                ref_mb[0][i8+2] =
                    ref_mb[0][i8+3] = ref_frm[ir + 1];
                for( i = 0; i < 4; i++ )
                {
                    mv_mb[0][i8+i][0] = mv_frm[iv + i][0];
                    mv_mb[0][i8+i][1] = mv_frm[iv + i][1];
                }
            }
            else
            {
                const int i8 = x264_scan8[0] - 8;
                for( i = 0; i < 4; i++ )
                {
                    ref_mb[0][i8+i] = -2;
                    mv_mb[0][i8+i][0] =
                        mv_mb[0][i8+i][1] = 0;
                }
            }

            if( i_neighbour & MB_TOPRIGHT )
            {
                const int i8 = x264_scan8[0] + 4 - 1*8;
                const int ir = i_mb_8x8 - s8x8 + 2;
                const int iv = i_mb_4x4 - s4x4 + 4;

                ref_mb[0][i8]  = ref_frm[ir];
                mv_mb[0][i8][0] = mv_frm[iv][0];
                mv_mb[0][i8][1] = mv_frm[iv][1];
            }
            else
            {
                const int i8 = x264_scan8[0] + 4 - 1*8;

                ref_mb[0][i8] = -2;
                mv_mb[0][i8][0] = 0;
                mv_mb[0][i8][1] = 0;
            }

            if( i_neighbour & MB_LEFT )
            {
                const int i8 = x264_scan8[0] - 1;
                const int ir = i_mb_8x8 - 1;
                const int iv = i_mb_4x4 - 1;

                ref_mb[0][i8+0*8] =
                    ref_mb[0][i8+1*8] = ref_frm[ir + 0*s8x8];
                ref_mb[0][i8+2*8] =
                    ref_mb[0][i8+3*8] = ref_frm[ir + 1*s8x8];

                for( i = 0; i < 4; i++ )
                {
                    mv_mb[0][i8+i*8][0] = mv_frm[iv + i*s4x4][0];
                    mv_mb[0][i8+i*8][1] = mv_frm[iv + i*s4x4][1];
                }
            }
            else
            {
                const int i8 = x264_scan8[0] - 1;
                for( i = 0; i < 4; i++ )
                {
                    ref_mb[0][i8+i*8] = -2;
                    mv_mb[0][i8+i*8][0] =
                        mv_mb[0][i8+i*8][1] = 0;
                }
            }
        }
    }
}
STATIC void load_preddata(int i_mb_xy, int i_neighbour, int stride_luma, int stride_chroma, uint8_t preddata16[2][21], uint8_t preddata8_U[2][9], uint8_t preddata8_V[2][9]) {
    int i_mb_x = i_mb_xy % SPS_MB_WIDTH;
    int i_mb_y = i_mb_xy / SPS_MB_WIDTH;

    uint8_t *p_Y = p_Y_frm_buf_1663 + (i_mb_y * 16 * stride_luma) + (i_mb_x * 16);
    uint8_t *p_U = p_U_frm_buf_1664 + (i_mb_y * 8 * stride_chroma) + (i_mb_x * 8);
    uint8_t *p_V = p_V_frm_buf_1665 + (i_mb_y * 8 * stride_chroma) + (i_mb_x * 8);

    if (i_neighbour & MB_TOP) {
        int i;

        for (i = 0 ; i < 20 ; i++) preddata16[0][i+1] = p_Y[i - stride_luma];
        for (i = 0 ; i < 8 ; i++) {
            preddata8_U[0][i+1] = p_U[i - stride_chroma];
            preddata8_V[0][i+1] = p_V[i - stride_chroma];
        }
    }
    if (i_neighbour & MB_LEFT) {
        int i;

        for (i = 1 ; i < 17 ; i++) preddata16[1][i] = p_Y[stride_luma*(i-1) - 1];
        for (i = 1 ; i < 9 ; i++) {
            preddata8_U[1][i] = p_U[stride_chroma*(i-1) - 1];
            preddata8_V[1][i] = p_V[stride_chroma*(i-1) - 1];
        }
    }	 
    if (i_neighbour & MB_TOPLEFT) {
        preddata16[0][0] = preddata16[1][0] = p_Y[-stride_luma-1];
        preddata8_U[0][0] = preddata8_U[1][0] = p_U[-stride_chroma - 1];
        preddata8_V[0][0] = preddata8_V[1][0] = p_V[-stride_chroma - 1];
    }
}
STATIC inline int x264_clip3( int v, int i_min, int i_max )
{
    return ( (v < i_min) ? i_min : (v > i_max) ? i_max : v );
}
STATIC inline int clip_uint8( int a )
{
    if (a&(~255))
        return (-a)>>31;
    else
        return a;
}
STATIC void deblock_luma_c( uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0 )
{
    int i, d;
    for( i = 0; i < 4; i++ ) {
        if( tc0[i] < 0 ) {
            pix += 4*ystride;
            continue;
        }
        for( d = 0; d < 4; d++ ) {
            const int p2 = pix[-3*xstride];
            const int p1 = pix[-2*xstride];
            const int p0 = pix[-1*xstride];
            const int q0 = pix[ 0*xstride];
            const int q1 = pix[ 1*xstride];
            const int q2 = pix[ 2*xstride];

            if( abs( p0 - q0 ) < alpha &&
                    abs( p1 - p0 ) < beta &&
                    abs( q1 - q0 ) < beta ) {

                int tc = tc0[i];
                int delta;

                if( abs( p2 - p0 ) < beta ) {
                    pix[-2*xstride] = p1 + x264_clip3( (( p2 + ((p0 + q0 + 1) >> 1)) >> 1) - p1, -tc0[i], tc0[i] );
                    tc++; 
                }
                if( abs( q2 - q0 ) < beta ) {
                    pix[ 1*xstride] = q1 + x264_clip3( (( q2 + ((p0 + q0 + 1) >> 1)) >> 1) - q1, -tc0[i], tc0[i] );
                    tc++;
                }

                delta = x264_clip3( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );
                pix[-1*xstride] = clip_uint8( p0 + delta );    /* p0' */
                pix[ 0*xstride] = clip_uint8( q0 - delta );    /* q0' */
            }
            pix += ystride;
        }
    }
}

STATIC void deblock_luma_intra_c( uint8_t *pix, int xstride, int ystride, int alpha, int beta )
{
    int d;
    for( d = 0; d < 16; d++ ) {
        const int p2 = pix[-3*xstride];
        const int p1 = pix[-2*xstride];
        const int p0 = pix[-1*xstride];
        const int q0 = pix[ 0*xstride];
        const int q1 = pix[ 1*xstride];
        const int q2 = pix[ 2*xstride];

        if( abs( p0 - q0 ) < alpha &&
                abs( p1 - p0 ) < beta &&
                abs( q1 - q0 ) < beta ) {

            if(abs( p0 - q0 ) < ((alpha >> 2) + 2) ){
                if( abs( p2 - p0 ) < beta)
                {
                    const int p3 = pix[-4*xstride];
                    /* p0', p1', p2' */
                    pix[-1*xstride] = ( p2 + 2*p1 + 2*p0 + 2*q0 + q1 + 4 ) >> 3;
                    pix[-2*xstride] = ( p2 + p1 + p0 + q0 + 2 ) >> 2;
                    pix[-3*xstride] = ( 2*p3 + 3*p2 + p1 + p0 + q0 + 4 ) >> 3;
                } else {
                    /* p0' */
                    pix[-1*xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;
                }
                if( abs( q2 - q0 ) < beta)
                {
                    const int q3 = pix[3*xstride];
                    /* q0', q1', q2' */
                    pix[0*xstride] = ( p1 + 2*p0 + 2*q0 + 2*q1 + q2 + 4 ) >> 3;
                    pix[1*xstride] = ( p0 + q0 + q1 + q2 + 2 ) >> 2;
                    pix[2*xstride] = ( 2*q3 + 3*q2 + q1 + q0 + p0 + 4 ) >> 3;
                } else {
                    /* q0' */
                    pix[0*xstride] = ( 2*q1 + q0 + p1 + 2 ) >> 2;
                }
            }else{
                /* p0', q0' */
                pix[-1*xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;
                pix[ 0*xstride] = ( 2*q1 + q0 + p1 + 2 ) >> 2;
            }
        }
        pix += ystride;
    }
}
STATIC void deblock_chroma_c( uint8_t *pix, int xstride, int ystride, int alpha, int beta, int8_t *tc0 )
{
    int i, d;
    for( i = 0; i < 4; i++ ) {
        const int tc = tc0[i];
        if( tc <= 0 ) {
            pix += 2*ystride;
            continue;
        }
        for( d = 0; d < 2; d++ ) {
            const int p1 = pix[-2*xstride];
            const int p0 = pix[-1*xstride];
            const int q0 = pix[ 0*xstride];
            const int q1 = pix[ 1*xstride];

            if( abs( p0 - q0 ) < alpha &&
                    abs( p1 - p0 ) < beta &&
                    abs( q1 - q0 ) < beta ) {

                int delta = x264_clip3( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc );
                pix[-1*xstride] = clip_uint8( p0 + delta );    /* p0' */
                pix[ 0*xstride] = clip_uint8( q0 - delta );    /* q0' */
            }
            pix += ystride;
        }
    }
}

STATIC void deblock_chroma_intra_c( uint8_t *pix, int xstride, int ystride, int alpha, int beta )
{   
    int d; 
    for( d = 0; d < 8; d++ ) {
        const int p1 = pix[-2*xstride];
        const int p0 = pix[-1*xstride];
        const int q0 = pix[ 0*xstride];
        const int q1 = pix[ 1*xstride];

        if( abs( p0 - q0 ) < alpha &&
                abs( p1 - p0 ) < beta &&
                abs( q1 - q0 ) < beta ) {

            pix[-1*xstride] = (2*p1 + p0 + q1 + 2) >> 2;   /* p0' */
            pix[ 0*xstride] = (2*q1 + q0 + p1 + 2) >> 2;   /* q0' */
        }

        pix += ystride;
    }
}
STATIC void deblock_h_luma_c( uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0 )
{
    deblock_luma_c( pix, 1, stride, alpha, beta, tc0 );
}
STATIC void deblock_h_luma_intra_c( uint8_t *pix, int stride, int alpha, int beta )
{   
    deblock_luma_intra_c( pix, 1, stride, alpha, beta );
}
STATIC void deblock_h_chroma_c( uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0 )
{   
    deblock_chroma_c( pix, 1, stride, alpha, beta, tc0 );
}

STATIC void deblock_h_chroma_intra_c( uint8_t *pix, int stride, int alpha, int beta )
{   
    deblock_chroma_intra_c( pix, 1, stride, alpha, beta );
}

STATIC void deblock_v_luma_c( uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0 )
{
    deblock_luma_c( pix, stride, 1, alpha, beta, tc0 ); 
}
STATIC void deblock_v_luma_intra_c( uint8_t *pix, int stride, int alpha, int beta )
{   
    deblock_luma_intra_c( pix, stride, 1, alpha, beta );
}
STATIC void deblock_v_chroma_c( uint8_t *pix, int stride, int alpha, int beta, int8_t *tc0 )
{   
    deblock_chroma_c( pix, stride, 1, alpha, beta, tc0 );
}
STATIC void deblock_v_chroma_intra_c( uint8_t *pix, int stride, int alpha, int beta )
{   
    deblock_chroma_intra_c( pix, stride, 1, alpha, beta );
}
STATIC void deblock_edge(uint8_t *pix, int i_stride, int bS[4], int i_qp, int b_chroma,
        x264_deblock_inter_t pf_inter, x264_deblock_intra_t pf_intra )
{
    int i;
    const int index_a = x264_clip3( i_qp, 0, 51 );
    const int alpha = i_alpha_table[index_a];
    const int beta  = i_beta_table[x264_clip3( i_qp, 0, 51 )];

    if( bS[0] < 4 ) {
        int8_t tc[4]; 
        for(i=0; i<4; i++)
            tc[i] = (bS[i] ? i_tc0_table[index_a][bS[i] - 1] : -1) + b_chroma;
        pf_inter( pix, i_stride, alpha, beta, tc );
    } else {
        pf_intra( pix, i_stride, alpha, beta );
    }
}
STATIC void plane_expand_border( uint8_t *pix, int i_stride, int i_height, int i_pad )
{
#define PPIXEL(x, y) ( pix + (x) + (y)*i_stride )
    const int i_width = i_stride - 2*i_pad;
    int y;

    for( y = 0; y < i_height; y++ )
    {
        /* left band */
        memset( PPIXEL(-i_pad, y), PPIXEL(0, y)[0], i_pad );
        /* right band */
        memset( PPIXEL(i_width, y), PPIXEL(i_width-1, y)[0], i_pad );
    }
    /* upper band */
    for( y = 0; y < i_pad; y++ )
        memcpy( PPIXEL(-i_pad, -y-1), PPIXEL(-i_pad, 0), i_stride );
    /* lower band */
    for( y = 0; y < i_pad; y++ )
        memcpy( PPIXEL(-i_pad, i_height+y), PPIXEL(-i_pad, i_height-1), i_stride );
#undef PPIXEL
}
STATIC void x264_frame_deblocking_filter(int frame_type, 
        int8_t mb_type[(176+15)/16 * (144+15)/16], 
        int non_zero_count[(176+15)/16 * (144+15)/16][16+4+4], 
        int8_t ref_frm[(176+15)/16 * (144+15)/16 * 4], 
        int16_t mv_frm[(176+15)/16 * (144+15)/16 * 2 * 16][2])
{
    const int s8x8 = 2 * SPS_MB_WIDTH;
    const int s4x4 = 4 * SPS_MB_HEIGHT;

    int mb_y, mb_x;

    for( mb_y = 0, mb_x = 0; mb_y < SPS_MB_HEIGHT; )
    {
        const int mb_xy  = mb_y * SPS_MB_WIDTH + mb_x;
        const int mb_8x8 = 2 * s8x8 * mb_y + 2 * mb_x;
        const int mb_4x4 = 4 * s4x4 * mb_y + 4 * mb_x;
        int i_edge;
        int i_dir;

        /* i_dir == 0 -> vertical edge
         * i_dir == 1 -> horizontal edge */
        for( i_dir = 0; i_dir < 2; i_dir++ )
        {
            int i_start;
            int i_qp, i_qpn;

            i_start = (( i_dir == 0 && mb_x != 0 ) || ( i_dir == 1 && mb_y != 0 ) ) ? 0 : 1;

            for( i_edge = i_start; i_edge < 4; i_edge++ )
            {
                int mbn_xy  = i_edge > 0 ? mb_xy  : ( i_dir == 0 ? mb_xy  - 1 : mb_xy - SPS_MB_WIDTH );
                int mbn_8x8 = i_edge > 0 ? mb_8x8 : ( i_dir == 0 ? mb_8x8 - 2 : mb_8x8 - 2 * s8x8 );
                int mbn_4x4 = i_edge > 0 ? mb_4x4 : ( i_dir == 0 ? mb_4x4 - 4 : mb_4x4 - 4 * s4x4 );

                int bS[4];  /* filtering strength */

                /* *** Get bS for each 4px for the current edge *** */
                if( IS_INTRA( mb_type[mb_xy] ) || IS_INTRA( mb_type[mbn_xy] ) )
                {
                    bS[0] = bS[1] = bS[2] = bS[3] = ( i_edge == 0 ? 4 : 3 );
                }
                else
                {
                    int i;
                    for( i = 0; i < 4; i++ )
                    {
                        int x  = i_dir == 0 ? i_edge : i;
                        int y  = i_dir == 0 ? i      : i_edge;
                        int xn = (x - (i_dir == 0 ? 1 : 0 ))&0x03;
                        int yn = (y - (i_dir == 0 ? 0 : 1 ))&0x03;

                        if( non_zero_count[mb_xy][block_idx_xy[x][y]] != 0 ||
                                non_zero_count[mbn_xy][block_idx_xy[xn][yn]] != 0 )
                        {
                            bS[i] = 2;
                        }
                        else
                        {
                            /* FIXME: A given frame may occupy more than one position in
                             * the reference list. So we should compare the frame numbers,
                             * not the indices in the ref list.
                             * No harm yet, as we don't generate that case.*/

                            int i8p= mb_8x8+(x/2)+(y/2)*s8x8;
                            int i8q= mbn_8x8+(xn/2)+(yn/2)*s8x8;
                            int i4p= mb_4x4+x+y*s4x4;
                            int i4q= mbn_4x4+xn+yn*s4x4;
                            int l;

                            bS[i] = 0;

                            if( ref_frm[i8p] != ref_frm[i8q] ||
                                    abs( mv_frm[i4p][0] - mv_frm[i4q][0] ) >= 4 ||
                                    abs( mv_frm[i4p][1] - mv_frm[i4q][1] ) >= 4 )
                            {
                                bS[i] = 1;
                            }
                        }
                    }
                }

                /* *** filter *** */
                /* Y plane */
                i_qp = frame_type == 0 ? 23 : 26;
                i_qpn= frame_type == 0 ? 23 : 26;

                if( i_dir == 0 )
                {
                    /* vertical edge */
                    deblock_edge( &plane0_1666[16*mb_y * (176+64) + 16*mb_x + 4*i_edge],
                            176+64, bS, (i_qp+i_qpn+1) >> 1, 0,
                            deblock_h_luma_c, deblock_h_luma_intra_c );
                    if( !(i_edge & 1) )
                    {
                        /* U/V planes */
                        int i_qpc = ( i_chroma_qp_table[x264_clip3( i_qp, 0, 51 )] +
                                i_chroma_qp_table[x264_clip3( i_qpn, 0, 51 )] + 1 ) >> 1;
                        deblock_edge( &plane1_1667[8*(mb_y*(176+64)/2+mb_x)+2*i_edge],
                                (176+64)/2, bS, i_qpc, 1,
                                deblock_h_chroma_c, deblock_h_chroma_intra_c );
                        deblock_edge( &plane2_1668[8*(mb_y*(176+64)/2+mb_x)+2*i_edge],
                                (176+64)/2, bS, i_qpc, 1,
                                deblock_h_chroma_c, deblock_h_chroma_intra_c );
                    }
                }
                else
                {
                    /* horizontal edge */
                    deblock_edge( &plane0_1666[(16*mb_y + 4*i_edge) * (176+64) + 16*mb_x],
                            176+64, bS, (i_qp+i_qpn+1) >> 1, 0,
                            deblock_v_luma_c, deblock_v_luma_intra_c );
                    /* U/V planes */
                    if( !(i_edge & 1) )
                    {
                        int i_qpc = ( i_chroma_qp_table[x264_clip3( i_qp, 0, 51 )] +
                                i_chroma_qp_table[x264_clip3( i_qpn, 0, 51 )] + 1 ) >> 1;
                        deblock_edge( &plane1_1667[8*(mb_y*(176+64)/2+mb_x)+2*i_edge*(176+64)/2],
                                (176+64)/2, bS, i_qpc, 1,
                                deblock_v_chroma_c, deblock_v_chroma_intra_c );
                        deblock_edge( &plane2_1668[8*(mb_y*(176+64)/2+mb_x)+2*i_edge*(176+64)/2],
                                (176+64)/2, bS, i_qpc, 1,
                                deblock_v_chroma_c, deblock_v_chroma_intra_c );
                    }
                }
            }
        }

        /* newt mb */
        mb_x++;
        if( mb_x >= SPS_MB_WIDTH )
        {
            mb_x = 0;
            mb_y++;
        }
    }
}

STATIC void x264_frame_expand_border()
{
    plane_expand_border( plane0_1666, 176+64, 144, 32 );
    plane_expand_border( plane1_1667, (176+64)/2, 144/2, 16 );
    plane_expand_border( plane2_1668, (176+64)/2, 144/2, 16 );
}
STATIC inline int x264_tapfilter( uint8_t *pix, int i_pix_next )
{
    return pix[-2*i_pix_next] - 5*pix[-1*i_pix_next] + 20*(pix[0] + pix[1*i_pix_next]) - 5*pix[ 2*i_pix_next] + pix[ 3*i_pix_next];
}
STATIC inline int x264_tapfilter1( uint8_t *pix )
{
    return pix[-2] - 5*pix[-1] + 20*(pix[0] + pix[1]) - 5*pix[ 2] + pix[ 3];
}
STATIC inline uint8_t x264_mc_clip1( int x )
{
    return x264_mc_clip1_table[x+80];
}
STATIC inline void mc_hh( uint8_t *src, int i_src_stride, uint8_t *dst, int i_dst_stride, int i_width, int i_height )
{
    int x, y;

    for( y = 0; y < i_height; y++ )
    {
        for( x = 0; x < i_width; x++ )
        {
            dst[x] = x264_mc_clip1( ( x264_tapfilter1( &src[x] ) + 16 ) >> 5 );
        }
        src += i_src_stride;
        dst += i_dst_stride;
    }
}
STATIC inline void mc_hv( uint8_t *src, int i_src_stride, uint8_t *dst, int i_dst_stride, int i_width, int i_height )
{
    int x, y;

    for( y = 0; y < i_height; y++ )
    {
        for( x = 0; x < i_width; x++ )
        {
            dst[x] = x264_mc_clip1( ( x264_tapfilter( &src[x], i_src_stride ) + 16 ) >> 5 );
        }
        src += i_src_stride;
        dst += i_dst_stride;
    }
}
STATIC inline void mc_hc( uint8_t *src, int i_src_stride, uint8_t *dst, int i_dst_stride, int i_width, int i_height )
{
    uint8_t *out;
    uint8_t *pix;
    int x, y;

    for( x = 0; x < i_width; x++ )
    {
        int tap[6];

        pix = &src[x];
        out = &dst[x];

        tap[0] = x264_tapfilter1( &pix[-2*i_src_stride] );
        tap[1] = x264_tapfilter1( &pix[-1*i_src_stride] );
        tap[2] = x264_tapfilter1( &pix[ 0*i_src_stride] );
        tap[3] = x264_tapfilter1( &pix[ 1*i_src_stride] );
        tap[4] = x264_tapfilter1( &pix[ 2*i_src_stride] );

        for( y = 0; y < i_height; y++ )
        {
            tap[5] = x264_tapfilter1( &pix[ 3*i_src_stride] );

            *out = x264_mc_clip1( ( tap[0] - 5*tap[1] + 20 * tap[2] + 20 * tap[3] -5*tap[4] + tap[5] + 512 ) >> 10 );

            /* Next line */
            pix += i_src_stride;
            out += i_dst_stride;
            tap[0] = tap[1];
            tap[1] = tap[2];
            tap[2] = tap[3];
            tap[3] = tap[4];
            tap[4] = tap[5];
        }
    }
}

STATIC void x264_frame_filter()
{
    const int x_inc = 16, y_inc = 16;
    const int stride = 176+64;
    int x, y;

    {
        for( y = -8; y < 144+8; y += y_inc )
        {
            uint8_t *p_in = plane0_1669 + y * stride - 8;
            uint8_t *p_h  = filtered1_1670 + y * stride - 8;
            uint8_t *p_v  = filtered2_1671 + y * stride - 8;
            uint8_t *p_hv = filtered3_1672 + y * stride - 8;
            for( x = -8; x < stride - 64 + 8; x += x_inc )
            {
                mc_hh(  p_in, stride, p_h,  stride, x_inc, y_inc );
                mc_hv(  p_in, stride, p_v,  stride, x_inc, y_inc );
                mc_hc( p_in, stride, p_hv, stride, x_inc, y_inc );

                p_h += x_inc;
                p_v += x_inc;
                p_hv += x_inc;
                p_in += x_inc;
            }
        }
    }
}
STATIC void x264_frame_expand_border_filtered()
{
    /* during filtering, 8 extra pixels were filtered on each edge. 
       we want to expand border from the last filtered pixel */

    plane_expand_border( filtered1_1670 - 8*(176+64) - 8, 176+64, 144+2*8, 24 );
    plane_expand_border( filtered2_1671 - 8*(176+64) - 8, 176+64, 144+2*8, 24 );
    plane_expand_border( filtered3_1672 - 8*(176+64) - 8, 176+64, 144+2*8, 24 );	
}
#ifdef WINDOWS

#include <windows.h>
#include <process.h>
#include <vfw.h>
#include <memory.h>


typedef struct
{
    HANDLE hThread;
    HANDLE hEvent;
    HWND hWnd;
    MSG msg;
    WNDCLASS wc;
    HDRAWDIB hDrawDib;
    HDC hDC;
    BITMAPINFOHEADER biHeader;
    char lpszAppName[15];
    DWORD dwThreadID;
    BOOL imageIsReady;
    unsigned char *bufRGB;
    RECT rect;
    unsigned char *src[3];

    int width, height;
    int zoom, oldzoom;
    int windowDismissed;

} T_VDWINDOW;


#define VIDEO_BEGIN                         (WM_USER + 0)
#define VIDEO_DRAW_FRAME          (WM_USER + 1)
#define VIDEO_REDRAW_FRAME      (WM_USER + 2)
#define VIDEO_END                             (WM_USER + 3)


STATIC int initDisplay (int pels, int lines);
STATIC int displayImage (unsigned char *lum, unsigned char *Cr, unsigned char *Cb);
STATIC int closeDisplay ();

STATIC void DisplayWinMain (void *);
STATIC LONG APIENTRY MainWndProc (HWND, UINT, UINT, LONG);
STATIC int DrawDIB ();
STATIC void init_dither_tab();
STATIC void ConvertYUVtoRGB(
        unsigned char *src0,
        unsigned char *src1,
        unsigned char *src2,
        unsigned char *dst_ori,
        int width,
        int height
        );
STATIC int InitDisplayWindowThread ();

#endif
#ifdef WINDOWS

/* vdinit.c */

T_VDWINDOW vdWindow;

STATIC int initDisplay (int pels, int lines)
{
    int errFlag = 0;

    init_dither_tab();
    errFlag |= InitDisplayWindowThread (pels, lines);

    return errFlag;
}


STATIC int InitDisplayWindowThread (int width, int height)
{
    int errFlag = 0;

    /* now modify the couple that need it */
    vdWindow.width = width;
    vdWindow.height = height;
    vdWindow.biHeader.biWidth = vdWindow.width;
    vdWindow.biHeader.biHeight = vdWindow.height;
    vdWindow.biHeader.biSize = sizeof(BITMAPINFOHEADER);
    vdWindow.biHeader.biCompression = BI_RGB;
    vdWindow.biHeader.biPlanes = 1;
    vdWindow.biHeader.biBitCount = 24;


    vdWindow.biHeader.biSizeImage = 3 * vdWindow.width * vdWindow.height;
    vdWindow.imageIsReady = FALSE;

    /* allocate the memory needed to hold the RGB and visualization information */  vdWindow.bufRGB = (unsigned char *)malloc (3 * vdWindow.width * vdWindow.height);

    /* Create synchronization event */
    vdWindow.hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    vdWindow.hThread =
        CreateThread (
                NULL,
                0,
                (LPTHREAD_START_ROUTINE) DisplayWinMain,
                (LPVOID) NULL,
                0,
                &(vdWindow.dwThreadID)
                );

    if (vdWindow.hThread == NULL) {
        errFlag = 1;
        return errFlag;
    }

    return errFlag;
}


/* vddraw.c */

STATIC int displayImage (unsigned char *lum, unsigned char *Cr, unsigned char *Cb)
{
    int errFlag = 0;
    DWORD dwRetVal;

    /* wait until we have finished drawing the last frame */
    if (vdWindow.windowDismissed == FALSE) {
        vdWindow.src[0] = lum;
        vdWindow.src[1] = Cb;
        vdWindow.src[2] = Cr;

        /* wait until previous frame has been drawn */
        dwRetVal = WaitForSingleObject(vdWindow.hEvent,INFINITE);

        vdWindow.imageIsReady = TRUE;
        /* Post message to drawing thread's window to draw frame */
        PostMessage (vdWindow.hWnd, VIDEO_DRAW_FRAME, (WPARAM) NULL, (LPARAM) NULL);

    }

    return errFlag;
}
STATIC int DrawDIB()
{                                                                                
    int errFlag = 0;

    errFlag |=
        DrawDibDraw (
                vdWindow.hDrawDib,
                vdWindow.hDC,
                0,
                0,
                vdWindow.zoom * vdWindow.width,
                vdWindow.zoom * vdWindow.height,
                &vdWindow.biHeader,
                vdWindow.bufRGB,
                0,
                0,
                vdWindow.width,
                vdWindow.height,
                DDF_SAME_DRAW
                );


    return errFlag;
}




/* vdwinman.c */

STATIC void DisplayWinMain (void *dummy)
{
    int errFlag = 0;
    DWORD dwStyle;

    vdWindow.wc.style =  CS_BYTEALIGNWINDOW;
    vdWindow.wc.lpfnWndProc = MainWndProc;
    vdWindow.wc.cbClsExtra = 0;
    vdWindow.wc.cbWndExtra = 0;
    vdWindow.wc.hInstance = 0;
    vdWindow.wc.hIcon = LoadIcon (NULL, IDI_APPLICATION);
    vdWindow.wc.hCursor = LoadCursor (NULL, IDC_ARROW);
    vdWindow.wc.hbrBackground = GetStockObject (WHITE_BRUSH);
    vdWindow.wc.lpszMenuName = NULL;
    vdWindow.zoom = 1;
    strcpy (vdWindow.lpszAppName, "H.264 Display");
    vdWindow.wc.lpszClassName = vdWindow.lpszAppName;

    RegisterClass(&vdWindow.wc);

    dwStyle =  WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;

    vdWindow.hWnd =
        CreateWindow (vdWindow.lpszAppName,
                vdWindow.lpszAppName,
                dwStyle,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                vdWindow.width + 6,
                vdWindow.height + 25,
                NULL,
                NULL,
                0,
                NULL
                );

    if (vdWindow.hWnd == NULL)
        ExitThread (errFlag = 1);

    ShowWindow(vdWindow.hWnd, SW_SHOWNOACTIVATE);
    UpdateWindow(vdWindow.hWnd);

    /* Message loop for display window's thread */
    while (GetMessage (&(vdWindow.msg), NULL, 0, 0)) {
        TranslateMessage (&(vdWindow.msg));
        DispatchMessage (&(vdWindow.msg));
    }

    ExitThread (0);
}


STATIC LRESULT APIENTRY MainWndProc (HWND hWnd, UINT msg, UINT wParam, LONG lParam)
{
    LPMINMAXINFO lpmmi;

    switch (msg) {
        case VIDEO_BEGIN:
            vdWindow.hDC = GetDC (vdWindow.hWnd);
            vdWindow.hDrawDib = DrawDibOpen();
            vdWindow.zoom = 1;
            vdWindow.oldzoom = 0;
            DrawDibBegin (
                    vdWindow.hDrawDib,
                    vdWindow.hDC,
                    2*vdWindow.width,
                    2*vdWindow.height,
                    &vdWindow.biHeader,
                    vdWindow.width,
                    vdWindow.height,
                    0
                    );
            SetEvent(vdWindow.hEvent);
            vdWindow.windowDismissed = FALSE;
            ReleaseDC (vdWindow.hWnd, vdWindow.hDC);
            break;
        case VIDEO_DRAW_FRAME:
            vdWindow.hDC = GetDC (vdWindow.hWnd);
            ConvertYUVtoRGB(
                    vdWindow.src[0],
                    vdWindow.src[1],
                    vdWindow.src[2],
                    vdWindow.bufRGB,
                    vdWindow.width,
                    vdWindow.height
                    );
            /* draw the picture onto the screen*/
            DrawDIB();
            SetEvent(vdWindow.hEvent);
            ReleaseDC (vdWindow.hWnd, vdWindow.hDC);
            break;
        case VIDEO_END:
            /* Window has been closed.  The following lines handle the cleanup. */
            vdWindow.hDC = GetDC (vdWindow.hWnd);
            DrawDibEnd (vdWindow.hDrawDib);
            DrawDibClose (vdWindow.hDrawDib);
            ReleaseDC (vdWindow.hWnd, vdWindow.hDC);

            vdWindow.windowDismissed = TRUE;
            PostQuitMessage(0);
            break;

        case WM_CREATE:
            PostMessage(hWnd, VIDEO_BEGIN, 0, 0);
            break;
        case WM_SIZE:
            switch (wParam) {
                case SIZE_MAXIMIZED:
                    vdWindow.zoom = 2;
                    break;
                case SIZE_MINIMIZED:
                    vdWindow.oldzoom = vdWindow.zoom;
                    break;
                case SIZE_RESTORED:
                    if (vdWindow.oldzoom) {
                        vdWindow.zoom = vdWindow.oldzoom;
                        vdWindow.oldzoom = 0;
                    }
                    else
                        vdWindow.zoom = 1;
                    break;
                case SIZE_MAXHIDE:
                    break;
                case SIZE_MAXSHOW:
                    break;
            }
            PostMessage(hWnd,WM_PAINT,0,0);
            break;
        case WM_GETMINMAXINFO:
            lpmmi = (LPMINMAXINFO) lParam;

            GetWindowRect (hWnd, &vdWindow.rect);
            lpmmi->ptMaxPosition.x = vdWindow.rect.left;
            lpmmi->ptMaxPosition.y = vdWindow.rect.top;

            lpmmi->ptMaxSize.x = 2 * (vdWindow.width) + 6;
            lpmmi->ptMaxSize.y = 2 * (vdWindow.height) + 25;
            break;
        case WM_DESTROY:
            /* Window has been closed.  The following lines handle the cleanup. */
            DrawDibEnd (vdWindow.hDrawDib);
            ReleaseDC (vdWindow.hWnd, vdWindow.hDC);
            DrawDibClose (vdWindow.hDrawDib);

            vdWindow.windowDismissed = TRUE;
            PostQuitMessage(0);
            break;
        case WM_PAINT:
            if (vdWindow.imageIsReady) {
                vdWindow.hDC = GetDC (vdWindow.hWnd);
                DrawDIB ();
                ReleaseDC (vdWindow.hWnd, vdWindow.hDC);
            }
            break;

    }
    return DefWindowProc (hWnd, msg, wParam, lParam);
}



/* vdclose.c */

STATIC int closeDisplay ()
{
    int errFlag = 0;

    if (vdWindow.hWnd) {
        PostMessage (vdWindow.hWnd, VIDEO_END, (WPARAM) NULL, (LPARAM) NULL);
        while (vdWindow.windowDismissed == FALSE)
            ;
    }

    if (vdWindow.hEvent)
        CloseHandle(vdWindow.hEvent);

    if (vdWindow.hThread)
        CloseHandle (vdWindow.hThread);

    free (vdWindow.bufRGB);

    return errFlag;
}




#endif
/* Data for ConvertYUVtoRGB*/
#if (defined DISPLAY || defined WINDOWS)
long int crv_tab_1678[256];
long int cbu_tab_1679[256];
long int cgu_tab_1680[256];

long int cgv_tab_1681[256];
long int tab_76309_1682[256];

STATIC void init_dither_tab()
{
    long int crv,cbu,cgu,cgv;
    int i;

    crv = 104597; cbu = 132201;  /* fra matrise i global.h */
    cgu = 25675;  cgv = 53279;

    for (i = 0; i < 256; i++) {
        crv_tab_1678[i] = (i-128) * crv;
        cbu_tab_1679[i] = (i-128) * cbu;
        cgu_tab_1680[i] = (i-128) * cgu;
        cgv_tab_1681[i] = (i-128) * cgv;
        tab_76309_1682[i] = 76309*(i-16);
    }
}




/**********************************************************************
 *
 *      Name:            ConvertYUVtoRGB
 *      Description:     Converts YUV image to RGB (packed mode)
 *
 *      Input:           pointer to source luma, Cr, Cb, destination,
 *                       image width and height
 *      Returns:
 *      Side effects:
 *
 *      Date: 951208    Author: Karl.Lillevold@nta.no
 *
 ***********************************************************************/



STATIC void ConvertYUVtoRGB(unsigned char *src0,unsigned char *src1,unsigned char *src2,unsigned char *dst_ori,int width,int height)
{
    //extern long int crv_tab_1678[];
    //extern long int cbu_tab_1679[];
    //extern long int cgu_tab_1680[];

    //extern long int cgv_tab_1681[];
    //extern long int tab_76309_1682[];

    int y11,y21;
    int y12,y22;
    int y13,y23;
    int y14,y24;
    int u,v;
    int i,j;
    int c11, c21, c31, c41;
    int c12, c22, c32, c42;
    unsigned int DW;
    unsigned int *id1, *id2;
    unsigned char *py1,*py2,*pu,*pv;
    unsigned char *d1, *d2;

    d1 = dst_ori;
    d1 += width*height*3 - width*3;
    d2 = d1 - width*3;

    py1 = src0; pu = src1; pv = src2;
    py2 = py1 + width;

    id1 = (unsigned int *)d1;
    id2 = (unsigned int *)d2;

    for (j = 0; j < height; j += 2) {
        /* line j + 0 */
        for (i = 0; i < width; i += 4) {
            u = *pu++;
            v = *pv++;
            c11 = crv_tab_1678[v];
            c21 = cgu_tab_1680[u];
            c31 = cgv_tab_1681[v];
            c41 = cbu_tab_1679[u];
            u = *pu++;
            v = *pv++;
            c12 = crv_tab_1678[v];
            c22 = cgu_tab_1680[u];
            c32 = cgv_tab_1681[v];
            c42 = cbu_tab_1679[u];

            y11 = tab_76309_1682[*py1++]; /* (255/219)*65536 */
            y12 = tab_76309_1682[*py1++];
            y13 = tab_76309_1682[*py1++]; /* (255/219)*65536 */
            y14 = tab_76309_1682[*py1++];

            y21 = tab_76309_1682[*py2++];
            y22 = tab_76309_1682[*py2++];
            y23 = tab_76309_1682[*py2++];
            y24 = tab_76309_1682[*py2++];

            /* RGBR*/
            DW = ((clp_1676[(y11 + c41)>>16])) |
                ((clp_1676[(y11 - c21 - c31)>>16])<<8) |
                ((clp_1676[(y11 + c11)>>16])<<16) |
                ((clp_1676[(y12 + c41)>>16])<<24);
            *id1++ = DW;

            /* GBRG*/
            DW = ((clp_1676[(y12 - c21 - c31)>>16])) |
                ((clp_1676[(y12 + c11)>>16])<<8) |
                ((clp_1676[(y13 + c42)>>16])<<16) |
                ((clp_1676[(y13 - c22 - c32)>>16])<<24);

            /* BRGB*/
            DW = ((clp_1676[(y13 + c12)>>16])) |
                ((clp_1676[(y14 + c42)>>16])<<8) |
                ((clp_1676[(y14 - c22 - c32)>>16])<<16) |
                ((clp_1676[(y14 + c12)>>16])<<24);
            *id1++ = DW;

            /* RGBR*/
            DW = ((clp_1676[(y21 + c41)>>16])) |
                ((clp_1676[(y21 - c21 - c31)>>16])<<8) |
                ((clp_1676[(y21 + c11)>>16])<<16) |
                ((clp_1676[(y22 + c41)>>16])<<24);
            *id2++ = DW;

            /* GBRG*/
            DW = ((clp_1676[(y22 - c21 - c31)>>16])) |
                ((clp_1676[(y22 + c11)>>16])<<8) |
                ((clp_1676[(y23 + c42)>>16])<<16) |
                ((clp_1676[(y23 - c22 - c32)>>16])<<24);
            *id2++ = DW;

            /* BRGB*/
            DW = ((clp_1676[(y23 + c12)>>16])) |
                ((clp_1676[(y24 + c42)>>16])<<8) |
                ((clp_1676[(y24 - c22 - c32)>>16])<<16) |
                ((clp_1676[(y24 + c12)>>16])<<24);
            *id2++ = DW;
        }
        id1 -= (9 * width)>>2;
        id2 -= (9 * width)>>2;
        py1 += width;
        py2 += width;
    }
}
#endif

#ifdef HKSIM_DISPLAY 

int tCr1[256], tCr2[256], tCb1[256], tCb2[256], tY1[256];
int clpR[2048], clpG[2048], clpB[2048];

static void initRGBConversion_HKSIM() {
        int i;
        for(i=0; i<256; i++) {
                tCr1[i] = 1.402*(float)(i-128);
                tCr2[i] = 0.714*(float)(i-128);
                tCb1[i] = 0.344*(float)(i-128);
                tCb2[i] = 1.772*(float)(i-128);
                tY1[i] = (float)i+768;
        }
        for (i=-768; i<1280; i++) {
                clpR[i+768] = (i<0) ? 0 : ((i>255) ? (255L<<16) : (i << 16));
                clpG[i+768] = (i<0) ? 0 : ((i>255) ? (255L<< 8) : (i <<  8));
                clpB[i+768] = (i<0) ? 0 : ((i>255) ? (255L    ) : (i      ));
        }
}

static void convertRGB_HKSIM(unsigned char *Y, unsigned char *Cb, unsigned char *Cr, unsigned int *out, int width, int height) {
        int i, j, k, i_lcd, j_lcd;
        int cwidth, cheight;
        int row, col;
        int Cr1, CrCb, Cb1, Y1;

        cwidth = width >> 1;
        cheight = height >> 1;

        i=0;
        i_lcd=0;
        j=width;
        j_lcd=width;
        k=0;
        for (row=0; row<cheight; row++) {
                for (col=0; col<cwidth; col++) {
                        Cr1 = tCr1[Cr[k]];
                        CrCb = -tCr2[Cr[k]]-tCb1[Cb[k]];
                        Cb1 = tCb2[Cb[k]];

                        // first
                        Y1 = tY1[Y[i]]; i++;
                        out[i_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

                        // second
                        Y1 = tY1[Y[i]]; i++;
                        out[i_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

                        // third
                        Y1 = tY1[Y[j]]; j++;
                        out[j_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

                        // forth
                        Y1 = tY1[Y[j]]; j++;
                        out[j_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

                        k++;
                }
                i += width;
                i_lcd += width;
                j += width;
                j_lcd += width;
        }
}

#endif




#ifdef IO_MODELING

int tCr1[256], tCr2[256], tCb1[256], tCb2[256], tY1[256];
int clpR[2048], clpG[2048], clpB[2048];

STATIC void initRGBConversion() {
    int i;
    for(i=0; i<256; i++) {
        tCr1[i] = 1.596*(float)(i-128);
        tCr2[i] = 0.813*(float)(i-128);
        tCb1[i] = 0.392*(float)(i-128);
        tCb2[i] = 2.017*(float)(i-128);
        tY1[i] = 1.164*(float)(i-16)+768;
    }
    for (i=-768; i<1280; i++) {
        clpR[i+768] = (i<0) ? 0 : ((i>255) ? (31<<11) : ((i>>3)<<11));
        clpG[i+768] = (i<0) ? 0 : ((i>255) ? (63<<5)  : ((i>>2)<<5));
        clpB[i+768] = (i<0) ? 0 : ((i>255) ? (31) : (i>>3));
    }
}

STATIC void convertRGB(unsigned char *Y, unsigned char *Cr, unsigned char *Cb, unsigned short *out, int width, int height) {
    int i, j, k, i_lcd, j_lcd;
    int cwidth, cheight;
    int row, col;
    int Cr1, CrCb, Cb1, Y1;

    cwidth = width >> 1;
    cheight = height >> 1;

    i=0;
    i_lcd=0;
    j=width;
    j_lcd=240;
    k=0;
    for (row=0; row<cheight; row++) {
        for (col=0; col<cwidth; col++) {
            Cr1 = tCr1[Cr[k]];
            CrCb = tCr2[Cr[k]]-tCb1[Cb[k]];
            Cb1 = tCb2[Cb[k]];

            // first
            Y1 = tY1[Y[i]];
            out[i_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

            // second
            Y1 = tY1[Y[i]];
            out[i_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

            // third
            Y1 = tY1[Y[j]];
            out[j_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

            // forth
            Y1 = tY1[Y[j]];
            out[j_lcd++] = clpR[Y1+Cr1] | clpG[Y1+CrCb] | clpB[Y1+Cb1];

            k++;
        }
        i += width;
        i_lcd += 304;
        j += width;
        j_lcd += 304;
    }
}
#endif
#ifdef DISPLAY
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#endif


#ifdef DISPLAY

#undef INTERPOLATE

/*
 * Erik Corry's multi-byte dither routines.
 *
 * The basic idea is that the Init generates all the necessary tables.
 * The tables incorporate the information about the layout of pixels
 * in the XImage, so that it should be able to cope with 15-bit, 16-bit
 * 24-bit (non-packed) and 32-bit (10-11 bits per color!) screens.
 * At present it cannot cope with 24-bit packed mode, since this involves
 * getting down to byte level again. It is assumed that the bits for each
 * color are contiguous in the longword.
 *
 * Writing to memory is done in shorts or ints. (Unfortunately, short is not
 * very fast on Alpha, so there is room for improvement here). There is no
 * dither time check for overflow - instead the tables have slack at
 * each end. This is likely to be faster than an 'if' test as many modern
 * architectures are really bad at ifs. Potentially, each '&&' causes a
 * pipeline flush!
 *
 * There is no shifting and fixed point arithmetic, as I really doubt you
 * can see the difference, and it costs. This may be just my bias, since I
 * heard that Intel is really bad at shifting.
 */
/* Gamma correction stuff */

#define GAMMA_CORRECTION(x) ((int)(pow((x) / 255.0, 1.0 / gammaCorrect_1683) * 255.0))
#define CHROMA_CORRECTION256(x) ((x) >= 128 \
        ? 128 + mmin(127, (int)(((x) - 128.0) * chromaCorrect_1684)) \
        : 128 - mmin(128, (int)((128.0 - (x)) * chromaCorrect_1684)))
#define CHROMA_CORRECTION128(x) ((x) >= 0 \
        ? mmin(127,  (int)(((x) * chromaCorrect_1684))) \
        : mmax(-128, (int)(((x) * chromaCorrect_1684))))
#define CHROMA_CORRECTION256D(x) ((x) >= 128 \
        ? 128.0 + mmin(127.0, (((x) - 128.0) * chromaCorrect_1684)) \
        : 128.0 - mmin(128.0, (((128.0 - (x)) * chromaCorrect_1684))))
#define CHROMA_CORRECTION128D(x) ((x) >= 0 \
        ? mmin(127.0,  ((x) * chromaCorrect_1684)) \
        : mmax(-128.0, ((x) * chromaCorrect_1684)))


/* Flag for gamma correction */
int gammaCorrectFlag_1685 = 0;
double gammaCorrect_1683 = 1.0;

/* Flag for chroma correction */
int chromaCorrectFlag_1686 = 0;
double chromaCorrect_1684 = 1.0;

/*
 * How many 1 bits are there in the longword.
 * Low performance, do not call often.
 */
    STATIC int
number_of_bits_set(unsigned long a)
{
    if(!a) return 0;
    if(a & 1) return 1 + number_of_bits_set(a >> 1);
    return(number_of_bits_set(a >> 1));
}

/*
 * Shift the 0s in the least significant end out of the longword.
 * Low performance, do not call often.
 */
    STATIC unsigned long
shifted_down(unsigned long a)
{
    if(!a) return 0;
    if(a & 1) return a;
    return a >> 1;
}
/*
 * How many 0 bits are there at most significant end of longword.
 * Low performance, do not call often.
 */
    STATIC int
free_bits_at_top(unsigned long a)
{
    /* assume char is 8 bits */
    if(!a) return sizeof(unsigned long) * 8;
    /* assume twos complement */
    if(((long)a) < 0l) return 0;
    return 1 + free_bits_at_top ( a << 1);
}

/*
 * How many 0 bits are there at least significant end of longword.
 * Low performance, do not call often.
 */
    STATIC int
free_bits_at_bottom(unsigned long a)
{
    /* assume char is 8 bits */
    if(!a) return sizeof(unsigned long) * 8;
    if(((long)a) & 1l) return 0;
    return 1 + free_bits_at_bottom ( a >> 1);
}

STATIC int *L_tab, *Cr_r_tab, *Cr_g_tab, *Cb_g_tab, *Cb_b_tab;

/*
 * We define tables that convert a color value between -256 and 512
 * into the R, G and B parts of the pixel. The normal range is 0-255.
 */

STATIC long *r_2_pix;
STATIC long *g_2_pix;
STATIC long *b_2_pix;
STATIC long *r_2_pix_alloc;
STATIC long *g_2_pix_alloc;
STATIC long *b_2_pix_alloc;


/*
 *--------------------------------------------------------------
 *
 * InitColor16Dither --
 *
 *      To get rid of the multiply and other conversions in color
 *      dither, we use a lookup table.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      The lookup tables are initialized.
 *
 *--------------------------------------------------------------
 */

    STATIC void
InitColorDither(int thirty2)
{
    extern XImage *ximage_1687;
    extern unsigned long wpixel_1688[3];
    /*
     * misuse of the wpixel_1688 array for the pixel masks. Note that this
     * implies that the window is created before this routine is called
     */


    unsigned long red_mask;
    unsigned long green_mask;
    unsigned long blue_mask;

    int CR, CB, i;

    red_mask = wpixel_1688[0];
    green_mask = wpixel_1688[1];
    blue_mask = wpixel_1688[2];

    if (ximage_1687->bits_per_pixel == 24) /* not necessary in non-packed mode */
        init_dither_tab();

    L_tab    = (int *)malloc(256*sizeof(int));
    Cr_r_tab = (int *)malloc(256*sizeof(int));
    Cr_g_tab = (int *)malloc(256*sizeof(int));
    Cb_g_tab = (int *)malloc(256*sizeof(int));
    Cb_b_tab = (int *)malloc(256*sizeof(int));

    r_2_pix_alloc = (long *)malloc(768*sizeof(long));
    g_2_pix_alloc = (long *)malloc(768*sizeof(long));
    b_2_pix_alloc = (long *)malloc(768*sizeof(long));

    if (L_tab == NULL ||
            Cr_r_tab == NULL ||
            Cr_g_tab == NULL ||
            Cb_g_tab == NULL ||
            Cb_b_tab == NULL ||
            r_2_pix_alloc == NULL ||
            g_2_pix_alloc == NULL ||
            b_2_pix_alloc == NULL) {
        fprintf(stderr, "Could not get enough memory in InitColorDither\n");
        exit(1);
    }

    for (i=0; i<256; i++) {
        L_tab[i] = i;
        if (gammaCorrectFlag_1685) {
            L_tab[i] = GAMMA_CORRECTION(i);
        }

        CB = CR = i;

        if (chromaCorrectFlag_1686) {
            CB -= 128;
            CB = CHROMA_CORRECTION128(CB);
            CR -= 128;
            CR = CHROMA_CORRECTION128(CR);
        } else {
            CB -= 128; CR -= 128;
        }
        /* was
           Cr_r_tab[i] =  1.596 * CR;
           Cr_g_tab[i] = -0.813 * CR;
           Cb_g_tab[i] = -0.391 * CB;
           Cb_b_tab[i] =  2.018 * CB;
           but they were just messed up.
           Then was (_Video Deymstified_):
           Cr_r_tab[i] =  1.366 * CR;
           Cr_g_tab[i] = -0.700 * CR;
           Cb_g_tab[i] = -0.334 * CB;
           Cb_b_tab[i] =  1.732 * CB;
           but really should be:
           (from ITU-R BT.470-2 System B, G and SMPTE 170M )
           */
        Cr_r_tab[i] =  (0.419/0.299) * CR;
        Cr_g_tab[i] = -(0.299/0.419) * CR;
        Cb_g_tab[i] = -(0.114/0.331) * CB;
        Cb_b_tab[i] =  (0.587/0.331) * CB;

        /*
           though you could argue for:
           SMPTE 240M
           Cr_r_tab[i] =  (0.445/0.212) * CR;
           Cr_g_tab[i] = -(0.212/0.445) * CR;
           Cb_g_tab[i] = -(0.087/0.384) * CB;
           Cb_b_tab[i] =  (0.701/0.384) * CB;
           FCC
           Cr_r_tab[i] =  (0.421/0.30) * CR;
           Cr_g_tab[i] = -(0.30/0.421) * CR;
           Cb_g_tab[i] = -(0.11/0.331) * CB;
           Cb_b_tab[i] =  (0.59/0.331) * CB;
           ITU-R BT.709
           Cr_r_tab[i] =  (0.454/0.2125) * CR;
           Cr_g_tab[i] = -(0.2125/0.454) * CR;
           Cb_g_tab[i] = -(0.0721/0.386) * CB;
           Cb_b_tab[i] =  (0.7154/0.386) * CB;
           */
    }

    /*
     * Set up entries 0-255 in rgb-to-pixel value tables.
     */
    for (i = 0; i < 256; i++) {
        r_2_pix_alloc[i + 256] = i >> (8 - number_of_bits_set(red_mask));
        r_2_pix_alloc[i + 256] <<= free_bits_at_bottom(red_mask);
        g_2_pix_alloc[i + 256] = i >> (8 - number_of_bits_set(green_mask));
        g_2_pix_alloc[i + 256] <<= free_bits_at_bottom(green_mask);
        b_2_pix_alloc[i + 256] = i >> (8 - number_of_bits_set(blue_mask));
        b_2_pix_alloc[i + 256] <<= free_bits_at_bottom(blue_mask);
        /*
         * If we have 16-bit output depth, then we double the value
         * in the top word. This means that we can write out both
         * pixels in the pixel doubling mode with one op. It is
         * harmless in the normal case as storing a 32-bit value
         * through a short pointer will lose the top bits anyway.
         * A similar optimisation for Alpha for 64 bit has been
         * prepared for, but is not yet implemented.
         */
        if(!thirty2) {

            r_2_pix_alloc[i + 256] |= (r_2_pix_alloc[i + 256]) << 16;
            g_2_pix_alloc[i + 256] |= (g_2_pix_alloc[i + 256]) << 16;
            b_2_pix_alloc[i + 256] |= (b_2_pix_alloc[i + 256]) << 16;

        }
#ifdef SIXTYFOUR_BIT
        if(thirty2) {

            r_2_pix_alloc[i + 256] |= (r_2_pix_alloc[i + 256]) << 32;
            g_2_pix_alloc[i + 256] |= (g_2_pix_alloc[i + 256]) << 32;
            b_2_pix_alloc[i + 256] |= (b_2_pix_alloc[i + 256]) << 32;

        }
#endif
    }

    /*
     * Spread out the values we have to the rest of the array so that
     * we do not need to check for overflow.
     */
    for (i = 0; i < 256; i++) {
        r_2_pix_alloc[i] = r_2_pix_alloc[256];
        r_2_pix_alloc[i+ 512] = r_2_pix_alloc[511];
        g_2_pix_alloc[i] = g_2_pix_alloc[256];
        g_2_pix_alloc[i+ 512] = g_2_pix_alloc[511];
        b_2_pix_alloc[i] = b_2_pix_alloc[256];
        b_2_pix_alloc[i+ 512] = b_2_pix_alloc[511];
    }

    r_2_pix = r_2_pix_alloc + 256;
    g_2_pix = g_2_pix_alloc + 256;
    b_2_pix = b_2_pix_alloc + 256;

}


/*
 *--------------------------------------------------------------
 *
 * Color16DitherImage --
 *
 *      Converts image into 16 bit color.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */

    STATIC void
Color16DitherImage(unsigned char *src[], unsigned char *out)
{
    unsigned char *lum = src[0];
    unsigned char *cb = src[1];
    unsigned char *cr = src[2];
    int cols;
    int rows;

    int L, CR, CB;
    unsigned short *row1, *row2;
    unsigned char *lum2;
    int x, y;
    int cr_r;
    int cr_g;
    int cb_g;
    int cb_b;
    int cols_2;

    cols = 176;
    rows = 144;
    if (expand_1673) {
        cols *= 2;
        rows *= 2;
    }
    cols_2 = cols/2;

    row1 = (unsigned short *)out;
    row2 = row1 + cols_2 + cols_2;
    lum2 = lum + cols_2 + cols_2;

    for (y=0; y<rows; y+=2) {
        for (x=0; x<cols_2; x++) {
            int R, G, B;

            CR = *cr++;
            CB = *cb++;
            cr_r = Cr_r_tab[CR];
            cr_g = Cr_g_tab[CR];
            cb_g = Cb_g_tab[CB];
            cb_b = Cb_b_tab[CB];

            L = L_tab[(int) *lum++];

            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row1++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);

#ifdef INTERPOLATE
            if(x != cols_2 - 1) {
                CR = (CR + *cr) >> 1;
                CB = (CB + *cb) >> 1;
                cr_r = Cr_r_tab[CR];
                cr_g = Cr_g_tab[CR];
                cb_g = Cb_g_tab[CB];
                cb_b = Cb_b_tab[CB];
            }
#endif

            L = L_tab[(int) *lum++];

            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row1++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);

            /*
             * Now, do second row.
             */
#ifdef INTERPOLATE
            if(y != rows - 2) {
                CR = (CR + *(cr + cols_2 - 1)) >> 1;
                CB = (CB + *(cb + cols_2 - 1)) >> 1;
                cr_r = Cr_r_tab[CR];
                cr_g = Cr_g_tab[CR];
                cb_g = Cb_g_tab[CB];
                cb_b = Cb_b_tab[CB];
            }
#endif

            L = L_tab[(int) *lum2++];
            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row2++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);

            L = L_tab[(int) *lum2++];
            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row2++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);
        }
        /*
         * These values are at the start of the next line, (due
         * to the ++'s above),but they need to be at the start
         * of the line after that.
         */
        lum += cols_2 + cols_2;
        lum2 += cols_2 + cols_2;
        row1 += cols_2 + cols_2;
        row2 += cols_2 + cols_2;
    }
}


/*
 *--------------------------------------------------------------
 *
 * Color32DitherImage --
 *
 *      Converts image into 32 bit color (or 24-bit non-packed).
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      None.
 *
 *--------------------------------------------------------------
 */

/*
 * This is a copysoft version of the function above with ints instead
 * of shorts to cause a 4-byte pixel size
 */

    STATIC void
Color32DitherImage(unsigned char *src[], unsigned char *out)
{
    unsigned char *lum = src[0];
    unsigned char *cb = src[1];
    unsigned char *cr = src[2];
    int cols;
    int rows;

    int L, CR, CB;
    unsigned int *row1, *row2;
    unsigned char *lum2;
    int x, y;
    int cr_r;
    int cr_g;
    int cb_g;
    int cb_b;
    int cols_2;

    cols = 176;
    rows = 144;
    if (expand_1673) {
        cols *= 2;
        rows *= 2;
    }
    cols_2 = cols/2;

    row1 = (unsigned int *)out;
    row2 = row1 + cols_2 + cols_2;
    lum2 = lum + cols_2 + cols_2;
    for (y=0; y<rows; y+=2) {
        for (x=0; x<cols_2; x++) {
            int R, G, B;

            CR = *cr++;
            CB = *cb++;
            cr_r = Cr_r_tab[CR];
            cr_g = Cr_g_tab[CR];
            cb_g = Cb_g_tab[CB];
            cb_b = Cb_b_tab[CB];

            L = L_tab[(int) *lum++];

            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row1++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);

#ifdef INTERPOLATE
            if(x != cols_2 - 1) {
                CR = (CR + *cr) >> 1;
                CB = (CB + *cb) >> 1;
                cr_r = Cr_r_tab[CR];
                cr_g = Cr_g_tab[CR];
                cb_g = Cb_g_tab[CB];
                cb_b = Cb_b_tab[CB];
            }
#endif

            L = L_tab[(int) *lum++];

            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row1++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);

            /*
             * Now, do second row.
             */

#ifdef INTERPOLATE
            if(y != rows - 2) {
                CR = (CR + *(cr + cols_2 - 1)) >> 1;
                CB = (CB + *(cb + cols_2 - 1)) >> 1;
                cr_r = Cr_r_tab[CR];
                cr_g = Cr_g_tab[CR];
                cb_g = Cb_g_tab[CB];
                cb_b = Cb_b_tab[CB];
            }
#endif

            L = L_tab [(int) *lum2++];
            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row2++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);

            L = L_tab [(int) *lum2++];
            R = L + cr_r;
            G = L + cr_g + cb_g;
            B = L + cb_b;

            *row2++ = (r_2_pix[R] | g_2_pix[G] | b_2_pix[B]);
        }
        lum += cols_2 + cols_2;
        lum2 += cols_2 + cols_2;
        row1 += cols_2 + cols_2;
        row2 += cols_2 + cols_2;
    }
}

#endif
#ifdef DISPLAY
extern unsigned char pixel_1689[256];

STATIC unsigned char ytab[16 * (256 + 16)];
STATIC unsigned char uvtab[256 * 269 + 270];

/****************************************************************************

  4x4 ordered dither

  Threshold pattern:

  0  8  2 10
  12  4 14  6
  3 11  1  9
  15  7 13  5

 ****************************************************************************/
    STATIC void
ord4x4_dither_init (void)
{
    int i, j, v;
    unsigned char ctab[256 + 32];

    for (i = 0; i < 256 + 16; i++)
    {
        v = (i - 8) >> 4;
        if (v < 2)
            v = 2;
        else if (v > 14)
            v = 14;
        for (j = 0; j < 16; j++)
            ytab[16 * i + j] = pixel_1689[(v << 4) + j];
    }

    for (i = 0; i < 256 + 32; i++)
    {
        v = (i + 48 - 128) >> 5;
        if (v < 0)
            v = 0;
        else if (v > 3)
            v = 3;
        ctab[i] = v;
    }

    for (i = 0; i < 255 + 15; i++)
        for (j = 0; j < 255 + 15; j++)
            uvtab[256 * i + j] = (ctab[i + 16] << 6) | (ctab[j + 16] << 4) | (ctab[i] << 2) | ctab[j];
}



    STATIC void
ord4x4_dither_frame (unsigned char *src[], unsigned char *dst)
{
    int i, j;
    unsigned char *py = src[0];
    unsigned char *pu = src[1];
    unsigned char *pv = src[2];

    int width, height, cwidth;

    if (expand_1673)
    {
        width = 2 * 176;
        height = 2 * 144;
        cwidth = 2 * (176>>1);
    }
    else
    {
        width = 176;
        height = 144;
        cwidth = (176>>1);
    }

    for (j = 0; j < height; j += 4)
    {
        register unsigned int uv;

        /* line j + 0 */
        for (i = 0; i < width; i += 8)
        {
            uv = uvtab[(*pu++ << 8) | *pv++];
            *dst++ = ytab[((*py++) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 8) << 4) | (uv >> 4)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 1028];
            *dst++ = ytab[((*py++ + 2) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 10) << 4) | (uv >> 4)];
            uv = uvtab[(*pu++ << 8) | *pv++];
            *dst++ = ytab[((*py++) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 8) << 4) | (uv >> 4)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 1028];
            *dst++ = ytab[((*py++ + 2) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 10) << 4) | (uv >> 4)];
        }

        pu -= cwidth;
        pv -= cwidth;

        /* line j + 1 */
        for (i = 0; i < width; i += 8)
        {
            uv = uvtab[((*pu++ << 8) | *pv++) + 2056];
            *dst++ = ytab[((*py++ + 12) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 4) << 4) | (uv & 15)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 3084];
            *dst++ = ytab[((*py++ + 14) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 6) << 4) | (uv & 15)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 2056];
            *dst++ = ytab[((*py++ + 12) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 4) << 4) | (uv & 15)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 3084];
            *dst++ = ytab[((*py++ + 14) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 6) << 4) | (uv & 15)];
        }

        /* line j + 2 */
        for (i = 0; i < width; i += 8)
        {
            uv = uvtab[((*pu++ << 8) | *pv++) + 1542];
            *dst++ = ytab[((*py++ + 3) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 11) << 4) | (uv >> 4)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 514];
            *dst++ = ytab[((*py++ + 1) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 9) << 4) | (uv >> 4)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 1542];
            *dst++ = ytab[((*py++ + 3) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 11) << 4) | (uv >> 4)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 514];
            *dst++ = ytab[((*py++ + 1) << 4) | (uv & 15)];
            *dst++ = ytab[((*py++ + 9) << 4) | (uv >> 4)];
        }

        pu -= cwidth;
        pv -= cwidth;

        /* line j + 3 */
        for (i = 0; i < width; i += 8)
        {
            uv = uvtab[((*pu++ << 8) | *pv++) + 3598];
            *dst++ = ytab[((*py++ + 15) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 7) << 4) | (uv & 15)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 2570];
            *dst++ = ytab[((*py++ + 13) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 5) << 4) | (uv & 15)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 3598];
            *dst++ = ytab[((*py++ + 15) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 7) << 4) | (uv & 15)];
            uv = uvtab[((*pu++ << 8) | *pv++) + 2570];
            *dst++ = ytab[((*py++ + 13) << 4) | (uv >> 4)];
            *dst++ = ytab[((*py++ + 5) << 4) | (uv & 15)];
        }
    }
}
#endif
#ifdef IO_MODELING
STATIC char *IObuf;
unsigned short *lcd_buffer;
#endif

#ifdef HKSIM_DISPLAY

#define HKSIM_DISPLAY_BASE 0x40000000

#endif

#ifdef DISPLAY

#include <stdio.h>
#include <stdlib.h>

#include <X11/Xlib.h>
#include <X11/Xutil.h>


/* private prototypes */
STATIC void display_image (XImage *, unsigned char *);

/* display related data */
unsigned long wpixel_1688[3];
STATIC unsigned char *dithered_image;

/* X11 related variables */
STATIC Display *display;
STATIC Window window;
STATIC GC gc;
STATIC int dpy_depth;

XImage *ximage_1687;

unsigned char pixel_1689[256];

#ifdef SH_MEM

#include <sys/ipc.h>
#include <sys/shm.h>
#include <X11/extensions/XShm.h>

extern int XShmQueryExtension _ANSI_ARGS_((Display *dpy));
extern int XShmGetEventBase _ANSI_ARGS_((Display *dpy));

STATIC int HandleXError _ANSI_ARGS_((Display *dpy, XErrorEvent *event));
STATIC void InstallXErrorHandler _ANSI_ARGS_((void));
STATIC void DeInstallXErrorHandler _ANSI_ARGS_((void));

STATIC int shmem_flag;
STATIC XShmSegmentInfo shminfo1, shminfo2;
STATIC int gXErrorFlag;
STATIC int CompletionType = -1;

STATIC int HandleXError(Display *dpy, XErrorEvent *event)
{
    gXErrorFlag = 1;

    return 0;
}

STATIC void InstallXErrorHandler()
{
    XSetErrorHandler(HandleXError);
    XFlush(display);
}

STATIC void DeInstallXErrorHandler()
{
    XSetErrorHandler(NULL);
    XFlush(display);
}

#endif

/* connect to server, create and map window,
 * allocate colors and (shared) memory
 */
STATIC void init_display(char *name)
{
    int crv, cbu, cgu, cgv;
    int y, u, v, r, g, b;
    int i;
    char dummy;
    int screen;
    Visual *visual;
    int dpy_class;
    Colormap cmap;
    int _private;
    XColor xcolor;
    unsigned int fg, bg;
    char *hello = "H.264 Display";
    XSizeHints hint;
    XEvent xev;
    XSetWindowAttributes xswa;
    unsigned long tmp_pixel;
    unsigned int mask;
    int matrix_coefficients = 0;

    clp_1676 = clpGlobal_1677;
    clp_1676 += 384;
    { int i;
        for (i=-384; i<640; i++)
            clp_1676[i] = (i<0) ? 0 : ((i>255) ? 255 : i);
    }

    display = XOpenDisplay(name);

    if (display == NULL) {
        printf("Can not open display\n");
        exit(1);
    }

    screen = DefaultScreen(display);

    visual = DefaultVisual (display, screen);
    dpy_depth = DefaultDepth (display, screen);
#ifdef __cplusplus
    dpy_class = visual->c_class;
#else
    dpy_class = visual->class;
#endif

    if (!((dpy_class == TrueColor && dpy_depth == 32)
                || (dpy_class == TrueColor && dpy_depth == 24)
                || (dpy_class == TrueColor && dpy_depth == 16)
                || (dpy_class == PseudoColor && dpy_depth == 8))) 
    {
        printf("requires 8 bit PseudoColor or 16/24/32 bit TrueColor display\n");
        exit(1);
    }

    if (dpy_class == TrueColor && dpy_depth == 32)
        printf("TrueColor : 32 bit colordepth\n");
    if (dpy_class == TrueColor && dpy_depth == 24)
        printf("TrueColor : 24 bit colordepth\n");
    if (dpy_class == TrueColor && dpy_depth == 16)
        printf("TrueColor : 16 bit colordepth\n");
    if (dpy_class == PseudoColor && dpy_depth == 8)
        printf("PseudoColor : 8 bit colordepth, 4x4 ordered dither\n");

    /* width and height of the display window */
    if (expand_1673) {
        hint.min_width = hint.max_width = hint.width = 2*176;
        hint.min_height = hint.max_height = hint.height = 2*144;
    }
    else {
        hint.min_width = hint.max_width = hint.width = 176;
        hint.min_height = hint.max_height = hint.height = 144;
    }

    hint.flags = PSize | PMinSize | PMaxSize;

    /* Get some colors */

    bg = WhitePixel (display, screen);
    fg = BlackPixel (display, screen);

    /* Make the window */
    mask = CWBackPixel | CWBorderPixel;
    if (dpy_depth == 32 || dpy_depth == 24 || dpy_depth == 16) {
        mask |= CWColormap;
        xswa.colormap = XCreateColormap (display, DefaultRootWindow (display),
                visual, AllocNone);
    }
    xswa.background_pixel = bg;
    xswa.border_pixel = fg;
    window = XCreateWindow (display, DefaultRootWindow (display),
            hint.x, hint.y, hint.width, hint.height,
            1, dpy_depth, InputOutput, visual, mask, &xswa);


    XSelectInput(display, window, StructureNotifyMask);

    /* Tell other applications about this window */

    XSetStandardProperties (display, window, hello, hello, None, NULL, 0, &hint);

    /* Map window. */

    XMapWindow(display, window);

    /* Wait for map. */
    do
    {
        XNextEvent(display, &xev);
    }
    while (xev.type != MapNotify || xev.xmap.event != window);

    XSelectInput(display, window, NoEventMask);

    /* allocate colors */

    gc = DefaultGC(display, screen);

    if (dpy_depth == 8) {
        XWindowAttributes xwa;

        cmap = DefaultColormap(display, screen);
        _private = 0;

        /* matrix coefficients */
        crv = convmat_1675[matrix_coefficients][0];
        cbu = convmat_1675[matrix_coefficients][1];
        cgu = convmat_1675[matrix_coefficients][2];
        cgv = convmat_1675[matrix_coefficients][3];

        /* color allocation:
         * i is the (internal) 8 bit color number, it consists of separate
         * bit fields for Y, U and V: i = (yyyyuuvv), we don't use yyyy=0000
         * yyyy=0001 and yyyy=1111, this leaves 48 colors for other applications
         *
         * the allocated colors correspond to the following Y, U and V values:
         * Y:   40, 56, 72, 88, 104, 120, 136, 152, 168, 184, 200, 216, 232
         * U,V: -48, -16, 16, 48
         *
         * U and V values span only about half the color space; this gives
         * usually much better quality, although highly saturated colors can
         * not be displayed properly
         *
         * translation to R,G,B is implicitly done by the color look-up table
         */
        for (i=32; i<240; i++) {
            /* color space conversion */
            y = 16*((i>>4)&15) + 8;
            u = 32*((i>>2)&3)  - 48;
            v = 32*(i&3)       - 48;

            y = 76309 * (y - 16); /* (255/219)*65536 */

            r = clp_1676[(y + crv*v + 32768)>>16];
            g = clp_1676[(y - cgu*u -cgv*v + 32768)>>16];
            b = clp_1676[(y + cbu*u + 32786)>>16];

            /* X11 colors are 16 bit */
            xcolor.red   = r << 8;
            xcolor.green = g << 8;
            xcolor.blue  = b << 8;

            if (XAllocColor(display, cmap, &xcolor) != 0)
                pixel_1689[i] = xcolor.pixel;
            else {
                /* allocation failed, have to use a private colormap */

                if (_private) {
                    printf("Couldn't allocate private colormap\n");
                    exit(1);
                }

                _private = 1;

                if (!quiet_1674)
                    fprintf(stderr, "Using private colormap (%d colors were "
                            "available).\n", i-32);

                /* Free colors. */
                while (--i >= 32)
                {
                    tmp_pixel = pixel_1689[i]; /* because XFreeColors expects unsigned long */
                    XFreeColors(display, cmap, &tmp_pixel, 1, 0);
                }

                /* i is now 31, this restarts the outer loop */

                /* create private colormap */

                XGetWindowAttributes(display, window, &xwa);
                cmap = XCreateColormap(display, window, xwa.visual, AllocNone);
                XSetWindowColormap(display, window, cmap);
            }
        }
    }

#ifdef SH_MEM
    if (XShmQueryExtension(display))
        shmem_flag = 1;
    else
    {
        shmem_flag = 0;
        if (!quiet_1674)
            fprintf(stderr, "Shared memory not supported\nReverting to normal "
                    "Xlib\n");
    }

    if (shmem_flag)
        CompletionType = XShmGetEventBase(display) + ShmCompletion;

    InstallXErrorHandler();

    if (shmem_flag)
    {

        if (expand_1673)
            ximage_1687 = XShmCreateImage(display, visual, dpy_depth, ZPixmap, NULL,
                    &shminfo1,
                    2*176, 2*144);
        else
            ximage_1687 = XShmCreateImage(display, visual, dpy_depth, ZPixmap, NULL,
                    &shminfo1,
                    176, 144);


        /* If no go, then revert to normal Xlib calls. */

        if (ximage_1687==NULL)
        {
            if (ximage_1687!=NULL)
                XDestroyImage(ximage_1687);
            if (!quiet_1674)
                fprintf(stderr, "Shared memory error, disabling (Ximage error)\n", 1);
            goto shmemerror;
        }

        /* Success here, continue. */

        shminfo1.shmid = shmget(IPC_PRIVATE,
                ximage_1687->bytes_per_line * ximage_1687->height,
                IPC_CREAT | 0777);

        if (shminfo1.shmid<0)
        {
            XDestroyImage(ximage_1687);
            if (!quiet_1674)
                fprintf(stderr, "Shared memory error, disabling (seg id error)\n");
            goto shmemerror;
        }

        shminfo1.shmaddr = (char *) shmat(shminfo1.shmid, 0, 0);
        shminfo2.shmaddr = (char *) shmat(shminfo2.shmid, 0, 0);

        if (shminfo1.shmaddr==((char *) -1))
        {
            XDestroyImage(ximage_1687);
            if (shminfo1.shmaddr!=((char *) -1))
                shmdt(shminfo1.shmaddr);
            if (!quiet_1674)
            {
                fprintf(stderr, "Shared memory error, disabling (address error)\n");
            }
            goto shmemerror;
        }

        ximage_1687->data = shminfo1.shmaddr;
        dithered_image = (unsigned char *)ximage_1687->data;
        shminfo1.readOnly = False;
        XShmAttach(display, &shminfo1);

        XSync(display, False);

        if (gXErrorFlag)
        {
            /* Ultimate failure here. */
            XDestroyImage(ximage_1687);
            shmdt(shminfo1.shmaddr);
            if (!quiet_1674)
                fprintf(stderr, "Shared memory error, disabling.\n");
            gXErrorFlag = 0;
            goto shmemerror;
        }
        else
        {
            shmctl(shminfo1.shmid, IPC_RMID, 0);
        }

        if (!quiet_1674)
        {
            fprintf(stderr, "Sharing memory.\n");
        }
    }
    else
    {
shmemerror:
        shmem_flag = 0;
#endif


        if (expand_1673) {
            ximage_1687 = XCreateImage(display,visual,dpy_depth,ZPixmap,0,&dummy,
                    2*176,2*144,8,0);
            if (!(dithered_image =
                        (unsigned char *)malloc(176*144*
                            (dpy_depth > 8 ? sizeof (int)*4 :
                             sizeof (unsigned char))*4)))
            { printf("malloc failed\n"); exit(1); }
        }
        else {
            ximage_1687 = XCreateImage(display,visual,dpy_depth,ZPixmap,0,&dummy,
                    176,144,8,0);
            if (!(dithered_image =
                        (unsigned char *)malloc(176*144*
                            (dpy_depth > 8 ? sizeof (int) :
                             sizeof (unsigned char)))))
            { printf("malloc failed\n"); exit(1); }
        }

#ifdef SH_MEM
    }

    DeInstallXErrorHandler();
#endif


    if (dpy_depth == 32 || dpy_depth == 24 || dpy_depth == 16) {
        XWindowAttributes xwa;

        XGetWindowAttributes(display, window, &xwa);


        wpixel_1688[0] = xwa.visual->red_mask;
        wpixel_1688[1] = xwa.visual->green_mask;
        wpixel_1688[2] = xwa.visual->blue_mask;

        /* If the colors in 16/24/32-bit mode are wrong, try this instead
           of the above three lines */
        /*
           wpixel_1688[2] = xwa.visual->red_mask;
           wpixel_1688[1] = xwa.visual->green_mask;
           wpixel_1688[0] = xwa.visual->blue_mask;
           */

        InitColorDither(dpy_depth == 24 || dpy_depth == 32);
    }
    else {
        ord4x4_dither_init ();
    }
}

STATIC void exit_display()
{
#ifdef SH_MEM
    if (shmem_flag)
    {
        XShmDetach(display, &shminfo1);
        XDestroyImage(ximage_1687);
        shmdt(shminfo1.shmaddr);
    }
#endif
}

STATIC void display_image(XImage *ximage_1687,unsigned char *dithered_image)
{
    int t = 1;

    /* Always work in native bit and byte order. This tells Xlib to
       reverse bit and byte order if necessary when crossing a
       network. Frankly, this part of XImages is somewhat
       underdocumented, so this may not be exactly correct.  */

    if (*(char *)&t == 1) {
        ximage_1687->byte_order = LSBFirst;
        ximage_1687->bitmap_bit_order = LSBFirst;
    }
    else {
        ximage_1687->byte_order = MSBFirst;
        ximage_1687->bitmap_bit_order = MSBFirst;
    }

    /* display dithered image */
#ifdef SH_MEM
    if (shmem_flag)
    {
        XShmPutImage(display, window, gc, ximage_1687,
                0, 0, 0, 0, ximage_1687->width, ximage_1687->height, True);
        XFlush(display);

        while (1)
        {
            XEvent xev;

            XNextEvent(display, &xev);
            if (xev.type == CompletionType)
                break;
        }
    }
    else
#endif
    {
        ximage_1687->data = (char *) dithered_image;
        XPutImage(display, window, gc, ximage_1687, 0, 0, 0, 0, ximage_1687->width, ximage_1687->height);
    }
}


STATIC void dither(unsigned char *src[])
{
    if (dpy_depth == 24 || dpy_depth == 32) {
        if (ximage_1687->bits_per_pixel == 24)
            ConvertYUVtoRGB(src[0],src[1],src[2], dithered_image,
                    176,
                    144);
        else
            Color32DitherImage(src, dithered_image);
    }
    else if (dpy_depth == 16) {
        Color16DitherImage(src, dithered_image);
    }
    else {
        ord4x4_dither_frame (src, dithered_image);
    }

    display_image (ximage_1687, dithered_image);
}

#endif

/////////////////////////////////////
// init code
/////////////////////////////////////
TASK_INIT
{
// ##INIT_PORT_SECTION::START
    port_p24 = PORT_INITIALIZE(TASK_ID, "p24");
    port_p42 = PORT_INITIALIZE(TASK_ID, "p42");
// ##INIT_PORT_SECTION::END

    // TODO: task initialize code
    memset(recon_frame_Y_1599.data, 0, sizeof(uint8_t)*(176+64)*(144+64));
    memset(recon_frame_U_1600.data, 0, sizeof(uint8_t)*(176/2+32)*(144/2+32));
    memset(recon_frame_V_1601.data, 0, sizeof(uint8_t)*(176/2+32)*(144/2+32));
    memset(ref_frm_1611.data, -2, sizeof(int8_t)*(176+15)/16 * (144+15)/16 * 4);
    p_Y_frm_buf_1663 = recon_frame_Y_1599.data + (176 + 64) * 32 + 32;
    p_U_frm_buf_1664 = recon_frame_U_1600.data + (176/2 + 32) * 16 + 16;
    p_V_frm_buf_1665 = recon_frame_V_1601.data + (176/2 + 32) * 16 + 16;
    memset(ref_mb_1604.data, -2, sizeof(ref_mb_1604.data));
    plane0_1666 = recon_frame_Y_1613.data + (176 + 64) * 32 + 32;
    plane1_1667 = recon_frame_U_1614.data + (176/2 + 32) * 16 + 16;
    plane2_1668 = recon_frame_V_1615.data + (176/2 + 32) * 16 + 16;
    plane0_1669 = recon_frame_Y_1613.data + (176 + 64) * 32 + 32;
    filtered1_1670 = Filtered_frame_1_1619.data + (176 + 64) * 32 + 32;
    filtered2_1671 = Filtered_frame_2_1620.data + (176 + 64) * 32 + 32;
    filtered3_1672 = Filtered_frame_3_1621.data + (176 + 64) * 32 + 32;
#ifdef DISPLAY
    init_display("");
#endif
#ifdef WINDOWS
    initDisplay(176, 144);
#endif

#ifdef HKSIM_DISPLAY

    initRGBConversion_HKSIM();

#endif

#ifdef IO_MODELING
    IOmodel_request_LCD();
    IObuf = (char *)malloc( sizeof(Frame1)*3 );
    if (IObuf==NULL) {
        printf("malloc failed for IObuf\n");
        exit(1);
    }
    lcd_buffer = (unsigned short *)malloc(320*240*sizeof(unsigned short));
    initRGBConversion();
#endif
    output_1642 = 0;
    output_1630 = 0;
    output_1708_phase = 0;

    mb_index_Debl = 0 ;
    {int i; for(i=0;i<99;i++) MB_Available[i] = 0;}
}


/////////////////////////////////////
// go code
/////////////////////////////////////

TASK_GO
{
    // TODO: task main code
        EncDbkPacket d;
    {    
        MQ_RECEIVE(port_p24, (unsigned char *)&d, sizeof(EncDbkPacket));
        memcpy(&output_1634, &d.recon_block_1313, 256);
        memcpy(&output_1635, &d.recon_block_1382, 256);
        memcpy(&output_1636, &d.recon_block_U, 64);
        memcpy(&output_1637, &d.recon_block_V, 64);
        memcpy(&output_1639, &d.non_zero_count, 192);
        memcpy(&d_r_info, &d.d_s_info, sizeof(deblock_send_info));
        mb_index_Debl = d.MB_index_Enc;

        if (mb_index_Debl==0)
        {
            {  /* DeblockI82.XFrameFilterI44 (class CGCXFrameFilter) */
                x264_frame_filter();
                x264_frame_expand_border_filtered(); //1666,1667,1668
            }
        }

        // 99 loop start
        {
            // MB_Available matrix
            MB_Available[mb_index_Debl]=1;
            MB_finder(mb_index_Debl, SPS_MB_WIDTH, MB_Available);

            if (mb_index_Debl==0)
                output_1630 = d.intFrameType;

            {  /*DeblockI82.XMBPostI0 (class CGCXMBPost) */
                if (d_r_info.mb_type == I_4x4)
                    construct_luma_frm(mb_index_Debl, SPS_MB_WIDTH, 176+64, d_r_info.recon_block_4x4.data);
                else if (d_r_info.mb_type == I_16x16)
                    construct_luma_frm(mb_index_Debl, SPS_MB_WIDTH, 176+64, output_1634.data);
                else 
                    construct_luma_frm(mb_index_Debl, SPS_MB_WIDTH, 176+64, output_1635.data);

                construct_chroma_frm(mb_index_Debl, SPS_MB_WIDTH, 176/2+32, output_1636.data, p_U_frm_buf_1664);
                construct_chroma_frm(mb_index_Debl, SPS_MB_WIDTH, 176/2+32, output_1637.data, p_V_frm_buf_1665);

                mb_frm_1609.data[mb_index_Debl] = d_r_info.mb_type;
                save_i4x4_nzc(d_r_info.mb_type, mb_index_Debl, d_r_info.i_pred4x4.data, output_1639.data, nzc_frm_1610.data);
                save_ref_mv(d_r_info.mb_type, mb_index_Debl, d_r_info.ref_mb.data, d_r_info.mv_mb.data, ref_frm_1611.data, mv_frm_1612.data);

                if (mb_index_Debl != SPS_MB_WIDTH * SPS_MB_HEIGHT - 1) {
                    if ( R_Available )
                    {
                        load_i4x4_nzc(d_r_info.mb_type, mb_index_Debl+1, &(info_R.i_neighbour), &(info_R.b_fast_intra), info_R.i_pred4x4.data, info_R.non_zero_count.data, nzc_frm_1610.data, mb_frm_1609.data);
                        load_ref_mv(output_1630, d_r_info.mb_type, info_R.i_neighbour, mb_index_Debl+1, info_R.ref_mb.data, info_R.mv_mb.data, ref_frm_1611.data, mv_frm_1612.data);
                        load_preddata(mb_index_Debl+1, info_R.i_neighbour, 176+64, 176/2+32, info_R.preddata16_Y.data, info_R.preddata8_U.data, info_R.preddata8_V.data);
                    }
                    if ( LD_Available )
                    {
                        load_i4x4_nzc(d_r_info.mb_type, mb_index_Debl+SPS_MB_WIDTH-1, &(info_LD.i_neighbour), &(info_LD.b_fast_intra), info_LD.i_pred4x4.data, info_LD.non_zero_count.data, nzc_frm_1610.data, mb_frm_1609.data);
                        load_ref_mv(output_1630, d_r_info.mb_type, info_LD.i_neighbour, mb_index_Debl+SPS_MB_WIDTH-1, info_LD.ref_mb.data, info_LD.mv_mb.data, ref_frm_1611.data, mv_frm_1612.data);
                        load_preddata(mb_index_Debl+SPS_MB_WIDTH-1, info_LD.i_neighbour, 176+64, 176/2+32, info_LD.preddata16_Y.data, info_LD.preddata8_U.data, info_LD.preddata8_V.data);
                    }
                }
                else { // last macro block // is this right?
                    MQ_SEND(port_p42, (unsigned char *)&info_R, sizeof(neighbour_info));
                    load_i4x4_nzc(d_r_info.mb_type, 0 , &(info_R.i_neighbour), &(info_R.b_fast_intra), info_R.i_pred4x4.data, info_R.non_zero_count.data, nzc_frm_1610.data, mb_frm_1609.data);
                    load_ref_mv(output_1630, d_r_info.mb_type, info_R.i_neighbour, 0 , info_R.ref_mb.data, info_R.mv_mb.data, ref_frm_1611.data, mv_frm_1612.data);
                    load_preddata(0 , info_R.i_neighbour, 176+64, 176/2+32, info_R.preddata16_Y.data, info_R.preddata8_U.data, info_R.preddata8_V.data);
                }

                // phase & queue - jwlee
            }

            if ( R_Available )
            {  /* (class CGCXMErefgen) */
                int i;
                int i_mb_x = mb_index_Debl+1 % SPS_MB_WIDTH;
                int i_mb_y = mb_index_Debl+1 / SPS_MB_WIDTH;

                int offset = i_mb_y * 16 * (176+64) + i_mb_x * 16;
                int offset_c = i_mb_y * 8 * (176/2+32) + i_mb_x * 8;
                int stride = 176 + 64;
                int stride_c = 176/2 + 32;

                uint8_t *p_0 = plane0_1666 + offset;
                uint8_t *p_1 = filtered1_1670 + offset;
                uint8_t *p_2 = filtered2_1671 + offset;
                uint8_t *p_3 = filtered3_1672 + offset;
                uint8_t *p_4 = plane1_1667 + offset_c;
                uint8_t *p_5 = plane2_1668 + offset_c;

                /*
                   for (i = -16 ; i < 32 ; i++) {
                   memcpy(&info_R.ME_ref.data[0][(i+16)*48], &p_0[i * stride - 16], sizeof(uint8_t)*48);
                   memcpy(&info_R.ME_ref.data[1][(i+16)*48], &p_1[i * stride - 16], sizeof(uint8_t)*48);
                   memcpy(&info_R.ME_ref.data[2][(i+16)*48], &p_2[i * stride - 16], sizeof(uint8_t)*48);
                   memcpy(&info_R.ME_ref.data[3][(i+16)*48], &p_3[i * stride - 16], sizeof(uint8_t)*48);		
                   }    	

                   for (i = -8 ; i < 16 ; i++) {
                   memcpy(&info_R.ME_ref_chroma.data[0][(i+8)*24], &p_4[i * stride_c - 8], sizeof(uint8_t)*24);
                   memcpy(&info_R.ME_ref_chroma.data[1][(i+8)*24], &p_5[i * stride_c - 8], sizeof(uint8_t)*24);
                   }
                 */
                MQ_SEND(port_p42, (unsigned char *)&info_R, sizeof(neighbour_info));
                //if(count < 199)  printf("%d) R: %d\n",count, mb_index_Debl+1); 
            }

            //if ( LD_Available )
            if(!R_Available && !LD_Available && (mb_index_Debl != SPS_MB_WIDTH * SPS_MB_HEIGHT - 1))
            {  /* (class CGCXMErefgen) */
                int i;
                int i_mb_x = (mb_index_Debl+SPS_MB_WIDTH -1) % SPS_MB_WIDTH;
                int i_mb_y = (mb_index_Debl+SPS_MB_WIDTH -1) / SPS_MB_WIDTH;


                int offset = i_mb_y * 16 * (176+64) + i_mb_x * 16;
                int offset_c = i_mb_y * 8 * (176/2+32) + i_mb_x * 8;
                int stride = 176 + 64;
                int stride_c = 176/2 + 32;

                uint8_t *p_0 = plane0_1666 + offset;
                uint8_t *p_1 = filtered1_1670 + offset;
                uint8_t *p_2 = filtered2_1671 + offset;
                uint8_t *p_3 = filtered3_1672 + offset;
                uint8_t *p_4 = plane1_1667 + offset_c;
                uint8_t *p_5 = plane2_1668 + offset_c;
                /*
                   for (i = -16 ; i < 32 ; i++) {
                   memcpy(&info_LD.ME_ref.data[0][(i+16)*48], &p_0[i * stride - 16], sizeof(uint8_t)*48);
                   memcpy(&info_LD.ME_ref.data[1][(i+16)*48], &p_1[i * stride - 16], sizeof(uint8_t)*48);
                   memcpy(&info_LD.ME_ref.data[2][(i+16)*48], &p_2[i * stride - 16], sizeof(uint8_t)*48);
                   memcpy(&info_LD.ME_ref.data[3][(i+16)*48], &p_3[i * stride - 16], sizeof(uint8_t)*48);		
                   }    	

                   for (i = -8 ; i < 16 ; i++) {
                   memcpy(&info_LD.ME_ref_chroma.data[0][(i+8)*24], &p_4[i * stride_c - 8], sizeof(uint8_t)*24);
                   memcpy(&info_LD.ME_ref_chroma.data[1][(i+8)*24], &p_5[i * stride_c - 8], sizeof(uint8_t)*24);
                   }
                 */
                 
                MQ_SEND(port_p42, (unsigned char *)&info_LD, sizeof(neighbour_info));
                //if(count < 199)  printf("%d) LD: %d\n",count, mb_index_Debl+1); 
            }
       }
            //        } // 99 loop end
    } /* end repeat, depth 2*/
    // Frame encoding end
    if (mb_index_Debl == 98) // last macroblock
    {
        {
            int i;
            for(i=0;i<SPS_MB_WIDTH*SPS_MB_HEIGHT;i++)
            {
                MB_Available[i] = 0;
            }
        }

        output_1642 = d.intFrameType;

        {  /* XDeblockFilterI29 (class CGCXDeblockFilter) */
            int i;
            memcpy(recon_frame_Y_1613.data, recon_frame_Y_1599.data, (176+64) * (144+64)*sizeof(uint8_t));
            memcpy(recon_frame_U_1614.data, recon_frame_U_1600.data, (176/2 + 32) * (144/2 + 32)*sizeof(uint8_t));
            memcpy(recon_frame_V_1615.data, recon_frame_V_1601.data, (176/2 + 32) * (144/2 + 32)*sizeof(uint8_t));    	 
            x264_frame_deblocking_filter(output_1642, mb_frm_1609.data, nzc_frm_1610.data, ref_frm_1611.data, mv_frm_1612.data);
            x264_frame_expand_border();
            for (i = 0 ; i < 144 ; i++)
                memcpy(display_Y_1616.data + i * 176, plane0_1666+ i*(176+64), sizeof(char)*176);
            for (i = 0 ; i < 144/2 ; i++) {
                memcpy(display_U_1617.data + i * 176/2, plane1_1667+ i*((176+64)/2), sizeof(char)*176/2);
                memcpy(display_V_1618.data + i * 176/2, plane2_1668+ i*((176+64)/2), sizeof(char)*176/2);
            }
        }

        {  /* DeblockI82.XDisplayFrameI61 (class CGCXDisplayFrame) */
#ifdef DISPLAY
            unsigned char* frame[3];

            frame[0] = (unsigned char *)display_Y_1616.data;
            frame[1] = (unsigned char *)display_U_1617.data;
            frame[2] = (unsigned char *)display_V_1618.data;

            dither(frame);
#endif

#ifdef HKSIM_DISPLAY

            unsigned char* frame[3];

            frame[0] = (unsigned char *)display_Y_1616.data;
            frame[1] = (unsigned char *)display_U_1617.data;
            frame[2] = (unsigned char *)display_V_1618.data;

            printf("Display start!\n");
            convertRGB_HKSIM(frame[0], frame[1], frame[2], (unsigned short *)0x40000000, 352, 176);
            printf("Display end!\n");

#endif

#ifdef WINDOWS
            displayImage(display_Y_1616.data,display_U_1617.data,display_V_1618.data);
#endif
        }

    }
}



/////////////////////////////////////
// wrapup code
/////////////////////////////////////

TASK_WRAPUP
{
    // TODO: task wrapup code
    XCloseDisplay(display);
#ifdef DISPLAY
    exit_display();
#endif
#ifdef WINDOWS
    closeDisplay();
#endif
}

TASK_CODE_END
